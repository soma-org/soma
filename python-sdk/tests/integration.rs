// Copyright (c) Soma Contributors
// SPDX-License-Identifier: Apache-2.0

//! Integration tests for the Python SDK.
//!
//! These tests spin up a real test cluster (validators + fullnode) and exercise
//! the `soma_sdk` Python module via PyO3's in-process embedding.
//!
//! Because `test-cluster` is a dev-dependency, none of these heavyweight
//! dependencies are included in the published Python wheel.

use std::ffi::CString;
use std::sync::Once;

use pyo3::prelude::*;
use soma_keys::keystore::AccountKeystore;
// Import the companion module generated by `#[pymodule] pub fn soma_sdk(...)`.
// The crate is also named `soma_sdk`, so we alias to avoid shadowing.
use soma_sdk::soma_sdk as pymod;
use test_cluster::{TestCluster, TestClusterBuilder};

// ---------------------------------------------------------------------------
// Python module registration (replaces `maturin develop`)
// ---------------------------------------------------------------------------

static INIT: Once = Once::new();

/// Register the `soma_sdk` module in Python's built-in module table.
/// Must be called before any `Python::attach()`.
fn init_python() {
    INIT.call_once(|| {
        pyo3::append_to_inittab!(pymod);
        pyo3::Python::initialize();
    });
}

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

/// Extract the Bech32-encoded secret key for the pre-funded account at `idx`.
fn export_keypair_bech32(cluster: &TestCluster, idx: usize) -> (String, String) {
    let addr = cluster.get_addresses()[idx];
    let kp = cluster.wallet.config.keystore.export(&addr).unwrap();
    let encoded = kp.encode().unwrap(); // "somaprivkey1..."
    (addr.to_string(), encoded)
}

/// Run a Python snippet inside `spawn_blocking` so we never block the tokio
/// executor that the test cluster lives on.
async fn run_python(code: String) {
    tokio::task::spawn_blocking(move || {
        let c_code = CString::new(code).expect("Python code contains null bytes");
        Python::attach(|py| {
            py.run(&c_code, None, None)
                .map_err(|e: PyErr| {
                    e.print(py);
                    e
                })
                .expect("Python test failed");
        });
    })
    .await
    .expect("spawn_blocking panicked");
}

// ---------------------------------------------------------------------------
// Tests
// ---------------------------------------------------------------------------

/// Verify basic chain-info queries return valid data.
#[tokio::test(flavor = "multi_thread")]
async fn test_chain_info() {
    init_python();
    let cluster = TestClusterBuilder::new().build().await;
    let rpc_url = cluster.fullnode_handle.rpc_url.clone();

    run_python(format!(
        r#"
import asyncio
from soma_sdk import SomaClient

async def _test():
    client = await SomaClient("{rpc_url}")

    chain_id = await client.get_chain_identifier()
    assert isinstance(chain_id, str) and len(chain_id) > 0, \
        f"chain_id should be a non-empty string, got {{chain_id!r}}"

    version = await client.get_server_version()
    assert isinstance(version, str) and len(version) > 0, \
        f"server_version should be a non-empty string, got {{version!r}}"

    protocol = await client.get_protocol_version()
    assert isinstance(protocol, int) and protocol > 0, \
        f"protocol_version should be a positive int, got {{protocol!r}}"

asyncio.run(_test())
"#
    ))
    .await;
}

/// Verify `get_balance` returns a positive SOMA float for a pre-funded account.
#[tokio::test(flavor = "multi_thread")]
async fn test_get_balance() {
    init_python();
    let cluster = TestClusterBuilder::new().build().await;
    let rpc_url = cluster.fullnode_handle.rpc_url.clone();
    let (addr, _) = export_keypair_bech32(&cluster, 0);

    run_python(format!(
        r#"
import asyncio
from soma_sdk import SomaClient

async def _test():
    client = await SomaClient("{rpc_url}")
    balance = await client.get_balance("{addr}")
    assert isinstance(balance, float), \
        f"balance should be a float, got {{type(balance).__name__}}"
    assert balance > 0.0, \
        f"pre-funded balance should be > 0, got {{balance}}"

asyncio.run(_test())
"#
    ))
    .await;
}

/// Transfer 1.0 SOMA between two pre-funded accounts and verify balances.
#[tokio::test(flavor = "multi_thread")]
async fn test_transfer_coin() {
    init_python();
    let cluster = TestClusterBuilder::new().build().await;
    let rpc_url = cluster.fullnode_handle.rpc_url.clone();
    let (_, sender_secret) = export_keypair_bech32(&cluster, 0);
    let recipient_addr = cluster.get_addresses()[1].to_string();

    run_python(format!(
        r#"
import asyncio
from soma_sdk import SomaClient, Keypair

async def _test():
    client = await SomaClient("{rpc_url}")
    sender_kp = Keypair.from_secret_key("{sender_secret}")
    sender = sender_kp.address()

    balance_before = await client.get_balance(sender)
    await client.transfer_coin(signer=sender_kp, recipient="{recipient_addr}", amount=1.0)
    balance_after = await client.get_balance(sender)

    assert balance_after < balance_before, \
        f"sender balance should decrease: {{balance_before}} -> {{balance_after}}"

    recipient_balance = await client.get_balance("{recipient_addr}")
    assert recipient_balance > 0.0, \
        f"recipient should have a positive balance, got {{recipient_balance}}"

asyncio.run(_test())
"#
    ))
    .await;
}

/// Stake 1.0 SOMA with a validator and verify a StakedSoma object is created.
#[tokio::test(flavor = "multi_thread")]
async fn test_add_stake() {
    init_python();
    let cluster = TestClusterBuilder::new().build().await;
    let rpc_url = cluster.fullnode_handle.rpc_url.clone();
    let (_, secret) = export_keypair_bech32(&cluster, 0);

    run_python(format!(
        r#"
import asyncio
from soma_sdk import SomaClient, Keypair

async def _test():
    client = await SomaClient("{rpc_url}")
    kp = Keypair.from_secret_key("{secret}")
    sender = kp.address()

    state = await client.get_latest_system_state()
    validator_addr = state.validators.validators[0].metadata.soma_address

    balance_before = await client.get_balance(sender)
    await client.add_stake(signer=kp, validator=validator_addr, amount=1.0)
    balance_after = await client.get_balance(sender)

    assert balance_after < balance_before, \
        f"balance should decrease after staking: {{balance_before}} -> {{balance_after}}"

    staked = await client.list_owned_objects(sender, object_type="staked_soma")
    assert len(staked) >= 1, \
        f"should have at least 1 StakedSoma object, got {{len(staked)}}"

asyncio.run(_test())
"#
    ))
    .await;
}

// ---------------------------------------------------------------------------
// New comprehensive tests
// ---------------------------------------------------------------------------

/// Extract the scoring URL from the test cluster's validator config.
fn extract_scoring_url(cluster: &TestCluster) -> String {
    cluster.swarm.config().validator_configs[0]
        .scoring_url
        .clone()
        .expect("TestCluster should set scoring_url on validators")
}

/// Test static utility methods (no cluster needed).
#[tokio::test(flavor = "multi_thread")]
async fn test_static_utilities() {
    init_python();

    run_python(
        r#"
import asyncio
from soma_sdk import SomaClient

# encrypt/decrypt roundtrip
raw = b"hello world" * 100
encrypted, key = SomaClient.encrypt_weights(raw)
assert encrypted != raw, "encrypted should differ from raw"
decrypted = SomaClient.decrypt_weights(encrypted, key)
assert decrypted == raw, "decrypt(encrypt(x)) should equal x"

# encrypt with explicit key (bytes)
encrypted2, key2 = SomaClient.encrypt_weights(raw, bytes.fromhex(key))
assert key2 == key, "same key should be returned"
assert encrypted2 == encrypted, "same key should produce same ciphertext"

# commitment
h = SomaClient.commitment(raw)
assert isinstance(h, str) and len(h) == 64, \
    f"commitment should be 64-char hex, got {h!r}"
assert SomaClient.commitment(raw) == h, "commitment should be deterministic"

# different data → different commitment
h2 = SomaClient.commitment(b"different data")
assert h2 != h, "different data should produce different commitment"

# to_shannons / to_soma
assert SomaClient.to_shannons(1.0) == 1_000_000_000, "1 SOMA = 1e9 shannons"
assert SomaClient.to_shannons(0.5) == 500_000_000
assert SomaClient.to_soma(1_000_000_000) == 1.0
assert SomaClient.to_soma(500_000_000) == 0.5
"#
        .to_string(),
    )
    .await;
}

/// Test Keypair methods (no cluster needed).
#[tokio::test(flavor = "multi_thread")]
async fn test_keypair_operations() {
    init_python();

    run_python(
        r#"
import asyncio
from soma_sdk import Keypair

kp = Keypair.generate()
addr = kp.address()
assert isinstance(addr, str) and len(addr) > 0, \
    f"address should be non-empty string, got {addr!r}"

# to_secret_key → from_secret_key roundtrip (hex)
secret_hex = kp.to_secret_key()
assert isinstance(secret_hex, str) and len(secret_hex) > 0
kp2 = Keypair.from_secret_key(secret_hex)
assert kp2.address() == addr, "from_secret_key(hex) should restore same address"

# from_secret_key with raw bytes
kp3 = Keypair.from_secret_key(bytes.fromhex(secret_hex))
assert kp3.address() == addr, "from_secret_key(bytes) should restore same address"

# Two generated keypairs have different addresses
kp5 = Keypair.generate()
assert kp5.address() != kp.address(), "generated keypairs should be unique"

# from_mnemonic — standard 12-word BIP39 phrase
mnemonic = "abandon " * 11 + "about"
kp6 = Keypair.from_mnemonic(mnemonic)
addr6 = kp6.address()
assert isinstance(addr6, str) and len(addr6) > 0, \
    f"from_mnemonic should produce a valid address, got {addr6!r}"
# Deterministic — same mnemonic gives same address
kp7 = Keypair.from_mnemonic(mnemonic)
assert kp7.address() == addr6, "from_mnemonic should be deterministic"
"#
        .to_string(),
    )
    .await;
}

/// Test chain parameter queries.
#[tokio::test(flavor = "multi_thread")]
async fn test_chain_parameters() {
    init_python();
    let cluster = TestClusterBuilder::new().build().await;
    let rpc_url = cluster.fullnode_handle.rpc_url.clone();

    run_python(format!(
        r#"
import asyncio
from soma_sdk import SomaClient

async def _test():
    client = await SomaClient("{rpc_url}")

    arch = await client.get_architecture_version()
    assert isinstance(arch, int) and arch > 0, \
        f"architecture_version should be positive int, got {{arch!r}}"

    dim = await client.get_embedding_dim()
    assert isinstance(dim, int) and dim > 0, \
        f"embedding_dim should be positive int, got {{dim!r}}"

    min_stake = await client.get_model_min_stake()
    assert isinstance(min_stake, int) and min_stake > 0, \
        f"model_min_stake should be positive int, got {{min_stake!r}}"

    # check_api_version should not raise
    await client.check_api_version()

asyncio.run(_test())
"#
    ))
    .await;
}

/// Deep validation of `get_latest_system_state`.
#[tokio::test(flavor = "multi_thread")]
async fn test_system_state() {
    init_python();
    let cluster = TestClusterBuilder::new().build().await;
    let rpc_url = cluster.fullnode_handle.rpc_url.clone();

    run_python(format!(
        r#"
import asyncio
from soma_sdk import SomaClient

async def _test():
    client = await SomaClient("{rpc_url}")
    state = await client.get_latest_system_state()

    assert isinstance(state.epoch, int) and state.epoch >= 0, \
        f"epoch should be non-negative int, got {{state.epoch!r}}"
    assert isinstance(state.protocol_version, int) and state.protocol_version > 0, \
        f"protocol_version should be positive, got {{state.protocol_version!r}}"
    assert isinstance(state.epoch_start_timestamp_ms, int)

    # Validators
    vs = state.validators
    assert isinstance(vs.total_stake, int) and vs.total_stake > 0
    assert len(vs.validators) > 0, "should have at least 1 validator"

    v = vs.validators[0]
    assert isinstance(v.metadata.soma_address, str) and len(v.metadata.soma_address) > 0
    assert isinstance(v.voting_power, int)
    assert isinstance(v.commission_rate, int)

    # Staking pool
    pool = v.staking_pool
    assert isinstance(pool.id, str)
    assert isinstance(pool.soma_balance, int) and pool.soma_balance > 0

    # Parameters
    params = state.parameters
    assert isinstance(params.epoch_duration_ms, int)
    assert isinstance(params.model_min_stake, int)
    assert isinstance(params.target_embedding_dim, int)

    # Emission pool
    assert isinstance(state.emission_pool.balance, int)
    assert isinstance(state.emission_pool.emission_per_epoch, int)

asyncio.run(_test())
"#
    ))
    .await;
}

/// Test `get_epoch` for current and specific epoch.
#[tokio::test(flavor = "multi_thread")]
async fn test_epoch_info() {
    init_python();
    let cluster = TestClusterBuilder::new().build().await;
    let rpc_url = cluster.fullnode_handle.rpc_url.clone();

    run_python(format!(
        r#"
import asyncio
from soma_sdk import SomaClient

async def _test():
    client = await SomaClient("{rpc_url}")

    # Current epoch (omit arg for latest)
    info = await client.get_epoch()
    assert isinstance(info.epoch, int), f"epoch should be int, got {{type(info.epoch).__name__}}"
    assert isinstance(info.first_checkpoint_id, int)
    assert isinstance(info.epoch_start_timestamp_ms, int)

    # Specific epoch (0)
    info0 = await client.get_epoch(0)
    assert info0.epoch == 0, f"expected epoch 0, got {{info0.epoch}}"

asyncio.run(_test())
"#
    ))
    .await;
}

/// Test epoch timestamp convenience methods.
#[tokio::test(flavor = "multi_thread")]
async fn test_epoch_timestamps() {
    init_python();
    let cluster = TestClusterBuilder::new().build().await;
    let rpc_url = cluster.fullnode_handle.rpc_url.clone();

    run_python(format!(
        r#"
import asyncio, time
from soma_sdk import SomaClient

async def _test():
    client = await SomaClient("{rpc_url}")

    next_ts = await client.get_next_epoch_timestamp()
    following_ts = await client.get_following_epoch_timestamp()

    now_ms = int(time.time() * 1000)

    assert isinstance(next_ts, int), f"next_ts should be int, got {{type(next_ts).__name__}}"
    assert isinstance(following_ts, int), f"following_ts should be int, got {{type(following_ts).__name__}}"

    # following must be strictly after next
    assert following_ts > next_ts, \
        f"following ({{following_ts}}) should be > next ({{next_ts}})"

    # Verify the gap equals epoch_duration_ms
    state = await client.get_latest_system_state()
    epoch_dur = state.parameters.epoch_duration_ms
    assert following_ts - next_ts == epoch_dur, \
        f"gap ({{following_ts - next_ts}}) should equal epoch_duration_ms ({{epoch_dur}})"

asyncio.run(_test())
"#
    ))
    .await;
}

/// Test checkpoint queries.
#[tokio::test(flavor = "multi_thread")]
async fn test_checkpoints() {
    init_python();
    let cluster = TestClusterBuilder::new().build().await;
    let rpc_url = cluster.fullnode_handle.rpc_url.clone();

    run_python(format!(
        r#"
import asyncio
from soma_sdk import SomaClient

async def _test():
    client = await SomaClient("{rpc_url}")

    cp = await client.get_latest_checkpoint()
    assert isinstance(cp.data.sequence_number, int)
    assert isinstance(cp.data.epoch, int)
    assert isinstance(cp.data.timestamp_ms, int)
    assert isinstance(cp.data.content_digest, str)

    # Fetch the same checkpoint by sequence number
    cp2 = await client.get_checkpoint_summary(cp.data.sequence_number)
    assert cp2.data.sequence_number == cp.data.sequence_number, \
        f"sequence mismatch: {{cp2.data.sequence_number}} != {{cp.data.sequence_number}}"

asyncio.run(_test())
"#
    ))
    .await;
}

/// Transfers flow (mirrors `transfers.py`): transfer_coin, pay_coins, list_owned_objects.
#[tokio::test(flavor = "multi_thread")]
async fn test_transfers_flow() {
    init_python();
    let cluster = TestClusterBuilder::new().build().await;
    let rpc_url = cluster.fullnode_handle.rpc_url.clone();
    let (_, sender_secret) = export_keypair_bech32(&cluster, 0);
    let addr1 = cluster.get_addresses()[1].to_string();
    let addr2 = cluster.get_addresses()[2].to_string();

    run_python(format!(
        r#"
import asyncio
from soma_sdk import SomaClient, Keypair

async def _test():
    client = await SomaClient("{rpc_url}")
    kp = Keypair.from_secret_key("{sender_secret}")
    sender = kp.address()

    # transfer_coin
    balance_before = await client.get_balance(sender)
    await client.transfer_coin(signer=kp, recipient="{addr1}", amount=0.5)
    balance_after = await client.get_balance(sender)
    assert balance_after < balance_before, \
        f"sender balance should decrease: {{balance_before}} -> {{balance_after}}"
    recip1_bal = await client.get_balance("{addr1}")
    assert recip1_bal > 0.0, f"recipient1 should have balance, got {{recip1_bal}}"

    # pay_coins (multi-send)
    balance_before = await client.get_balance(sender)
    await client.pay_coins(
        signer=kp,
        recipients=["{addr1}", "{addr2}"],
        amounts=[0.25, 0.25],
    )
    balance_after = await client.get_balance(sender)
    assert balance_after < balance_before, \
        f"sender balance should decrease after pay_coins: {{balance_before}} -> {{balance_after}}"
    recip2_bal = await client.get_balance("{addr2}")
    assert recip2_bal > 0.0, f"recipient2 should have balance, got {{recip2_bal}}"

    # list_owned_objects (coin filter)
    coins = await client.list_owned_objects(sender, object_type="coin")
    assert len(coins) >= 1, f"sender should own at least 1 coin, got {{len(coins)}}"
    assert hasattr(coins[0], 'id'), "coin object should have 'id'"
    assert hasattr(coins[0], 'version'), "coin object should have 'version'"
    assert hasattr(coins[0], 'digest'), "coin object should have 'digest'"

asyncio.run(_test())
"#
    ))
    .await;
}

/// Test `get_object` and `get_object_with_version`.
#[tokio::test(flavor = "multi_thread")]
async fn test_get_object() {
    init_python();
    let cluster = TestClusterBuilder::new().build().await;
    let rpc_url = cluster.fullnode_handle.rpc_url.clone();
    let (addr, _) = export_keypair_bech32(&cluster, 0);

    run_python(format!(
        r#"
import asyncio
from soma_sdk import SomaClient

async def _test():
    client = await SomaClient("{rpc_url}")

    # Get a coin object to query
    coins = await client.list_owned_objects("{addr}", object_type="coin")
    assert len(coins) >= 1, "should have at least 1 coin"
    coin = coins[0]

    # get_object
    obj = await client.get_object(coin.id)
    assert obj.id == coin.id, f"object id mismatch: {{obj.id}} != {{coin.id}}"

    # get_object_with_version
    obj_v = await client.get_object_with_version(coin.id, coin.version)
    assert obj_v.id == coin.id, f"object id mismatch: {{obj_v.id}} != {{coin.id}}"
    assert obj_v.version == coin.version, \
        f"version mismatch: {{obj_v.version}} != {{coin.version}}"

asyncio.run(_test())
"#
    ))
    .await;
}

/// Full staking lifecycle (mirrors `staking.py`): stake → advance epoch → withdraw.
#[tokio::test(flavor = "multi_thread")]
async fn test_staking_lifecycle() {
    init_python();
    let cluster = TestClusterBuilder::new().build().await;
    let rpc_url = cluster.fullnode_handle.rpc_url.clone();
    let (_, secret) = export_keypair_bech32(&cluster, 0);

    // Stage 1: Stake and verify
    run_python(format!(
        r#"
import asyncio, builtins
from soma_sdk import SomaClient, Keypair

async def _test():
    client = await SomaClient("{rpc_url}")
    kp = Keypair.from_secret_key("{secret}")
    sender = kp.address()

    state = await client.get_latest_system_state()
    validator_addr = state.validators.validators[0].metadata.soma_address

    balance_before = await client.get_balance(sender)
    await client.add_stake(signer=kp, validator=validator_addr, amount=1.0)
    balance_after = await client.get_balance(sender)
    assert balance_after < balance_before, \
        f"balance should decrease after staking: {{balance_before}} -> {{balance_after}}"

    staked = await client.list_owned_objects(sender, object_type="staked_soma")
    assert len(staked) >= 1, f"should have StakedSoma object, got {{len(staked)}}"
    builtins._staked_id = staked[0].id

asyncio.run(_test())
"#
    ))
    .await;

    // Advance epoch from Rust so the stake activates
    cluster.trigger_reconfiguration().await;

    // Stage 2: Withdraw stake
    run_python(format!(
        r#"
import asyncio, builtins
from soma_sdk import SomaClient, Keypair

async def _test():
    client = await SomaClient("{rpc_url}")
    kp = Keypair.from_secret_key("{secret}")
    sender = kp.address()

    balance_before = await client.get_balance(sender)
    await client.withdraw_stake(signer=kp, staked_soma_id=builtins._staked_id)
    balance_after = await client.get_balance(sender)
    assert balance_after > balance_before, \
        f"balance should increase after withdrawal: {{balance_before}} -> {{balance_after}}"

    staked = await client.list_owned_objects(sender, object_type="staked_soma")
    assert len(staked) == 0, f"should have no StakedSoma objects, got {{len(staked)}}"

asyncio.run(_test())
"#
    ))
    .await;
}

/// Full model lifecycle (mirrors `quickstart.py`):
/// commit → reveal → get_targets → get_model_manifests → score → submit → claim.
#[tokio::test(flavor = "multi_thread")]
async fn test_model_lifecycle() {
    init_python();
    let cluster = TestClusterBuilder::new().build().await;
    let rpc_url = cluster.fullnode_handle.rpc_url.clone();
    let scoring_url = extract_scoring_url(&cluster);
    let (_, secret) = export_keypair_bech32(&cluster, 0);

    // Stage 1: Commit model
    run_python(format!(
        r#"
import asyncio, builtins
from soma_sdk import SomaClient, Keypair

async def _test():
    client = await SomaClient("{rpc_url}", scoring_url="{scoring_url}")
    kp = Keypair.from_secret_key("{secret}")
    sender = kp.address()

    raw = b"\x00" * 1024
    encrypted, key = SomaClient.encrypt_weights(raw)

    dim = await client.get_embedding_dim()
    embedding = [0.1] * dim

    await client.commit_model(
        signer=kp,
        weights_url="http://example.com/weights.enc",
        encrypted_weights=encrypted,
        decryption_key=key,
        embedding=embedding,
        commission_rate=1000,
    )

    # Discover model_id from pending models in system state
    state = await client.get_latest_system_state()
    pending = vars(state.model_registry.pending_models)
    model_id = next(
        mid for mid, m in pending.items()
        if m.owner == sender
    )
    assert isinstance(model_id, str) and len(model_id) > 0, \
        f"model_id should be non-empty string, got {{model_id!r}}"

    builtins._model_id = model_id
    builtins._key = key
    builtins._embedding = embedding

asyncio.run(_test())
"#
    ))
    .await;

    // Advance epoch so model can be revealed
    cluster.trigger_reconfiguration().await;

    // Stage 2: Reveal model
    run_python(format!(
        r#"
import asyncio, builtins
from soma_sdk import SomaClient, Keypair

async def _test():
    client = await SomaClient("{rpc_url}", scoring_url="{scoring_url}")
    kp = Keypair.from_secret_key("{secret}")

    await client.reveal_model(
        signer=kp,
        model_id=builtins._model_id,
        decryption_key=builtins._key,
        embedding=builtins._embedding,
    )

asyncio.run(_test())
"#
    ))
    .await;

    // Advance epoch so targets are generated
    cluster.trigger_reconfiguration().await;

    // Stage 3: Get targets, model manifests, score, submit
    run_python(format!(
        r#"
import asyncio, builtins
from soma_sdk import SomaClient, Keypair

async def _test():
    client = await SomaClient("{rpc_url}", scoring_url="{scoring_url}")
    kp = Keypair.from_secret_key("{secret}")

    # get_targets
    targets = await client.get_targets(status="open")
    assert len(targets) > 0, f"should have open targets, got {{len(targets)}}"
    target = next(t for t in targets if builtins._model_id in t.model_ids)
    assert hasattr(target, 'embedding'), "target should have 'embedding'"
    assert hasattr(target, 'distance_threshold'), "target should have 'distance_threshold'"
    assert hasattr(target, 'reward_pool'), "target should have 'reward_pool'"

    # list_targets (paginated)
    lt = await client.list_targets(status="open")
    assert len(lt.targets) > 0, "list_targets should return targets"

    # get_model_manifests
    manifests = await client.get_model_manifests(target)
    assert len(manifests) >= 1, f"should have at least 1 manifest, got {{len(manifests)}}"
    assert hasattr(manifests[0], 'url'), "manifest should have 'url'"

    # score (mock scoring server returns deterministic results)
    test_data = b"test data for submission"
    result = await client.score(
        data_url="http://example.com/data.bin",
        models=manifests,
        target_embedding=target.embedding,
        data=test_data,
        seed=0,
    )
    assert isinstance(result.winner, int), f"winner should be int, got {{type(result.winner).__name__}}"
    assert isinstance(result.distance, list), "distance should be a list"
    assert isinstance(result.embedding, list), "embedding should be a list"

    # submit_data
    await client.submit_data(
        signer=kp,
        target_id=target.id,
        data=test_data,
        data_url="http://example.com/data.bin",
        model_id=target.model_ids[result.winner],
        embedding=result.embedding,
        distance_score=result.distance[result.winner],
    )

    builtins._target_id = target.id

asyncio.run(_test())
"#
    ))
    .await;

    // Advance epochs so rewards become claimable
    cluster.trigger_reconfiguration().await;
    cluster.trigger_reconfiguration().await;

    // Stage 4: Claim rewards
    run_python(format!(
        r#"
import asyncio, builtins
from soma_sdk import SomaClient, Keypair

async def _test():
    client = await SomaClient("{rpc_url}", scoring_url="{scoring_url}")
    kp = Keypair.from_secret_key("{secret}")
    sender = kp.address()

    balance_before = await client.get_balance(sender)
    await client.claim_rewards(signer=kp, target_id=builtins._target_id)
    balance_after = await client.get_balance(sender)
    assert balance_after > balance_before, \
        f"balance should increase after claiming: {{balance_before}} -> {{balance_after}}"

asyncio.run(_test())
"#
    ))
    .await;
}

/// Test `scoring_health` with the mock scoring server.
#[tokio::test(flavor = "multi_thread")]
async fn test_scoring_health() {
    init_python();
    let cluster = TestClusterBuilder::new().build().await;
    let rpc_url = cluster.fullnode_handle.rpc_url.clone();
    let scoring_url = extract_scoring_url(&cluster);

    run_python(format!(
        r#"
import asyncio
from soma_sdk import SomaClient

async def _test():
    client = await SomaClient("{rpc_url}", scoring_url="{scoring_url}")
    ok = await client.scoring_health()
    assert ok is True, f"scoring_health should return True, got {{ok!r}}"

asyncio.run(_test())
"#
    ))
    .await;
}
