//! A block is constructed differently from the implementation of mysticeti by
//! Mysten Labs. This version optimizes the latency of fast path (Byzantine
//! Reliable Broadcast) transactions.
//!
//! Byzantine Reliable Broadcast systems like FastPay can use certificates that
//! are composed of signature of 2f+1 authorities to guarantee
//! payment. As long as the verifying party knows who the correct authorities
//! are, they can confirm payment with cryptography alone.
//!
//! Mysticeti provides a more scalable approach when compared to FastPay due to
//! reduced signing. In FastPay, the bottleneck of
//! scalability was signature generation. With FastPay, signatures scale with
//! transactions per second. As more transactions hit the system, more
//! signatures must be generated, which eventually consumes the authorities'
//! resources, capping performance at approximately 7k TPS.
//!
//! Mysticeti reduces signing such that each authority only needs to produce one
//! signature per block, and a block can contain many transactions. The downside
//! is that to provide a certificate, the
//! proof would need to comprise the 2f+1 blocks that reference the block
//! containing the signature. Using a zk-proof would be an option, but seemed to
//! add unnecessary complexity and marry the chain to a particular zk
//! implementation.
//!
//! The optimal trade-off seems to be constructing a block header that contains
//! references to large data items like transactions and blocks, instead of
//! including all raw transactions. An author signs off on the block header. The
//! block type then includes a signed block header and the raw data referenced
//! in the block header (e.g., the full signed transactions).
//!
//! There is an additional field for block reference signatures. Block authors
//! must sign off on each block ref they include in their block. These
//! signatures are packed in the block so that for a certificate, the signatures
//! do not add to proof size.
//!
//! Verification of a block by other authorities is still fast because all
//! blockref signatures can be aggregated such that an authority only needs to
//! verify two signatures: the block header signature and the aggregate
//! signature of the blockrefs + blockref signatures.
//!
//! The number of signatures generated by an authority is higher than base
//! mysticeti, but scales in response to network size (2f+1 stake) rather than
//! TPS. Additionally, signatures do not need to be generated all at once, but
//! can be verified and signed as they come in over the network, giving the
//! authority the ability to distribute signing load over time.
//!
//! To certify a transaction, all that is required is: the SignedTransaction,
//! SignedBlockHeader, and the aggregate signature of 2f+1 authorities. This is
//! comparably much smaller than delivering 2f+1 full blocks as a certificate, has
//! minimal performance impacts, and allows the latency of a third party acting
//! on a transaction to be as long as it takes to get 2f+1 signatures on a block.
// TODO: need to rewrite the above section slightly since it is outdated.

// Large portions of this file was adapted from code written by Mysten Labs for Sui.
// TODO: Untested, used for types only. Need to double check logic on everything
// TODO: rework the test block to use the block header construct
// TODO: double check signature verification and switch to threshold BLS
// TODO: double check types to ensure they are optimal
// TODO: change how verification occurs such that going from unverified to verified
// happens via the type syste rather than a seperate verifier
use std::{
    fmt,
    hash::{Hash, Hasher},
};

use crate::{
    commit::CommitVote,
    digest::Digest,
    error::{SharedError, SharedResult},
    signed::Signed,
    verified::Verified,
};
use bytes::Bytes;
use enum_dispatch::enum_dispatch;
use fastcrypto_vdf::{class_group::discriminant::DISCRIMINANT_3072, vdf::wesolowski::DefaultVDF};
use serde::{Deserialize, Serialize};

use crate::{
    authority_committee::AuthorityIndex,
    transaction::{SignedTransaction, TransactionRef},
};

type Epoch = u64;

/// Round number of a block.
type Round = u32;

/// Round zero for the genesis round
const GENESIS_ROUND: Round = 0;

/// Block proposal timestamp in milliseconds.
type BlockTimestampMs = u64;

/// BlockHeader is an enum that switches on versions. Because BlockHeaders can be sent independently
/// over the wire, they need to be versioned seperately from Blocks.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[enum_dispatch(BlockHeaderAPI)]
pub enum BlockHeader {
    V1(BlockHeaderV1),
}

/// [`BlockHeader`] API exposes common fields. Functionality can be added, but should not be removed.
#[enum_dispatch]
pub trait BlockHeaderAPI {
    /// Returns the epoch
    fn epoch(&self) -> Epoch;
    /// Returns the round
    fn round(&self) -> Round;
    /// Returns the author authority index. Dependent on epoch.
    fn author(&self) -> AuthorityIndex;
    /// Returns the transaction refs
    fn transaction_refs(&self) -> &[TransactionRef];
    /// Returns the digest of the body
    fn block_body_digest(&self) -> Digest<BlockBody>;
}

/// [`BlockHeaderV1`] is the first version of the block header.
#[derive(Clone, Debug, Deserialize, Serialize)]
struct BlockHeaderV1 {
    /// The epoch that this block header was produced.
    epoch: Epoch,
    /// The round this blockheader was produced.
    round: Round,
    /// The authority index that authored the block. Authority index is tied with epoch.
    author: AuthorityIndex,
    /// vec of [`TransactionRef`], unlike sui's implementation where validators sign off
    /// on full transactions, here only transaction references are provided to keep block header size small.
    transaction_refs: Vec<TransactionRef>,
    /// block body digest. The header is signed, which refrences a digest of the body, making the two linked
    /// cryptographically. As long as the digest of the provided body matches what is specified, and the authority
    /// signed the header containing that digest, it holds the same security properties as the authority signing
    /// the entire block.
    //NOTE: very important! while typically we hold version specific structs, in this case the digest must be a
    // BlockBody NOT BlockBodyV1. This is because serialization / hashing will differ due to the enum variant.
    block_body_digest: Digest<BlockBody>,
}

impl BlockHeaderV1 {
    #[allow(clippy::too_many_arguments)]
    fn new(
        epoch: Epoch,
        round: Round,
        author: AuthorityIndex,
        transaction_refs: Vec<TransactionRef>,
        block_body_digest: Digest<BlockBody>,
    ) -> Self {
        Self {
            epoch,
            round,
            author,
            transaction_refs,
            block_body_digest,
        }
    }
}

impl BlockHeaderAPI for BlockHeaderV1 {
    fn epoch(&self) -> Epoch {
        self.epoch
    }

    fn round(&self) -> Round {
        self.round
    }

    fn author(&self) -> AuthorityIndex {
        self.author
    }

    fn transaction_refs(&self) -> &[TransactionRef] {
        &self.transaction_refs
    }

    fn block_body_digest(&self) -> Digest<BlockBody> {
        self.block_body_digest.clone()
    }
}

pub type TransactionIndex = u16;

/// Votes on transactions in a specific block.
/// Reject votes are explicit. The rest of transactions in the block receive implicit accept votes.
// TODO: look into making fields `pub`.
#[derive(Clone, Debug, Deserialize, Serialize)]
pub(crate) struct BlockTransactionVotes {
    pub(crate) block_ref: BlockRef,
    pub(crate) rejects: Vec<TransactionIndex>,
}

#[enum_dispatch]
pub trait BlockBodyAPI {
    fn timestamp_ms(&self) -> BlockTimestampMs;
    fn ancestors(&self) -> &[BlockRef];
    fn transactions(&self) -> &[SignedTransaction];
    fn commit_votes(&self) -> &[CommitVote];
    fn transaction_votes(&self) -> &[BlockTransactionVotes];
    fn misbehavior_reports(&self) -> &[MisbehaviorReport];
}

#[derive(Clone, Debug, Deserialize, Serialize)]
#[enum_dispatch(BlockBodyAPI)]
pub enum BlockBody {
    V1(BlockBodyV1),
}

#[derive(Clone, Debug, Deserialize, Serialize)]
struct BlockBodyV1 {
    timestamp_ms: BlockTimestampMs,
    ancestors: Vec<BlockRef>,
    transactions: Vec<SignedTransaction>,
    transaction_votes: Vec<BlockTransactionVotes>,
    commit_votes: Vec<CommitVote>,
    misbehavior_reports: Vec<MisbehaviorReport>,
}

impl BlockBodyAPI for BlockBodyV1 {
    fn timestamp_ms(&self) -> BlockTimestampMs {
        self.timestamp_ms
    }
    fn ancestors(&self) -> &[BlockRef] {
        &self.ancestors
    }
    fn transactions(&self) -> &[SignedTransaction] {
        &self.transactions
    }
    fn commit_votes(&self) -> &[CommitVote] {
        &self.commit_votes
    }
    fn transaction_votes(&self) -> &[BlockTransactionVotes] {
        &self.transaction_votes
    }
    fn misbehavior_reports(&self) -> &[MisbehaviorReport] {
        &self.misbehavior_reports
    }
}

/// A block includes references to previous round blocks and transactions that the authority
/// considers valid.
/// Well behaved authorities produce at most one block per round, but malicious authorities can
/// equivocate.
#[derive(Clone, Deserialize, Serialize)]
#[enum_dispatch(BlockAPI)]
enum Block {
    V1(BlockV1),
}

/// BlockAPI helps conform with the mysticeti derived code. Allows for accessing the raw
/// data e.g. transactions / misbehavior_reports / etc.
#[enum_dispatch]
trait BlockAPI {
    fn signed_header(&self) -> Signed<BlockHeader>;
    /// returns the block body
    fn body(&self) -> BlockBody;
}

/// BlockV1 is the first implementation of block
#[derive(Clone, Deserialize, Serialize)]
struct BlockV1 {
    // TODO: make this blockheader situation cleaner since the signed / enum
    // forces us to use a non-specific version which is less type safe. This
    // should be the version. Same issue with the digest in block header
    signed_block_header: Signed<BlockHeader>,
    block_body: BlockBodyV1,
}

impl BlockAPI for BlockV1 {
    fn signed_header(&self) -> Signed<BlockHeader> {
        self.signed_block_header.clone()
    }

    fn body(&self) -> BlockBody {
        BlockBody::V1(self.block_body.clone())
    }
}

/// `BlockRef` uniquely identifies a `BlockHeader` and indirectly a Block via `digest`. It also contains the slot
/// info (round and author) so it can be used in logic such as aggregating stakes for a round.
#[derive(Clone, Copy, Serialize, Deserialize, PartialEq, Eq, PartialOrd, Ord)]
pub struct BlockRef {
    /// returns the round for the blockheader
    round: Round,
    /// returns the author
    author: AuthorityIndex,
    /// the digest for a blockheader (this is the unique reference)
    digest: Digest<Signed<BlockHeader>>,
}

impl BlockRef {
    /// MIN for lex
    const MIN: Self = Self {
        round: 0,
        author: AuthorityIndex::MIN,
        digest: Digest::MIN,
    };

    /// MIN for lex
    const MAX: Self = Self {
        round: u32::MAX,
        author: AuthorityIndex::MAX,
        digest: Digest::MAX,
    };

    /// creates a new block header ref
    pub fn new(round: Round, author: AuthorityIndex, digest: Digest<Signed<BlockHeader>>) -> Self {
        Self {
            round,
            author,
            digest,
        }
    }
}

// TODO: re-evaluate formats for production debugging.
impl fmt::Display for BlockRef {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {
        write!(f, "B{}({},{})", self.round, self.author, self.digest)
    }
}

impl fmt::Debug for BlockRef {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {
        write!(f, "B{}({},{:?})", self.round, self.author, self.digest)
    }
}

impl Hash for BlockRef {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.digest.hash(state);
    }
}
/// A block can attach reports of misbehavior by other authorities.
#[derive(Clone, Serialize, Deserialize, Debug)]
struct MisbehaviorReport {
    /// the author being reported
    target: AuthorityIndex,
    /// An enum to switch on different proofs
    proof: MisbehaviorProof,
}

/// Proof of misbehavior are usually signed block(s) from the misbehaving authority.
#[derive(Clone, Serialize, Deserialize, Debug)]
enum MisbehaviorProof {
    /// Proof of an invalid block
    InvalidBlock(BlockRef),
}

/// `MisbehaviorReportRef` uniquely identifies a `VerifiedMisbehaviorReport` via `digest`. It also contains the slot
/// info (round and author) so it can be used in logic such as aggregating stakes for a round.
#[derive(Clone, Copy, Serialize, Deserialize, PartialEq, Eq, PartialOrd, Ord)]
struct MisbehaviorReportRef {
    /// digest is a hash of the misbehavior report to create a constantly sized report
    digest: Digest<MisbehaviorReport>,
}

impl MisbehaviorReportRef {
    /// lexigraphical min
    const MIN: Self = Self {
        digest: Digest::MIN,
    };

    /// lexigraphical max
    const MAX: Self = Self {
        digest: Digest::MAX,
    };

    /// creates a new misbehavior report ref
    const fn new(digest: Digest<MisbehaviorReport>) -> Self {
        Self { digest }
    }
}

// TODO: re-evaluate formats for production debugging.
impl fmt::Display for MisbehaviorReportRef {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {
        write!(f, "T{}", self.digest)
    }
}

impl fmt::Debug for MisbehaviorReportRef {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {
        write!(f, "T{}", self.digest)
    }
}

impl Hash for MisbehaviorReportRef {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.digest.hash(state)
    }
}
