//! A block is constructed differently from the implementation of mysticeti by
//! Mysten Labs. This version optimizes the latency of fast path (Byzantine
//! Reliable Broadcast) transactions.
//!
//! Byzantine Reliable Broadcast systems like FastPay can use certificates that
//! are composed of signature of 2f+1 authorities to guarantee
//! payment. As long as the verifying party knows who the correct authorities
//! are, they can confirm payment with cryptography alone.
//!
//! Mysticeti provides a more scalable approach when compared to FastPay due to
//! reduced signing. In FastPay, the bottleneck of
//! scalability was signature generation. With FastPay, signatures scale with
//! transactions per second. As more transactions hit the system, more
//! signatures must be generated, which eventually consumes the authorities'
//! resources, capping performance at approximately 7k TPS.
//!
//! Mysticeti reduces signing such that each authority only needs to produce one
//! signature per block, and a block can contain many transactions. The downside
//! is that to provide a certificate, the
//! proof would need to comprise the 2f+1 blocks that reference the block
//! containing the signature. Using a zk-proof would be an option, but seemed to
//! add unnecessary complexity and marry the chain to a particular zk
//! implementation.
//!
//! The optimal trade-off seems to be constructing a block header that contains
//! references to large data items like transactions and blocks, instead of
//! including all raw transactions. An author signs off on the block header. The
//! block type then includes a signed block header and the raw data referenced
//! in the block header (e.g., the full signed transactions).
//!
//! There is an additional field for block reference signatures. Block authors
//! must sign off on each block ref they include in their block. These
//! signatures are packed in the block so that for a certificate, the signatures
//! do not add to proof size.
//!
//! Verification of a block by other authorities is still fast because all
//! blockref signatures can be aggregated such that an authority only needs to
//! verify two signatures: the block header signature and the aggregate
//! signature of the blockrefs + blockref signatures.
//!
//! The number of signatures generated by an authority is higher than base
//! mysticeti, but scales in response to network size (2f+1 stake) rather than
//! TPS. Additionally, signatures do not need to be generated all at once, but
//! can be verified and signed as they come in over the network, giving the
//! authority the ability to distribute signing load over time.
//!
//! To certify a transaction, all that is required is: the SignedTransaction,
//! SignedBlockHeader, and the aggregate signature of 2f+1 authorities. This is
//! comparably much smaller than delivering 2f+1 full blocks as a certificate, has
//! minimal performance impacts, and allows the latency of a third party acting
//! on a transaction to be as long as it takes to get 2f+1 signatures on a block.

// Large portions of this file was adapted from code written by Mysten Labs for Sui.
// TODO: Untested, used for types only. Need to double check logic on everything
// TODO: rework the test block to use the block header construct
// TODO: double check signature verification and switch to threshold BLS
// TODO: double check types to ensure they are optimal
// TODO: change how verification occurs such that going from unverified to verified
// happens via the type syste rather than a seperate verifier
use std::{
    fmt,
    hash::{Hash, Hasher},
    ops::Deref,
    sync::Arc,
};

use crate::crypto::keys::{ProtocolKeyPair, ProtocolKeySignature, ProtocolPublicKey};
use bytes::Bytes;
use enum_dispatch::enum_dispatch;
use fastcrypto::hash::{Digest, HashFunction};
use serde::{Deserialize, Serialize};
// use shared_crypto::intent::{Intent, IntentMessage, IntentScope};

use crate::{
    crypto::{DefaultHashFunction, DIGEST_LENGTH},
    ensure,
    error::ShardError,
    error::ShardResult,
    types::authority_committee::{AuthorityIndex, Epoch},
    types::commit::CommitVote,
    types::context::Context,
    types::transaction::{SignedTransaction, TransactionRef},
};

use crate::types::scope::{Scope, ScopedMessage, VersionedScope};

/// Round number of a block.
type Round = u32;

/// Round zero for the genesis round
const GENESIS_ROUND: Round = 0;

/// Block proposal timestamp in milliseconds.
type BlockTimestampMs = u64;

/// BlockHeader is an enum that switches on versions. Because BlockHeaders can be sent independently
/// over the wire, they need to be versioned seperately from Blocks.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[enum_dispatch(BlockHeaderAPI)]
pub(crate) enum BlockHeader {
    V1(BlockHeaderV1),
}

/// [`BlockHeader`] API exposes common fields. Functionality can be added, but should not be removed.
#[enum_dispatch]
trait BlockHeaderAPI {
    /// Returns the epoch
    fn epoch(&self) -> Epoch;
    /// Returns the round
    fn round(&self) -> Round;
    /// Returns the author authority index. Dependent on epoch.
    fn author(&self) -> AuthorityIndex;
    /// Returns the block timestamp in ms
    fn timestamp_ms(&self) -> BlockTimestampMs;
    /// Returns the block header refs
    fn block_header_refs(&self) -> &[BlockHeaderRef];
    /// Returns the transaction refs
    fn transaction_refs(&self) -> &[TransactionRef];
    /// Returns the commit votes
    fn commit_votes(&self) -> &[CommitVote];
    /// Returns the misbehavior report refs
    fn misbehavior_report_refs(&self) -> &[MisbehaviorReportRef];
}

/// [`BlockHeaderV1`] is the first version of the block header.
#[derive(Clone, Debug, Deserialize, Serialize)]
struct BlockHeaderV1 {
    /// The epoch that this block header was produced.
    epoch: Epoch,
    /// The round this blockheader was produced.
    round: Round,
    /// The authority index that authored the block. Authority index is tied with epoch.
    author: AuthorityIndex,
    /// the timestamp ms
    // TODO: during verification ensure that timestamp_ms >= ancestors.timestamp
    timestamp_ms: BlockTimestampMs,
    /// vec of [`BlockHeaderRef`], references block headers
    block_header_refs: Vec<BlockHeaderRef>,
    /// vec of [`TransactionRef`], unlike sui's implementation where validators sign off
    /// on full transactions, here only transaction references are signed to keep block header size small.
    transaction_refs: Vec<TransactionRef>,
    /// alias for commit reference
    commit_votes: Vec<CommitVote>, // alias for commit reference
    /// Again, misbehavior reports are converted to references.
    misbehavior_report_refs: Vec<MisbehaviorReportRef>,
}

impl BlockHeaderV1 {
    /// Creates a new blockheader
    // TODO: switch to having an impl on blockheader enum that can create versions.
    #[allow(clippy::too_many_arguments)]
    fn new(
        epoch: Epoch,
        round: Round,
        author: AuthorityIndex,
        timestamp_ms: BlockTimestampMs,
        block_header_refs: Vec<BlockHeaderRef>,
        transaction_refs: Vec<TransactionRef>,
        commit_votes: Vec<CommitVote>,
        misbehavior_report_refs: Vec<MisbehaviorReportRef>,
    ) -> Self {
        Self {
            epoch,
            round,
            author,
            timestamp_ms,
            block_header_refs,
            transaction_refs,
            commit_votes,
            misbehavior_report_refs,
        }
    }

    /// creates a genesis (empty) block
    fn genesis_block(epoch: Epoch, author: AuthorityIndex) -> Self {
        Self {
            epoch,
            round: GENESIS_ROUND,
            author,
            timestamp_ms: 0,
            block_header_refs: vec![],
            transaction_refs: vec![],
            commit_votes: vec![],
            misbehavior_report_refs: vec![],
        }
    }
}

impl BlockHeaderAPI for BlockHeaderV1 {
    fn epoch(&self) -> Epoch {
        self.epoch
    }

    fn round(&self) -> Round {
        self.round
    }

    fn author(&self) -> AuthorityIndex {
        self.author
    }

    fn timestamp_ms(&self) -> BlockTimestampMs {
        self.timestamp_ms
    }

    fn block_header_refs(&self) -> &[BlockHeaderRef] {
        &self.block_header_refs
    }

    fn transaction_refs(&self) -> &[TransactionRef] {
        &self.transaction_refs
    }

    fn commit_votes(&self) -> &[CommitVote] {
        &self.commit_votes
    }

    fn misbehavior_report_refs(&self) -> &[MisbehaviorReportRef] {
        &self.misbehavior_report_refs
    }
}

/// A [`BlockHeader`] with its signature, before they are verified.
///
/// Note: `BlockHeaderDigest` is computed over this struct, so any added field (without `#[serde(skip)]`)
/// will affect the values of `BlockHeaderDigest` and `BlockHeaderRef`.
#[derive(Clone, Debug, Deserialize, Serialize)]
pub(crate) struct SignedBlockHeader {
    inner: BlockHeader,
    signature: Bytes,
}

impl SignedBlockHeader {
    /// Should only be used when constructing the genesis blocks
    fn new_genesis(block_header: BlockHeader) -> Self {
        Self {
            inner: block_header,
            signature: Bytes::default(),
        }
    }

    /// Creates a signed block header using a protocol keypair and a supplied block header
    fn new(block_header: BlockHeader, protocol_keypair: &ProtocolKeyPair) -> ShardResult<Self> {
        let signature = compute_block_header_signature(&block_header, protocol_keypair)?;
        Ok(Self {
            inner: block_header,
            signature: Bytes::copy_from_slice(signature.to_bytes()),
        })
    }

    /// Returns the block header signature
    const fn signature(&self) -> &Bytes {
        &self.signature
    }

    /// This method only verifies this block's signature. Verification of the full block
    /// should be done via BlockVerifier.
    fn verify_signature(&self, context: &Context) -> ShardResult<()> {
        let block_header = &self.inner;
        let committee = &context.authority_committee;
        ensure!(
            committee.is_valid_index(block_header.author()),
            ShardError::InvalidAuthorityIndex {
                index: block_header.author(),
                max: committee.size() - 1
            }
        );
        let authority = committee.authority(block_header.author());
        verify_block_header_signature(block_header, self.signature(), &authority.protocol_key)
    }

    /// Serialises the block using the bcs serializer
    fn serialize(&self) -> Result<Bytes, bcs::Error> {
        let bytes = bcs::to_bytes(self)?;
        Ok(bytes.into())
    }

    /// Clears signature for testing.
    #[cfg(test)]
    fn clear_signature(&mut self) {
        self.signature = Bytes::default();
    }
}

/// Digest of a block, covering all `BlockHeader` fields without its signature.
/// This is used during Block signing and signature verification.
/// This should never be used outside of this file, to avoid confusion with `BlockDigest`.
#[derive(Serialize, Deserialize)]
struct InnerBlockHeaderDigest([u8; DIGEST_LENGTH]);

/// Computes the digest of a Block, only for signing and verifications.
fn compute_inner_block_header_digest(block: &BlockHeader) -> ShardResult<InnerBlockHeaderDigest> {
    let mut hasher = DefaultHashFunction::new();
    hasher.update(bcs::to_bytes(block).map_err(ShardError::SerializationFailure)?);
    Ok(InnerBlockHeaderDigest(hasher.finalize().into()))
}

/// Wrap a InnerBlockDigest in the intent message.
fn to_consensus_block_header_scoped_message(
    digest: InnerBlockHeaderDigest,
) -> ScopedMessage<InnerBlockHeaderDigest> {
    ScopedMessage::new(Scope::ConsensusBlockHeader, digest)
}

/// Process for signing & verying a block signature:
/// 1. Compute the digest of `Block`.
/// 2. Wrap the digest in `IntentMessage`.
/// 3. Sign the serialized `IntentMessage`, or verify signature against it.
fn compute_block_header_signature(
    block_header: &BlockHeader,
    protocol_keypair: &ProtocolKeyPair,
) -> ShardResult<ProtocolKeySignature> {
    let digest = compute_inner_block_header_digest(block_header)?;
    let message = bcs::to_bytes(&to_consensus_block_header_scoped_message(digest))
        .map_err(ShardError::SerializationFailure)?;
    Ok(protocol_keypair.sign(&message))
}
/// verifies a block header signature
fn verify_block_header_signature(
    block_header: &BlockHeader,
    signature: &[u8],
    protocol_pubkey: &ProtocolPublicKey,
) -> ShardResult<()> {
    let digest = compute_inner_block_header_digest(block_header)?;
    let message = bcs::to_bytes(&to_consensus_block_header_scoped_message(digest))
        .map_err(ShardError::SerializationFailure)?;
    let sig =
        ProtocolKeySignature::from_bytes(signature).map_err(ShardError::MalformedSignature)?;
    protocol_pubkey
        .verify(&message, &sig)
        .map_err(ShardError::SignatureVerificationFailure)
}

/// Allow quick access on the underlying Block without having to always refer to the inner block ref.
impl Deref for SignedBlockHeader {
    type Target = BlockHeader;

    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

/// VerifiedBlockHeader allows full access to its content.
/// Note: clone() is relatively cheap with most underlying data refcounted.
#[derive(Clone)]
struct VerifiedBlockHeader {
    block_header: Arc<SignedBlockHeader>,
    digest: BlockHeaderDigest,
    serialized: Bytes,
}

impl VerifiedBlockHeader {
    /// Creates VerifiedBlockHeader from a verified SignedBlockHeader and its serialized bytes.
    fn new_verified(
        block_header: SignedBlockHeader,
        digest: BlockHeaderDigest,
        serialized: Bytes,
    ) -> Self {
        Self {
            block_header: Arc::new(block_header),
            digest,
            serialized,
        }
    }
}

/// A block includes references to previous round blocks and transactions that the authority
/// considers valid.
/// Well behaved authorities produce at most one block per round, but malicious authorities can
/// equivocate.
#[derive(Clone, Deserialize, Serialize)]
#[enum_dispatch(BlockAPI)]
enum Block {
    V1(BlockV1),
}

impl Block {
    /// Serializes a block into bytes
    fn serialize(&self) -> Result<Bytes, bcs::Error> {
        let bytes = bcs::to_bytes(self)?;
        Ok(bytes.into())
    }
}
/// BlockAPI helps conform with the mysticeti derived code. Allows for accessing the raw
/// data e.g. transactions / misbehavior_reports / etc.
#[enum_dispatch]
trait BlockAPI {
    /// returns the epoch
    fn epoch(&self) -> Epoch;
    /// returns the round
    fn round(&self) -> Round;
    /// returns the author (epoch dependent)
    fn author(&self) -> AuthorityIndex;
    /// returns the slot
    fn slot(&self) -> Slot;
    /// returns the timestamp in ms
    fn timestamp_ms(&self) -> BlockTimestampMs;
    /// returns the block header refs
    fn block_header_refs(&self) -> &[BlockHeaderRef];
    /// returns the transactions directly (dereferenced)
    fn transactions(&self) -> &[SignedTransaction];
    /// returns the commit votes
    fn commit_votes(&self) -> &[CommitVote];
    /// returns the misbehavior reports (dereferenced)
    fn misbehavior_reports(&self) -> &[MisbehaviorReport];
}

/// BlockV1 is the first implementation of block
#[derive(Clone, Deserialize, Serialize)]
struct BlockV1 {
    /// signed header is the block header and author signature. From this is created the block header digest
    signed_header: SignedBlockHeader,
    /// contains the actual signatures from the block author which can be used to create agg signatures for
    /// the certificates of 2f+1 for a given block
    signed_block_header_refs: Vec<ProtocolKeySignature>,
    /// full non-referenced signed transactions
    transactions: Vec<SignedTransaction>,
    /// full non-referenced misbehavior reports
    misbehavior_reports: Vec<MisbehaviorReport>,
}

impl BlockV1 {
    /// creates a new blockv1, should switch to add new_v1 to Block enum impl
    fn new(
        signed_header: SignedBlockHeader,
        signed_block_header_refs: Vec<ProtocolKeySignature>,
        transactions: Vec<SignedTransaction>,
        misbehavior_reports: Vec<MisbehaviorReport>,
    ) -> BlockV1 {
        Self {
            signed_header,
            signed_block_header_refs,
            transactions,
            misbehavior_reports,
        }
    }

    /// Creates a genesis block
    fn genesis_block(epoch: Epoch, author: AuthorityIndex) -> Self {
        Self {
            signed_header: SignedBlockHeader::new_genesis(BlockHeader::V1(
                BlockHeaderV1::genesis_block(epoch, author),
            )),
            signed_block_header_refs: vec![],
            transactions: vec![],
            misbehavior_reports: vec![],
        }
    }
}

impl BlockAPI for BlockV1 {
    fn epoch(&self) -> Epoch {
        self.signed_header.epoch()
    }

    fn round(&self) -> Round {
        self.signed_header.round()
    }

    fn author(&self) -> AuthorityIndex {
        self.signed_header.author()
    }

    fn slot(&self) -> Slot {
        Slot::new(self.signed_header.round(), self.signed_header.author())
    }

    fn timestamp_ms(&self) -> BlockTimestampMs {
        self.signed_header.timestamp_ms()
    }

    fn block_header_refs(&self) -> &[BlockHeaderRef] {
        self.signed_header.block_header_refs()
    }

    fn transactions(&self) -> &[SignedTransaction] {
        &self.transactions
    }

    fn commit_votes(&self) -> &[CommitVote] {
        self.signed_header.commit_votes()
    }

    fn misbehavior_reports(&self) -> &[MisbehaviorReport] {
        &self.misbehavior_reports
    }
}

/// `BlockHeaderRef` uniquely identifies a `BlockHeader` and indirectly a Block via `digest`. It also contains the slot
/// info (round and author) so it can be used in logic such as aggregating stakes for a round.
#[derive(Clone, Copy, Serialize, Deserialize, Default, PartialEq, Eq, PartialOrd, Ord)]
struct BlockHeaderRef {
    /// returns the round for the blockheader
    round: Round,
    /// returns the author
    author: AuthorityIndex,
    /// the digest for a blockheader (this is the unique reference)
    digest: BlockHeaderDigest,
}

impl BlockHeaderRef {
    /// MIN for lex
    const MIN: Self = Self {
        round: 0,
        author: AuthorityIndex::MIN,
        digest: BlockHeaderDigest::MIN,
    };

    /// MIN for lex
    const MAX: Self = Self {
        round: u32::MAX,
        author: AuthorityIndex::MAX,
        digest: BlockHeaderDigest::MAX,
    };

    /// creates a new block header ref
    fn new(round: Round, author: AuthorityIndex, digest: BlockHeaderDigest) -> Self {
        Self {
            round,
            author,
            digest,
        }
    }
}

// TODO: re-evaluate formats for production debugging.
impl fmt::Display for BlockHeaderRef {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {
        write!(f, "B{}({},{})", self.round, self.author, self.digest)
    }
}

impl fmt::Debug for BlockHeaderRef {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {
        write!(f, "B{}({},{:?})", self.round, self.author, self.digest)
    }
}

impl Hash for BlockHeaderRef {
    fn hash<H: Hasher>(&self, state: &mut H) {
        state.write(&self.digest.0[..8]);
    }
}

/// Digest of a `VerifiedBlockHeader` or verified `SignedBlockHeader`, which covers the `BlockHeader` and its
/// signature.
///
/// Note: the signature algorithm is assumed to be non-malleable, so it is impossible for another
/// party to create an altered but valid signature, producing an equivocating `BlockHeaderDigest`.
#[derive(Clone, Copy, Serialize, Deserialize, Default, PartialEq, Eq, PartialOrd, Ord)]
struct BlockHeaderDigest([u8; DIGEST_LENGTH]);

impl BlockHeaderDigest {
    /// Lexicographic min & max digest.
    const MIN: Self = Self([u8::MIN; DIGEST_LENGTH]);
    /// Lexicographic min & max digest.
    const MAX: Self = Self([u8::MAX; DIGEST_LENGTH]);
}

impl Hash for BlockHeaderDigest {
    fn hash<H: Hasher>(&self, state: &mut H) {
        state.write(&self.0[..8]);
    }
}

impl From<BlockHeaderDigest> for Digest<{ DIGEST_LENGTH }> {
    fn from(hd: BlockHeaderDigest) -> Self {
        Digest::new(hd.0)
    }
}

impl fmt::Display for BlockHeaderDigest {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {
        write!(
            f,
            "{}",
            base64::Engine::encode(&base64::engine::general_purpose::STANDARD, self.0)
                .get(0..4)
                .ok_or(fmt::Error)?
        )
    }
}

impl fmt::Debug for BlockHeaderDigest {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {
        write!(
            f,
            "{}",
            base64::Engine::encode(&base64::engine::general_purpose::STANDARD, self.0)
        )
    }
}

impl AsRef<[u8]> for BlockHeaderDigest {
    fn as_ref(&self) -> &[u8] {
        &self.0
    }
}

/// Slot is the position of blocks in the DAG. It can contain 0, 1 or multiple blocks
/// from the same authority at the same round.
#[derive(Clone, Copy, PartialEq, PartialOrd, Default, Hash)]
struct Slot {
    /// round
    round: Round,
    /// authority (dependent on epoch)
    authority: AuthorityIndex,
}

impl Slot {
    fn new(round: Round, authority: AuthorityIndex) -> Self {
        Self { round, authority }
    }

    #[cfg(test)]
    fn new_for_test(round: Round, authority: u32) -> Self {
        Self {
            round,
            authority: AuthorityIndex::new_for_test(authority),
        }
    }
}

impl From<BlockHeaderRef> for Slot {
    fn from(value: BlockHeaderRef) -> Self {
        Slot::new(value.round, value.author)
    }
}

// TODO: re-evaluate formats for production debugging.
impl fmt::Display for Slot {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}{}", self.authority, self.round,)
    }
}

impl fmt::Debug for Slot {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self)
    }
}
/// VerifiedBlock allows full access to its content.
/// Note: clone() is relatively cheap with most underlying data refcounted.
#[derive(Clone)]
struct VerifiedBlock {
    /// arc reference to the full block data
    block: Arc<Block>,

    // Cached Block header digest and serialized SignedBlockHeader, to avoid re-computing these values.
    digest: BlockHeaderDigest,
    serialized: Bytes,
}

impl VerifiedBlock {
    /// Creates VerifiedBlock from a verified SignedBlock and its serialized bytes.
    fn new_verified(block: Block, digest: BlockHeaderDigest, serialized: Bytes) -> Self {
        VerifiedBlock {
            block: Arc::new(block),
            digest,
            serialized,
        }
    }

    // /// This method is public for testing in other crates.
    // fn new_for_test(block: Block) -> Self {
    //     // Use empty signature in test.
    //     let signed_block = SignedBlock {
    //         inner: block,
    //         signature: Default::default(),
    //     };
    //     let serialized: Bytes = bcs::to_bytes(&signed_block)
    //         .expect("Serialization should not fail")
    //         .into();
    //     let digest = Self::compute_digest(&serialized);
    //     VerifiedBlock {
    //         block: Arc::new(signed_block),
    //         digest,
    //         serialized,
    //     }
    // }

    /// Returns reference to the block.
    fn reference(&self) -> BlockHeaderRef {
        BlockHeaderRef {
            round: self.round(),
            author: self.author(),
            digest: self.digest(),
        }
    }

    /// Returns the digest for the block (skip recompute)
    const fn digest(&self) -> BlockHeaderDigest {
        self.digest
    }

    /// Returns the serialized block with signature.
    const fn serialized(&self) -> &Bytes {
        &self.serialized
    }

    // /// Computes digest from the serialized block with signature.
    //  fn compute_digest(block: &Block) -> BlockHeaderDigest {
    //     let mut hasher = DefaultHashFunction::new();
    //     let serialized = block.signed_header.serialize();
    //     hasher.update(serialized);
    //     BlockHeaderDigest(hasher.finalize().into())
    // }
}

/// Allow quick access on the underlying Block without having to always refer to the inner block ref.
impl Deref for VerifiedBlock {
    type Target = Block;

    fn deref(&self) -> &Self::Target {
        &self.block
    }
}

impl PartialEq for VerifiedBlock {
    fn eq(&self, other: &Self) -> bool {
        self.digest() == other.digest()
    }
}

impl fmt::Display for VerifiedBlock {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {
        write!(f, "{}", self.reference())
    }
}

// TODO: re-evaluate formats for production debugging.
impl fmt::Debug for VerifiedBlock {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {
        write!(
            f,
            "{:?}({}ms;{:?};{}t;{}c)",
            self.reference(),
            self.timestamp_ms(),
            self.block_header_refs(),
            self.transactions().len(),
            self.commit_votes().len(),
        )
    }
}

// /// Generates the genesis blocks for the current Committee.
// /// The blocks are returned in authority index order.
//  fn genesis_blocks(context: Arc<Context>) -> Vec<VerifiedBlock> {
//     context
//         .committee
//         .authorities()
//         .map(|(authority_index, _)| {
//             let block = Block::V1(BlockV1::genesis_block(
//                 context.committee.epoch(),
//                 authority_index,
//             ));
//             let serialized = block
//                 .serialize()
//                 .expect("Genesis block serialization failed.");
//             // Unnecessary to verify genesis blocks.
//             VerifiedBlock::new_verified(block, serialized)
//         })
//         .collect::<Vec<VerifiedBlock>>()
// }

// /// Creates fake blocks for testing.
// /// This struct is public for testing in other crates.
// #[derive(Clone)]
// struct TestBlock {
//     block: BlockV1,
// }

// impl TestBlock {
//     fn new(round: Round, author: u32) -> Self {
//         Self {
//             block: BlockV1 {
//                 round,
//                 author: AuthorityIndex::new_for_test(author),
//                 ..Default::default()
//             },
//         }
//     }

//     fn set_epoch(mut self, epoch: Epoch) -> Self {
//         self.block.epoch = epoch;
//         self
//     }

//     fn set_round(mut self, round: Round) -> Self {
//         self.block.round = round;
//         self
//     }

//     fn set_author(mut self, author: AuthorityIndex) -> Self {
//         self.block.author = author;
//         self
//     }

//     fn set_timestamp_ms(mut self, timestamp_ms: BlockTimestampMs) -> Self {
//         self.block.timestamp_ms = timestamp_ms;
//         self
//     }

//     fn set_ancestors(mut self, ancestors: Vec<BlockRef>) -> Self {
//         self.block.ancestors = ancestors;
//         self
//     }

//     fn set_transactions(mut self, transactions: Vec<Transaction>) -> Self {
//         self.block.transactions = transactions;
//         self
//     }

//     fn set_commit_votes(mut self, commit_votes: Vec<CommitVote>) -> Self {
//         self.block.signed_header = commit_votes;
//         self
//     }

//     fn build(self) -> Block {
//         Block::V1(self.block)
//     }
// }

/// A block can attach reports of misbehavior by other authorities.
#[derive(Clone, Serialize, Deserialize, Debug)]
struct MisbehaviorReport {
    /// the author being reported
    target: AuthorityIndex,
    /// An enum to switch on different proofs
    proof: MisbehaviorProof,
}

/// Proof of misbehavior are usually signed block(s) from the misbehaving authority.
#[derive(Clone, Serialize, Deserialize, Debug)]
enum MisbehaviorProof {
    /// Proof of an invalid block
    InvalidBlock(BlockHeaderRef),
}

/// Digest of a `MisbehaviorReport` which covers the `MisbehaviorReport` in Bytes format.
#[derive(Clone, Copy, Serialize, Deserialize, Default, PartialEq, Eq, PartialOrd, Ord)]
struct MisbehaviorReportDigest([u8; DIGEST_LENGTH]);

impl MisbehaviorReportDigest {
    /// Lexicographic min & max digest.
    const MIN: Self = Self([u8::MIN; DIGEST_LENGTH]);
    /// Lexicographic min & max digest.
    const MAX: Self = Self([u8::MAX; DIGEST_LENGTH]);
}

impl Hash for MisbehaviorReportDigest {
    fn hash<H: Hasher>(&self, state: &mut H) {
        state.write(&self.0[..8]);
    }
}

impl From<MisbehaviorReportDigest> for Digest<{ DIGEST_LENGTH }> {
    fn from(hd: MisbehaviorReportDigest) -> Self {
        Digest::new(hd.0)
    }
}

impl fmt::Display for MisbehaviorReportDigest {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {
        write!(
            f,
            "{}",
            base64::Engine::encode(&base64::engine::general_purpose::STANDARD, self.0)
                .get(0..4)
                .ok_or(fmt::Error)?
        )
    }
}

impl fmt::Debug for MisbehaviorReportDigest {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {
        write!(
            f,
            "{}",
            base64::Engine::encode(&base64::engine::general_purpose::STANDARD, self.0)
        )
    }
}

impl AsRef<[u8]> for MisbehaviorReportDigest {
    fn as_ref(&self) -> &[u8] {
        &self.0
    }
}

/// `MisbehaviorReportRef` uniquely identifies a `VerifiedMisbehaviorReport` via `digest`. It also contains the slot
/// info (round and author) so it can be used in logic such as aggregating stakes for a round.
#[derive(Clone, Copy, Serialize, Deserialize, Default, PartialEq, Eq, PartialOrd, Ord)]
struct MisbehaviorReportRef {
    /// digest is a hash of the misbehavior report to create a constantly sized report
    digest: MisbehaviorReportDigest,
}

impl MisbehaviorReportRef {
    /// lexigraphical min
    const MIN: Self = Self {
        digest: MisbehaviorReportDigest::MIN,
    };

    /// lexigraphical max
    const MAX: Self = Self {
        digest: MisbehaviorReportDigest::MAX,
    };

    /// creates a new misbehavior report ref
    const fn new(digest: MisbehaviorReportDigest) -> Self {
        Self { digest }
    }
}

// TODO: re-evaluate formats for production debugging.
impl fmt::Display for MisbehaviorReportRef {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {
        write!(f, "T{}", self.digest)
    }
}

impl fmt::Debug for MisbehaviorReportRef {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {
        write!(f, "T{}", self.digest)
    }
}

impl Hash for MisbehaviorReportRef {
    fn hash<H: Hasher>(&self, state: &mut H) {
        state.write(&self.digest.0[..8]);
    }
}
// TODO: add basic verification for BlockRef and BlockDigest.
// TODO: add tests for SignedBlock and VerifiedBlock conversion.

// #[cfg(test)]
// mod tests {
//     use std::sync::Arc;

//     use fastcrypto::error::FastCryptoError;

//     use crate::{
//         error::ShardError,
//         types::block::{SignedBlock, TestBlock},
//         types::context::Context,
//     };

//     #[tokio::test]
//     async fn test_sign_and_verify() {
//         let (context, key_pairs) = Context::new_for_test(4);
//         let context = Arc::new(context);

//         // Create a block that authority 2 has created
//         let block = TestBlock::new(10, 2).build();

//         // Create a signed block with authority's 2 private key
//         let author_two_key = &key_pairs[2].1;
//         let signed_block = SignedBlock::new(block, author_two_key).expect("Shouldn't fail signing");

//         // Now verify the block's signature
//         let result = signed_block.verify_signature(&context);
//         assert!(result.is_ok());

//         // Try to sign authority's 2 block with authority's 1 key
//         let block = TestBlock::new(10, 2).build();
//         let author_one_key = &key_pairs[1].1;
//         let signed_block = SignedBlock::new(block, author_one_key).expect("Shouldn't fail signing");

//         // Now verify the block, it should fail
//         let result = signed_block.verify_signature(&context);
//         match result.err().unwrap() {
//             ShardError::SignatureVerificationFailure(err) => {
//                 assert_eq!(err, FastCryptoError::InvalidSignature);
//             }
//             err => panic!("Unexpected error: {err:?}"),
//         }
//     }
// }
