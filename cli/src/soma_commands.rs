use crate::{
    client_commands::SomaClientCommands, keytool::KeyToolCommand,
    validator_commands::SomaValidatorCommand,
};
use anyhow::{anyhow, bail, ensure, Context as _};
use clap::{Command, CommandFactory as _, Parser};
use colored::Colorize;
use fastcrypto::traits::KeyPair as _;
use rand::rngs::OsRng;
use sdk::{
    client_config::{SomaClientConfig, SomaEnv},
    wallet_context::{create_wallet_context, WalletContext, DEFAULT_WALLET_TIMEOUT_SEC},
    SomaClient,
};
use soma_keys::{
    key_derive::generate_new_key,
    keystore::{AccountKeystore as _, FileBasedKeystore, Keystore},
};
use std::{
    fs,
    io::{self, stdout, Write as _},
    net::{AddrParseError, IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr},
    path::{Path, PathBuf},
};
use std::{num::NonZeroUsize, time::Duration};
use test_cluster::swarm::Swarm;
use tokio::time::interval;
use tracing::info;
use types::{
    base::SomaAddress,
    config::{
        genesis_blob_exists,
        genesis_config::{GenesisConfig, ValidatorGenesisConfigBuilder},
        network_config::{CommitteeConfig, NetworkConfig},
        node_config::{default_json_rpc_address, Genesis},
        p2p_config::SeedPeer,
        soma_config_dir, PersistedConfig, FULL_NODE_DB_PATH, SOMA_CLIENT_CONFIG,
        SOMA_FULLNODE_CONFIG, SOMA_KEYSTORE_FILENAME, SOMA_NETWORK_CONFIG,
    },
    crypto::SignatureScheme,
    peer_id::PeerId,
};
use types::{
    config::{network_config::ConfigBuilder, Config, SOMA_GENESIS_FILENAME},
    crypto::SomaKeyPair,
};
use url::Url;

const DEFAULT_EPOCH_DURATION_MS: u64 = 60_000;

// TODO: RpcArgs for starting indexer and GraphQL server

#[derive(Parser)]
#[clap(rename_all = "kebab-case")]
pub struct SomaEnvConfig {
    /// Sets the file storing the state of our user accounts (an empty one will be created if missing)
    #[clap(long = "client.config")]
    config: Option<PathBuf>,
    /// The Soma environment to use. This must be present in the current config file.
    #[clap(long = "client.env")]
    env: Option<String>,
    /// Create a new soma config without prompting if none exists
    #[clap(short = 'y', long = "yes")]
    accept_defaults: bool,
}

impl SomaEnvConfig {
    pub fn new(config: Option<PathBuf>, env: Option<String>) -> Self {
        Self {
            config,
            env,
            accept_defaults: false,
        }
    }
}

#[allow(clippy::large_enum_variant)]
#[derive(Parser)]
#[clap(rename_all = "kebab-case")]
pub enum SomaCommand {
    /// Start a local network in two modes: saving state between re-runs and not saving state
    /// between re-runs. Please use (--help) to see the full description.
    ///
    /// By default, soma start will start a local network from the genesis blob that exists in
    /// the Soma config default dir or in the config_dir that was passed. If the default directory
    /// does not exist and the config_dir is not passed, it will generate a new default directory,
    /// generate the genesis blob, and start the network.
    ///
    /// Note that if you want to start an indexer, Postgres DB is required.
    ///
    /// ProtocolConfig parameters can be overridden individually by setting env variables as
    /// follows:
    /// - SOMA_PROTOCOL_CONFIG_OVERRIDE_ENABLE=1
    /// - Then, to configure an override, use the prefix `SOMA_PROTOCOL_CONFIG_OVERRIDE_`
    ///   along with the parameter name. For example, to increase the interval between
    ///   checkpoint creation to >1/s, you might set:
    ///   SOMA_PROTOCOL_CONFIG_OVERRIDE_min_checkpoint_interval_ms=1000
    ///
    /// Note that ProtocolConfig parameters must match between all nodes, or the network
    /// may break. Changing these values outside of local networks is very dangerous.
    #[clap(name = "start", verbatim_doc_comment)]
    Start {
        /// Config directory that will be used to store network config, node db, keystore.
        /// soma genesis -f --with-faucet generates a genesis config that can be used to start this
        /// process. Use with caution as the `-f` flag will overwrite the existing config directory.
        /// We can use any config dir that is generated by the `soma genesis`.
        #[clap(long = "network.config")]
        config_dir: Option<std::path::PathBuf>,

        /// A new genesis is created each time this flag is set, and state is not persisted between
        /// runs. Only use this flag when you want to start the network from scratch every time you
        /// run this command.
        ///
        /// To run with persisted state, do not pass this flag and use the `soma genesis` command
        /// to generate a genesis that can be used to start the network with.
        #[clap(long)]
        force_regenesis: bool,

        // TODO: faucet command
        /// Start a faucet with default host and port: 0.0.0.0:9123. This flag accepts also a
        /// port, a host, or both (e.g., 0.0.0.0:9123).
        /// When providing a specific value, please use the = sign between the flag and value:
        /// `--with-faucet=6124` or `--with-faucet=0.0.0.0`, or `--with-faucet=0.0.0.0:9123`
        // #[clap(
        //     long,
        //     default_missing_value = "0.0.0.0:9123",
        //     num_args = 0..=1,
        //     require_equals = true,
        //     value_name = "FAUCET_HOST_PORT",
        // )]
        // with_faucet: Option<String>,

        // #[clap(flatten)]
        // rpc_args: RpcArgs,

        /// Port to start the Fullnode RPC server on. Default port is 9000.
        #[clap(long, default_value = "9000")]
        fullnode_rpc_port: u16,

        /// Set the epoch duration. Can only be used when `--force-regenesis` flag is passed or if
        /// there's no genesis config and one will be auto-generated. When this flag is not set but
        /// `--force-regenesis` is set, the epoch duration will be set to 60 seconds.
        #[clap(long)]
        epoch_duration_ms: Option<u64>,

        /// Make the fullnode dump executed checkpoints as files to this directory. This is
        /// incompatible with --no-full-node.
        ///
        /// If --with-indexer is set, this defaults to a temporary directory.
        #[clap(long, value_name = "DATA_INGESTION_DIR")]
        data_ingestion_dir: Option<PathBuf>,

        /// Start the network without a fullnode
        #[clap(long = "no-full-node")]
        no_full_node: bool,
        /// Set the number of validators in the network. If a genesis was already generated with a
        /// specific number of validators, this will not override it; the user should recreate the
        /// genesis with the desired number of validators.
        #[clap(long)]
        committee_size: Option<usize>,
    },
    #[clap(name = "network")]
    Network {
        #[clap(long = "network.config")]
        config: Option<PathBuf>,
        #[clap(short, long, help = "Dump the public keys of all authorities")]
        dump_addresses: bool,
    },
    /// Bootstrap and initialize a new soma network
    #[clap(name = "genesis")]
    Genesis {
        #[clap(long, help = "Start genesis with a given config file")]
        from_config: Option<PathBuf>,
        #[clap(
            long,
            help = "Build a genesis config, write it to the specified path, and exit"
        )]
        write_config: Option<PathBuf>,
        #[clap(long)]
        working_dir: Option<PathBuf>,
        #[clap(short, long, help = "Forces overwriting existing configuration")]
        force: bool,
        #[clap(long = "epoch-duration-ms")]
        epoch_duration_ms: Option<u64>,
        #[clap(
            long,
            help = "Creates an extra faucet configuration for soma persisted runs."
        )]
        with_faucet: bool,
        /// Set number of validators in the network.
        #[clap(long)]
        committee_size: Option<usize>,
    },
    GenesisCeremony(Ceremony),
    /// Soma keystore tool.
    #[clap(name = "keytool")]
    KeyTool {
        #[clap(long)]
        keystore_path: Option<PathBuf>,
        ///Return command outputs in json format
        #[clap(long, global = true)]
        json: bool,
        /// Subcommands.
        #[clap(subcommand)]
        cmd: KeyToolCommand,
    },
    /// Client for interacting with the Soma network.
    #[clap(name = "client")]
    Client {
        #[clap(flatten)]
        config: SomaEnvConfig,
        #[clap(subcommand)]
        cmd: Option<SomaClientCommands>,
        /// Return command outputs in json format.
        #[clap(long, global = true)]
        json: bool,
    },
    /// A tool for validators and validator candidates.
    #[clap(name = "validator")]
    Validator {
        /// Sets the file storing the state of our user accounts (an empty one will be created if missing)
        #[clap(flatten)]
        config: SomaEnvConfig,
        #[clap(subcommand)]
        cmd: Option<SomaValidatorCommand>,
        /// Return command outputs in json format.
        #[clap(long, global = true)]
        json: bool,
    },
}

impl SomaCommand {
    pub async fn execute(self) -> Result<(), anyhow::Error> {
        match self {
            SomaCommand::Network {
                config,
                dump_addresses,
            } => {
                let config_path = config.unwrap_or(soma_config_dir()?.join(SOMA_NETWORK_CONFIG));
                let config: NetworkConfig = PersistedConfig::read(&config_path).map_err(|err| {
                    err.context(format!(
                        "Cannot open Soma network config file at {:?}",
                        config_path
                    ))
                })?;

                if dump_addresses {
                    for validator in config.validator_configs() {
                        println!(
                            "{} - {}",
                            validator.network_address(),
                            validator.protocol_key_pair().public(),
                        );
                    }
                }
                Ok(())
            }
            SomaCommand::Start {
                config_dir,
                force_regenesis,
                // with_faucet,
                // rpc_args,
                fullnode_rpc_port,
                data_ingestion_dir,
                no_full_node,
                epoch_duration_ms,
                committee_size,
            } => {
                start(
                    config_dir.clone(),
                    // with_faucet,
                    // rpc_args,
                    force_regenesis,
                    epoch_duration_ms,
                    fullnode_rpc_port,
                    data_ingestion_dir,
                    no_full_node,
                    committee_size,
                )
                .await?;

                Ok(())
            }
            SomaCommand::Genesis {
                working_dir,
                force,
                from_config,
                write_config,
                epoch_duration_ms,
                with_faucet,
                committee_size,
            } => {
                genesis(
                    from_config,
                    write_config,
                    working_dir,
                    force,
                    epoch_duration_ms,
                    with_faucet,
                    committee_size,
                )
                .await
            }
            SomaCommand::GenesisCeremony(cmd) => run(cmd),
            SomaCommand::KeyTool {
                keystore_path,
                json,
                cmd,
            } => {
                let keystore_path =
                    keystore_path.unwrap_or(soma_config_dir()?.join(SOMA_KEYSTORE_FILENAME));
                let mut keystore =
                    Keystore::from(FileBasedKeystore::load_or_create(&keystore_path)?);
                cmd.execute(&mut keystore).await?.print(!json);
                Ok(())
            }
            SomaCommand::Client { config, cmd, json } => {
                if let Some(cmd) = cmd {
                    let mut context = get_wallet_context(&config).await?;

                    if let Ok(client) = context.get_client().await {
                        if let Err(e) = client.check_api_version().await {
                            eprintln!("{}", format!("[warning] {e}").yellow().bold());
                        }
                    }
                    cmd.execute(&mut context).await?.print(!json);
                } else {
                    // Print help
                    let mut app: Command = SomaCommand::command();
                    app.build();
                    app.find_subcommand_mut("client").unwrap().print_help()?;
                }
                Ok(())
            }
            SomaCommand::Validator { config, cmd, json } => {
                let mut context = get_wallet_context(&config).await?;
                if let Some(cmd) = cmd {
                    if let Ok(client) = context.get_client().await {
                        if let Err(e) = client.check_api_version().await {
                            eprintln!("{}", format!("[warning] {e}").yellow().bold());
                        }
                    }
                    cmd.execute(&mut context).await?.print(!json);
                } else {
                    // Print help
                    let mut app: Command = SomaCommand::command();
                    app.build();
                    app.find_subcommand_mut("validator").unwrap().print_help()?;
                }
                Ok(())
            }
        }
    }
}

/// Starts a local network with the given configuration.
async fn start(
    config: Option<PathBuf>,
    // with_faucet: Option<String>,
    // rpc_args: RpcArgs,
    force_regenesis: bool,
    epoch_duration_ms: Option<u64>,
    fullnode_rpc_port: u16,
    mut data_ingestion_dir: Option<PathBuf>,
    no_full_node: bool,
    committee_size: Option<usize>,
) -> Result<(), anyhow::Error> {
    if force_regenesis {
        ensure!(
            config.is_none(),
            "Cannot pass `--force-regenesis` and `--network.config` at the same time."
        );
    }

    if epoch_duration_ms.is_some() && genesis_blob_exists(config.clone()) && !force_regenesis {
        bail!(
            "Epoch duration can only be set when passing the `--force-regenesis` flag, or when \
            there is no genesis configuration in the default Soma configuration folder or the given \
            network.config argument.",
        );
    }

    let mut swarm_builder = Swarm::builder();

    // If this is set, then no data will be persisted between runs, and a new genesis will be
    // generated each run.
    let config_dir = if force_regenesis {
        let committee_size = match committee_size {
            Some(x) => NonZeroUsize::new(x),
            None => NonZeroUsize::new(1),
        }
        .ok_or_else(|| anyhow!("Committee size must be at least 1."))?;
        swarm_builder = swarm_builder.committee_size(committee_size);
        let genesis_config = GenesisConfig::custom_genesis(1, 100);
        swarm_builder = swarm_builder.with_genesis_config(genesis_config);
        let epoch_duration_ms = epoch_duration_ms.unwrap_or(DEFAULT_EPOCH_DURATION_MS);
        swarm_builder = swarm_builder.with_epoch_duration_ms(epoch_duration_ms);
        tempfile::tempdir()?.keep()
    } else {
        // If the config path looks like a YAML file, it is treated as if it is the network.yaml
        // overriding the network.yaml found in the soma config directry. Otherwise it is treated as
        // the soma config directory for backwards compatibility with `soma-test-validator`.
        let (network_config_path, soma_config_path) = match config {
            Some(config)
                if config.is_file()
                    && config
                        .extension()
                        .is_some_and(|e| e == "yml" || e == "yaml") =>
            {
                if committee_size.is_some() {
                    eprintln!(
                        "{}",
                        "[warning] The committee-size arg wil be ignored as a network \
                            configuration already exists. To change the committee-size, you'll \
                            have to adjust the network configuration file or regenerate a genesis \
                            with the desired committee size. See `soma genesis --help` for more \
                            information."
                            .yellow()
                            .bold()
                    );
                }
                (config, soma_config_dir()?)
            }

            Some(config) => {
                if committee_size.is_some() {
                    eprintln!(
                        "{}",
                        "[warning] The committee-size arg wil be ignored as a network \
                            configuration already exists. To change the committee-size, you'll \
                            have to adjust the network configuration file or regenerate a genesis \
                            with the desired committee size. See `soma genesis --help` for more \
                            information."
                            .yellow()
                            .bold()
                    );
                }
                (config.join(SOMA_NETWORK_CONFIG), config)
            }

            None => {
                let soma_config = soma_config_dir()?;
                let network_config = soma_config.join(SOMA_NETWORK_CONFIG);

                if !network_config.exists() {
                    genesis(
                        None,
                        None,
                        None,
                        false,
                        epoch_duration_ms,
                        false,
                        committee_size,
                    )
                    .await
                    .map_err(|_| {
                        anyhow!(
                            "Cannot run genesis with non-empty Soma config directory: {}.\n\n\
                                If you are trying to run a local network without persisting the \
                                data (so a new genesis that is randomly generated and will not be \
                                saved once the network is shut down), use --force-regenesis flag.\n\
                                If you are trying to persist the network data and start from a new \
                                genesis, use soma genesis --help to see how to generate a new \
                                genesis.",
                            soma_config.display(),
                        )
                    })?;
                } else if committee_size.is_some() {
                    eprintln!(
                        "{}",
                        "[warning] The committee-size arg wil be ignored as a network \
                            configuration already exists. To change the committee-size, you'll \
                            have to adjust the network configuration file or regenerate a genesis \
                            with the desired committee size. See `soma genesis --help` for more \
                            information."
                            .yellow()
                            .bold()
                    );
                }

                (network_config, soma_config)
            }
        };

        // Load the config of the Soma authority.
        let network_config: NetworkConfig =
            PersistedConfig::read(&network_config_path).map_err(|err| {
                err.context(format!(
                    "Cannot open Soma network config file at {:?}",
                    network_config_path
                ))
            })?;

        swarm_builder = swarm_builder
            .dir(soma_config_path.clone())
            .with_network_config(network_config);

        soma_config_path
    };

    if let Some(ref dir) = data_ingestion_dir {
        swarm_builder = swarm_builder.with_data_ingestion_dir(dir.clone());
    }

    let mut fullnode_rpc_address = types::config::node_config::default_json_rpc_address();
    fullnode_rpc_address.set_port(fullnode_rpc_port);

    if no_full_node {
        swarm_builder = swarm_builder.with_fullnode_count(0);
    } else {
        let rpc_config = types::config::rpc_config::RpcConfig {
            enable_indexing: Some(true),
            ..Default::default()
        };

        swarm_builder = swarm_builder
            .with_fullnode_count(1)
            .with_fullnode_rpc_addr(fullnode_rpc_address)
            .with_fullnode_rpc_config(rpc_config);
    }

    let mut swarm = swarm_builder.build();
    swarm.launch().await?;
    // Let nodes connect to one another
    tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;
    info!("Cluster started");

    let fullnode_rpc_url = socket_addr_to_url(fullnode_rpc_address)?
        .to_string()
        .trim_end_matches("/")
        .to_string();
    info!("Fullnode RPC URL: {fullnode_rpc_url}");

    // Update the wallet_context with the configured fullnode rpc url so client operations will
    // succeed if a non-default port was provided.

    if config_dir.join(SOMA_CLIENT_CONFIG).exists() {
        let _ = update_wallet_config_rpc(config_dir.clone(), fullnode_rpc_url.clone())?;
    }

    if force_regenesis && soma_config_dir()?.join(SOMA_CLIENT_CONFIG).exists() {
        let _ = update_wallet_config_rpc(soma_config_dir()?, fullnode_rpc_url.clone())?;
    }

    // TODO: with_faucet
    // if let Some(input) = with_faucet {
    //     let faucet_address = parse_host_port(input, DEFAULT_FAUCET_PORT)
    //         .map_err(|_| anyhow!("Invalid faucet host and port"))?;

    //     info!("Starting the faucet service at {faucet_address}");

    //     let host_ip = match faucet_address {
    //         SocketAddr::V4(addr) => *addr.ip(),
    //         _ => bail!("Faucet configuration requires an IPv4 address"),
    //     };

    //     let config = FaucetConfig {
    //         host_ip,
    //         port: faucet_address.port(),
    //         amount: DEFAULT_FAUCET_MIST_AMOUNT,
    //         ..Default::default()
    //     };

    //     if force_regenesis {
    //         let kp = swarm.config_mut().account_keys.swap_remove(0);
    //         let keystore_path = config_dir.join(SOMA_KEYSTORE_FILENAME);
    //         let mut keystore =
    //             Keystore::from(FileBasedKeystore::load_or_create(&keystore_path).unwrap());
    //         let address: SomaAddress = kp.public().into();
    //         keystore
    //             .import(None, SomaKeyPair::Ed25519(kp))
    //             .await
    //             .unwrap();

    //         SomaClientConfig {
    //             keystore,
    //             external_keys: None,
    //             envs: vec![SomaEnv {
    //                 alias: "localnet".to_string(),
    //                 rpc: fullnode_rpc_url.clone(),
    //                 ws: None,
    //                 basic_auth: None,
    //                 chain_id: None,
    //             }],
    //             active_address: Some(address),
    //             active_env: Some("localnet".to_string()),
    //         }
    //         .persisted(config_dir.join(SOMA_CLIENT_CONFIG).as_path())
    //         .save()
    //         .unwrap();
    //     }

    //     let local_faucet = LocalFaucet::new(
    //         create_wallet_context(config.wallet_client_timeout_secs, config_dir.clone())?,
    //         config.clone(),
    //     )
    //     .await?;

    //     let app_state = Arc::new(AppState {
    //         faucet: local_faucet,
    //         config,
    //     });

    //     start_faucet(app_state).await?;
    // }

    // Run health check loop until Ctrl+C or failure
    let mut interval = interval(Duration::from_secs(3));

    loop {
        tokio::select! {
            _ = tokio::signal::ctrl_c() => {
                info!("Received Ctrl+C, shutting down...");
                break;
            }
            _ = interval.tick() => {}
        }
    }
    Ok(())
}

async fn genesis(
    from_config: Option<PathBuf>,
    write_config: Option<PathBuf>,
    working_dir: Option<PathBuf>,
    force: bool,
    epoch_duration_ms: Option<u64>,
    with_faucet: bool,
    committee_size: Option<usize>,
) -> Result<(), anyhow::Error> {
    let soma_config_dir = &match working_dir {
        Some(v) => v,
        None => {
            let config_path = soma_config_dir()?;
            fs::create_dir_all(&config_path)?;
            config_path
        }
    };

    let dir = soma_config_dir.read_dir().map_err(|err| {
        anyhow!(err).context(format!("Cannot open Soma config dir {:?}", soma_config_dir))
    })?;
    let files = dir.collect::<Result<Vec<_>, _>>()?;

    let client_path = soma_config_dir.join(SOMA_CLIENT_CONFIG);
    let keystore_path = soma_config_dir.join(SOMA_KEYSTORE_FILENAME);

    if write_config.is_none() && !files.is_empty() {
        if force {
            let is_compatible = FileBasedKeystore::load_or_create(&keystore_path).is_ok()
                && PersistedConfig::<SomaClientConfig>::read(&client_path).is_ok();
            if is_compatible {
                for file in files {
                    let path = file.path();
                    if path != client_path && path != keystore_path {
                        if path.is_file() {
                            fs::remove_file(path)
                        } else {
                            fs::remove_dir_all(path)
                        }
                        .map_err(|err| {
                            anyhow!(err).context(format!("Cannot remove file {:?}", file.path()))
                        })?;
                    }
                }
            } else {
                fs::remove_dir_all(soma_config_dir).map_err(|err| {
                    anyhow!(err).context(format!(
                        "Cannot remove Soma config dir {:?}",
                        soma_config_dir
                    ))
                })?;
                fs::create_dir(soma_config_dir).map_err(|err| {
                    anyhow!(err).context(format!(
                        "Cannot create Soma config dir {:?}",
                        soma_config_dir
                    ))
                })?;
            }
        } else if files.len() != 2 || !client_path.exists() || !keystore_path.exists() {
            bail!(
                "Cannot run genesis with non-empty Soma config directory {}, please use the --force/-f option to remove the existing configuration",
                soma_config_dir.to_str().unwrap()
            );
        }
    }

    let network_path = soma_config_dir.join(SOMA_NETWORK_CONFIG);
    let genesis_path = soma_config_dir.join(SOMA_GENESIS_FILENAME);

    let mut genesis_conf = match from_config {
        Some(path) => PersistedConfig::read(&path)?,
        None => {
            if keystore_path.exists() {
                let existing_keys = FileBasedKeystore::load_or_create(&keystore_path)?.addresses();
                GenesisConfig::for_local_testing_with_addresses(existing_keys)
            } else {
                GenesisConfig::for_local_testing()
            }
        }
    };

    if let Some(path) = write_config {
        let persisted = genesis_conf.persisted(&path);
        persisted.save()?;
        return Ok(());
    }

    let validator_info = genesis_conf.validator_config_info.take();
    let networking_validator_info = genesis_conf.networking_validator_config_info.take();

    let mut builder = ConfigBuilder::new(soma_config_dir);
    if let Some(epoch_duration_ms) = epoch_duration_ms {
        genesis_conf.parameters.epoch_duration_ms = epoch_duration_ms;
    }

    let committee_size = match committee_size {
        Some(x) => NonZeroUsize::new(x),
        None => NonZeroUsize::new(1),
    }
    .ok_or_else(|| anyhow!("Committee size must be at least 1."))?;

    let mut network_config = match (validator_info, networking_validator_info) {
        // Both consensus and networking validators specified in config
        (Some(mut validators), Some(networking_validators)) => {
            let networking_validators: Vec<_> = networking_validators
                .into_iter()
                .map(|mut v| {
                    v.is_networking_only = true;
                    v
                })
                .collect();
            validators.extend(networking_validators);

            builder
                .with_genesis_config(genesis_conf)
                .with_validators(validators)
                .build()
        }
        // Only consensus validators specified, generate one networking validator
        (Some(mut validators), None) => {
            let networking_validator = ValidatorGenesisConfigBuilder::new()
                .as_networking_only()
                .build(&mut OsRng);

            validators.push(networking_validator);

            builder
                .with_genesis_config(genesis_conf)
                .with_validators(validators)
                .build()
        }
        // Only networking validators specified in config
        (None, Some(networking_validators)) => {
            let networking_validators: Vec<_> = networking_validators
                .into_iter()
                .map(|mut v| {
                    v.is_networking_only = true;
                    v
                })
                .collect();

            builder
                .committee(CommitteeConfig::Mixed {
                    consensus_count: committee_size,
                    networking_count: NonZeroUsize::new(networking_validators.len())
                        .unwrap_or(NonZeroUsize::new(1).unwrap()),
                })
                .with_genesis_config(genesis_conf)
                .build()
        }
        // Neither specified, generate both using Mixed config
        (None, None) => builder
            .committee(CommitteeConfig::Mixed {
                consensus_count: committee_size,
                networking_count: NonZeroUsize::new(1).unwrap(),
            })
            .with_genesis_config(genesis_conf)
            .build(),
    };

    let mut keystore = FileBasedKeystore::load_or_create(&keystore_path)?;
    for key in &network_config.account_keys {
        keystore.import(None, key.copy()).await?;
    }
    let active_address = keystore.addresses().pop();

    network_config.genesis.save(&genesis_path)?;
    for validator in &mut network_config.validator_configs {
        validator.genesis = Genesis::new_from_file(&genesis_path);
    }

    info!("Network genesis completed.");
    network_config.save(&network_path)?;
    info!("Network config file is stored in {:?}.", network_path);
    info!("Client keystore is stored in {:?}.", keystore_path);

    // Save individual validator configs
    for (i, validator) in network_config.validator_configs().iter().enumerate() {
        let config_type = if validator.consensus_config.is_some() {
            "validator"
        } else {
            "networking_validator"
        };
        let path = soma_config_dir.join(format!("{}_{}.yaml", config_type, i));
        validator.save(&path)?;
        info!("{} config saved to {:?}", config_type, path);
    }

    // Save the first networking validator as SOMA_FULLNODE_CONFIG for backwards compatibility
    if let Some(networking_validator) = network_config
        .validator_configs()
        .iter()
        .find(|c| c.consensus_config.is_none())
    {
        networking_validator.save(soma_config_dir.join(SOMA_FULLNODE_CONFIG))?;
        info!(
            "Networking validator config saved as fullnode config in {:?}",
            soma_config_dir.join(SOMA_FULLNODE_CONFIG)
        );
    }

    // Build client config
    let mut client_config = if client_path.exists() {
        PersistedConfig::read(&client_path)?
    } else {
        SomaClientConfig::new(keystore.into())
    };

    if client_config.active_address.is_none() {
        client_config.active_address = active_address;
    }

    // Get RPC URL from the first networking validator (or first validator if none)
    let rpc_address = network_config
        .validator_configs()
        .iter()
        .find(|c| c.consensus_config.is_none())
        .or_else(|| network_config.validator_configs().first())
        .map(|c| c.rpc_address)
        .unwrap_or_else(default_json_rpc_address);

    let rpc = format!("http://{}:{}", rpc_address.ip(), rpc_address.port());

    client_config.add_env(SomaEnv {
        alias: "localnet".to_string(),
        rpc,
        basic_auth: None,
        chain_id: None,
    });
    client_config.add_env(SomaEnv::devnet());

    if client_config.active_env.is_none() {
        client_config.active_env = client_config.envs.first().map(|env| env.alias.clone());
    }

    client_config.save(&client_path)?;
    info!("Client config file is stored in {:?}.", client_path);

    Ok(())
}

/// If `wallet_conf_file` (or the default config file if None) doesn't exist, prompt the user and
/// then create it (along with a new keystore file in the same directory). The prompt is skipped if
/// `accept_defaults` is true.
async fn prompt_if_no_config(
    wallet_conf_file: &Path,
    accept_defaults: bool,
) -> Result<(), anyhow::Error> {
    if wallet_conf_file.exists() {
        return Ok(());
    }

    // prompt user
    if !accept_defaults {
        println!(
            "No soma config found in `{}`, create one [Y/n]?",
            wallet_conf_file.to_string_lossy()
        );
        let response = read_line()?.trim().to_lowercase();
        if !response.is_empty() && response != "y" {
            bail!("No config found, aborting");
        }
    }

    // make keystore
    let config_dir = wallet_conf_file
        .parent()
        .ok_or_else(|| anyhow!("Error: {wallet_conf_file:?} is an invalid file path"))?;

    let (keystore, address) =
        create_default_keystore(&config_dir.join(SOMA_KEYSTORE_FILENAME)).await?;

    // make config file
    let default_env = SomaEnv::testnet();
    let default_env_name = default_env.alias.clone();
    SomaClientConfig {
        keystore,
        envs: vec![
            default_env,
            SomaEnv::mainnet(),
            SomaEnv::devnet(),
            SomaEnv::localnet(),
        ],
        external_keys: None,
        active_address: Some(address),
        active_env: Some(default_env_name.clone()),
    }
    .persisted(wallet_conf_file)
    .save()?;
    println!("Created {wallet_conf_file:?}");
    println!("Set active environment to {default_env_name}");

    Ok(())
}

/// Create a keystore with a single key at `keystore_file`; returns the created keystore and
/// address
async fn create_default_keystore(keystore_file: &Path) -> anyhow::Result<(Keystore, SomaAddress)> {
    let mut keystore = Keystore::from(FileBasedKeystore::load_or_create(
        &keystore_file.to_path_buf(),
    )?);
    let key_scheme = SignatureScheme::ED25519;
    let (new_address, key_pair, scheme, phrase) = generate_new_key(key_scheme, None, None)?;
    keystore.import(None, key_pair).await?;
    let alias = keystore.get_alias(&new_address)?;

    println!(
        "Generated new keypair and alias for address with scheme {:?} [{alias}: {new_address}]",
        scheme.to_string()
    );
    println!("  secret recovery phrase : [{phrase}]");

    Ok((keystore, new_address))
}

/// Read a single line from stdin and return it
fn read_line() -> Result<String, anyhow::Error> {
    let mut s = String::new();
    let _ = stdout().flush();
    io::stdin().read_line(&mut s)?;
    Ok(s.trim_end().to_string())
}

/// Get the currently configured wallet context, creating one if it doesn't exist
async fn get_wallet_context(client_config: &SomaEnvConfig) -> Result<WalletContext, anyhow::Error> {
    let wallet_conf_file = client_config
        .config
        .clone()
        .unwrap_or(soma_config_dir()?.join(SOMA_CLIENT_CONFIG));

    prompt_if_no_config(&wallet_conf_file, client_config.accept_defaults).await?;
    let mut context = WalletContext::new(&wallet_conf_file)?;

    if let Some(env_override) = &client_config.env {
        context = context.with_env_override(env_override.clone());
    }

    Ok(context)
}

/// Get the currently configured client.
async fn get_client(
    client_config: SomaEnvConfig,
    command_err_string: &str,
) -> Result<SomaClient, anyhow::Error> {
    let context = get_wallet_context(&client_config).await?;
    let Ok(client) = context.get_client().await else {
        bail!(
            "`{command_err_string}` requires a connection to the network. \
             Current active network is {} but failed to connect to it.",
            context.config.active_env.as_ref().unwrap()
        );
    };

    Ok(client)
}

/// Get the currently configured client, and the chain ID for that client.
async fn get_chain_id_and_client(
    client_config: SomaEnvConfig,
    command_err_string: &str,
) -> anyhow::Result<(Option<String>, Option<SomaClient>)> {
    let client = get_client(client_config, command_err_string).await?;

    if let Err(e) = client.check_api_version().await {
        eprintln!("{}", format!("[warning] {e}").yellow().bold());
    }

    Ok((client.get_chain_identifier().await.ok(), Some(client)))
}

/// Parse the input string into a SocketAddr, with a default port if none is provided.
pub fn parse_host_port(
    input: String,
    default_port_if_missing: u16,
) -> Result<SocketAddr, AddrParseError> {
    let default_host = "0.0.0.0";
    let mut input = input;
    if input.contains("localhost") {
        input = input.replace("localhost", "127.0.0.1");
    }
    if input.contains(':') {
        input.parse::<SocketAddr>()
    } else if input.contains('.') {
        format!("{input}:{default_port_if_missing}").parse::<SocketAddr>()
    } else if input.is_empty() {
        format!("{default_host}:{default_port_if_missing}").parse::<SocketAddr>()
    } else if !input.is_empty() {
        format!("{default_host}:{input}").parse::<SocketAddr>()
    } else {
        format!("{default_host}:{default_port_if_missing}").parse::<SocketAddr>()
    }
}

/// Converts a socket address to a Url by setting the scheme to HTTP.
fn socket_addr_to_url(addr: SocketAddr) -> Result<Url, anyhow::Error> {
    let ip = normalize_bind_addr(addr);
    Url::parse(&format!("http://{ip}:{}", addr.port()))
        .with_context(|| format!("Failed to parse {addr} into a Url"))
}

/// Resolves an unspecified ip address to a localhost IP address. Particularly on Windows, clients
/// cannot connect to 0.0.0.0 addresses.
fn normalize_bind_addr(addr: SocketAddr) -> IpAddr {
    match addr.ip() {
        IpAddr::V4(v4) if v4.is_unspecified() => IpAddr::V4(Ipv4Addr::LOCALHOST),
        IpAddr::V6(v6) if v6.is_unspecified() => IpAddr::V6(Ipv6Addr::LOCALHOST),
        ip => ip,
    }
}

fn update_wallet_config_rpc(
    config_dir: PathBuf,
    fullnode_rpc_url: String,
) -> anyhow::Result<WalletContext, anyhow::Error> {
    let mut wallet_context = create_wallet_context(DEFAULT_WALLET_TIMEOUT_SEC, config_dir.clone())?;
    if let Some(env) = wallet_context
        .config
        .envs
        .iter_mut()
        .find(|env| env.alias == "localnet")
    {
        env.rpc = fullnode_rpc_url;
    }
    wallet_context.config.save()?;

    Ok(wallet_context)
}
