use anyhow::{Result, anyhow, bail};
use clap::*;
use colored::Colorize;
use fastcrypto::encoding::{Encoding, Hex};
use serde::Serialize;
use std::fmt::{self, Display, Formatter};
use std::path::PathBuf;
use tabled::{
    builder::Builder as TableBuilder,
    settings::{Panel as TablePanel, Style as TableStyle, style::HorizontalLine},
};
use tokio::io::AsyncWriteExt;

use sdk::proxy_client::ProxyClient;
use sdk::wallet_context::WalletContext;
use types::{
    base::SomaAddress,
    checksum::Checksum,
    crypto::DecryptionKey,
    digests::{ModelWeightsCommitment, ModelWeightsUrlCommitment},
    metadata::{Manifest, ManifestV1, Metadata, MetadataV1},
    model::{ArchitectureVersion, Model, ModelId, ModelWeightsManifest},
    object::ObjectID,
    system_state::SystemState,
    tensor::SomaTensor,
    transaction::{
        CommitModelArgs, CommitModelUpdateArgs, RevealModelArgs, RevealModelUpdateArgs,
        TransactionKind,
    },
};

use crate::client_commands::TxProcessingArgs;
use crate::response::TransactionResponse;

#[derive(Parser)]
#[clap(rename_all = "kebab-case")]
pub enum ModelCommand {
    /// Commit a new model (phase 1 of commit-reveal)
    ///
    /// Registers a new model by committing its weight hashes. The model enters
    /// "pending" state and must be revealed in the next epoch or the stake is slashed.
    #[clap(name = "commit")]
    Commit {
        /// Pre-assigned model ID (ObjectID)
        #[clap(long)]
        model_id: ObjectID,
        /// Hex-encoded commitment to the encrypted weights URL (32 bytes)
        #[clap(long)]
        weights_url_commitment: String,
        /// Hex-encoded commitment to the decrypted model weights (32 bytes)
        #[clap(long)]
        weights_commitment: String,
        /// Model architecture version
        #[clap(long)]
        architecture_version: ArchitectureVersion,
        /// Amount of SOMA to stake (in shannons)
        #[clap(long)]
        stake_amount: u64,
        /// Commission rate in basis points (100 = 1%, max 10000 = 100%)
        #[clap(long, default_value_t = 0)]
        commission_rate: u64,
        /// Staking pool ID (ObjectID, generated by caller)
        #[clap(long)]
        staking_pool_id: ObjectID,
        #[clap(flatten)]
        tx_args: TxProcessingArgs,
    },

    /// Reveal model weights (phase 2 of commit-reveal)
    ///
    /// Must be called in the epoch following the commit. Provides the actual
    /// weights URL, checksum, and decryption key. The model becomes active.
    #[clap(name = "reveal")]
    Reveal {
        /// Model ID to reveal
        #[clap(long)]
        model_id: ObjectID,
        /// URL where the encrypted weights are hosted
        #[clap(long)]
        weights_url: String,
        /// Hex-encoded checksum of the weights file (32 bytes)
        #[clap(long)]
        weights_checksum: String,
        /// Size of the weights file in bytes
        #[clap(long)]
        weights_size: usize,
        /// Hex-encoded AES-256 decryption key (32 bytes)
        #[clap(long)]
        decryption_key: String,
        /// Model embedding vector as comma-separated floats (e.g., "0.1,0.2,0.3,...")
        #[clap(long)]
        embedding: String,
        #[clap(flatten)]
        tx_args: TxProcessingArgs,
    },

    /// Commit updated weights for an active model
    #[clap(name = "update-commit")]
    UpdateCommit {
        /// Model ID to update
        #[clap(long)]
        model_id: ObjectID,
        /// Hex-encoded commitment to the new encrypted weights URL (32 bytes)
        #[clap(long)]
        weights_url_commitment: String,
        /// Hex-encoded commitment to the new decrypted model weights (32 bytes)
        #[clap(long)]
        weights_commitment: String,
        #[clap(flatten)]
        tx_args: TxProcessingArgs,
    },

    /// Reveal updated weights for an active model
    #[clap(name = "update-reveal")]
    UpdateReveal {
        /// Model ID to update
        #[clap(long)]
        model_id: ObjectID,
        /// URL where the new encrypted weights are hosted
        #[clap(long)]
        weights_url: String,
        /// Hex-encoded checksum of the new weights file (32 bytes)
        #[clap(long)]
        weights_checksum: String,
        /// Size of the new weights file in bytes
        #[clap(long)]
        weights_size: usize,
        /// Hex-encoded AES-256 decryption key (32 bytes)
        #[clap(long)]
        decryption_key: String,
        /// Model embedding vector as comma-separated floats (e.g., "0.1,0.2,0.3,...")
        #[clap(long)]
        embedding: String,
        #[clap(flatten)]
        tx_args: TxProcessingArgs,
    },

    /// Deactivate a model (owner only)
    ///
    /// Voluntarily deactivates the model. No slash is applied.
    /// Delegators can withdraw their stake after deactivation.
    #[clap(name = "deactivate")]
    Deactivate {
        /// Model ID to deactivate
        #[clap(long)]
        model_id: ObjectID,
        #[clap(flatten)]
        tx_args: TxProcessingArgs,
    },

    /// Display model information
    #[clap(name = "info")]
    Info {
        /// Model ID to query
        model_id: ObjectID,
    },

    /// List all registered models
    #[clap(name = "list")]
    List,

    /// Set commission rate for the next epoch (owner only)
    #[clap(name = "set-commission-rate")]
    SetCommissionRate {
        /// Model ID
        #[clap(long)]
        model_id: ObjectID,
        /// New commission rate in basis points (100 = 1%, max 10000 = 100%)
        #[clap(long)]
        commission_rate: u64,
        #[clap(flatten)]
        tx_args: TxProcessingArgs,
    },

    /// Download model weights from the validator network
    ///
    /// Fetches model weights via the validator proxy network. The weights are
    /// downloaded from any available validator that serves them.
    #[clap(name = "download")]
    Download {
        /// Model ID to download weights for
        model_id: ObjectID,
        /// Output file path (defaults to ./<model_id>.weights)
        #[clap(short, long)]
        output: Option<PathBuf>,
    },
}

// =============================================================================
// Execution
// =============================================================================

impl ModelCommand {
    pub async fn execute(self, context: &mut WalletContext) -> Result<ModelCommandResponse> {
        let sender = context.active_address()?;

        match self {
            ModelCommand::Commit {
                model_id,
                weights_url_commitment,
                weights_commitment,
                architecture_version,
                stake_amount,
                commission_rate,
                staking_pool_id,
                tx_args,
            } => {
                if commission_rate > 10000 {
                    bail!("Commission rate cannot exceed 10000 (100%)");
                }

                let url_commitment =
                    parse_hex_digest_32(&weights_url_commitment, "weights-url-commitment")?;
                let wt_commitment = parse_hex_digest_32(&weights_commitment, "weights-commitment")?;

                if commission_rate > 5000 {
                    eprintln!(
                        "  {} Commission rate {} ({:.1}%) is unusually high.",
                        "Warning:".yellow().bold(),
                        commission_rate,
                        commission_rate as f64 / 100.0,
                    );
                }

                let kind = TransactionKind::CommitModel(CommitModelArgs {
                    model_id,
                    weights_url_commitment: ModelWeightsUrlCommitment::new(url_commitment),
                    weights_commitment: ModelWeightsCommitment::new(wt_commitment),
                    architecture_version,
                    stake_amount,
                    commission_rate,
                    staking_pool_id,
                });

                let result = execute_tx(context, sender, kind, tx_args).await?;
                Ok(ModelCommandResponse::CommitSuccess {
                    model_id,
                    inner: Box::new(result),
                })
            }

            ModelCommand::Reveal {
                model_id,
                weights_url,
                weights_checksum,
                weights_size,
                decryption_key,
                embedding,
                tx_args,
            } => {
                let manifest = build_weights_manifest(
                    &weights_url,
                    &weights_checksum,
                    weights_size,
                    &decryption_key,
                )?;
                let embedding_tensor = parse_embedding(&embedding)?;

                let kind = TransactionKind::RevealModel(RevealModelArgs {
                    model_id,
                    weights_manifest: manifest,
                    embedding: embedding_tensor,
                });

                let result = execute_tx(context, sender, kind, tx_args).await?;
                Ok(ModelCommandResponse::RevealSuccess {
                    model_id,
                    inner: Box::new(result),
                })
            }

            ModelCommand::UpdateCommit {
                model_id,
                weights_url_commitment,
                weights_commitment,
                tx_args,
            } => {
                let url_commitment =
                    parse_hex_digest_32(&weights_url_commitment, "weights-url-commitment")?;
                let wt_commitment = parse_hex_digest_32(&weights_commitment, "weights-commitment")?;

                let kind = TransactionKind::CommitModelUpdate(CommitModelUpdateArgs {
                    model_id,
                    weights_url_commitment: ModelWeightsUrlCommitment::new(url_commitment),
                    weights_commitment: ModelWeightsCommitment::new(wt_commitment),
                });

                execute_tx(context, sender, kind, tx_args).await
            }

            ModelCommand::UpdateReveal {
                model_id,
                weights_url,
                weights_checksum,
                weights_size,
                decryption_key,
                embedding,
                tx_args,
            } => {
                let manifest = build_weights_manifest(
                    &weights_url,
                    &weights_checksum,
                    weights_size,
                    &decryption_key,
                )?;
                let embedding_tensor = parse_embedding(&embedding)?;

                let kind = TransactionKind::RevealModelUpdate(RevealModelUpdateArgs {
                    model_id,
                    weights_manifest: manifest,
                    embedding: embedding_tensor,
                });

                execute_tx(context, sender, kind, tx_args).await
            }

            ModelCommand::Deactivate { model_id, tx_args } => {
                let kind = TransactionKind::DeactivateModel { model_id };
                execute_tx(context, sender, kind, tx_args).await
            }

            ModelCommand::SetCommissionRate { model_id, commission_rate, tx_args } => {
                if commission_rate > 10000 {
                    bail!("Commission rate cannot exceed 10000 (100%)");
                }

                let kind =
                    TransactionKind::SetModelCommissionRate { model_id, new_rate: commission_rate };
                execute_tx(context, sender, kind, tx_args).await
            }

            ModelCommand::Info { model_id } => {
                let client = context.get_client().await?;
                let system_state = client
                    .get_latest_system_state()
                    .await
                    .map_err(|e| anyhow!("Failed to get system state: {}", e))?;

                match find_model(&system_state, &model_id) {
                    Some((status, summary)) => Ok(ModelCommandResponse::Info(ModelInfoOutput {
                        model_id,
                        status,
                        summary,
                    })),
                    None => {
                        bail!(
                            "Model {} not found in active, pending, or inactive registries",
                            model_id
                        );
                    }
                }
            }

            ModelCommand::List => {
                let client = context.get_client().await?;
                let system_state = client
                    .get_latest_system_state()
                    .await
                    .map_err(|e| anyhow!("Failed to get system state: {}", e))?;

                let models = list_all_models(&system_state);
                Ok(ModelCommandResponse::List(ModelListOutput { models }))
            }

            ModelCommand::Download { model_id, output } => {
                let client = context.get_client().await?;

                // Get system state to create proxy client
                let system_state = client
                    .get_latest_system_state()
                    .await
                    .map_err(|e| anyhow!("Failed to get system state: {}", e))?;

                // Verify model exists
                if find_model(&system_state, &model_id).is_none() {
                    bail!("Model {} not found", model_id);
                }

                // Create proxy client from system state
                let proxy_client = ProxyClient::from_system_state(&system_state)
                    .map_err(|e| anyhow!("Failed to create proxy client: {}", e))?;

                if proxy_client.validator_count() == 0 {
                    bail!("No validators with proxy addresses available");
                }

                // Determine output path
                let output_path = output.unwrap_or_else(|| {
                    PathBuf::from(format!("{}.weights", model_id))
                });

                // Download model weights
                eprintln!("Downloading model {} from {} validators...",
                    model_id, proxy_client.validator_count());

                let data = proxy_client
                    .fetch_model(&model_id)
                    .await
                    .map_err(|e| anyhow!("Failed to download model: {}", e))?;

                // Write to file
                let mut file = tokio::fs::File::create(&output_path)
                    .await
                    .map_err(|e| anyhow!("Failed to create output file: {}", e))?;
                file.write_all(&data)
                    .await
                    .map_err(|e| anyhow!("Failed to write to file: {}", e))?;

                Ok(ModelCommandResponse::Downloaded(ModelDownloadOutput {
                    model_id,
                    output_path,
                    size_bytes: data.len(),
                }))
            }
        }
    }
}

// =============================================================================
// Helpers
// =============================================================================

fn parse_hex_digest_32(hex_str: &str, field_name: &str) -> Result<[u8; 32]> {
    let bytes = Hex::decode(hex_str.strip_prefix("0x").unwrap_or(hex_str))
        .map_err(|e| anyhow!("Invalid hex for {}: {}", field_name, e))?;
    let arr: [u8; 32] =
        bytes.try_into().map_err(|_| anyhow!("{} must be exactly 32 bytes", field_name))?;
    Ok(arr)
}

fn build_weights_manifest(
    url: &str,
    checksum_hex: &str,
    size: usize,
    decryption_key_hex: &str,
) -> Result<ModelWeightsManifest> {
    let parsed_url: url::Url = url.parse().map_err(|e| anyhow!("Invalid URL: {}", e))?;
    let checksum_bytes = parse_hex_digest_32(checksum_hex, "weights-checksum")?;
    let key_bytes = parse_hex_digest_32(decryption_key_hex, "decryption-key")?;

    let metadata = Metadata::V1(MetadataV1::new(Checksum(checksum_bytes), size));
    let manifest = Manifest::V1(ManifestV1::new(parsed_url, metadata));

    Ok(ModelWeightsManifest { manifest, decryption_key: DecryptionKey::new(key_bytes) })
}

fn parse_embedding(embedding_str: &str) -> Result<SomaTensor> {
    let values: Vec<f32> = embedding_str
        .split(',')
        .map(|s| {
            s.trim()
                .parse::<f32>()
                .map_err(|e| anyhow!("Invalid float in embedding: {}", e))
        })
        .collect::<Result<Vec<f32>>>()?;

    if values.is_empty() {
        bail!("Embedding cannot be empty");
    }

    let dim = values.len();
    Ok(SomaTensor::new(values, vec![dim]))
}

/// Execute a model transaction, delegating to the shared client_commands helper.
async fn execute_tx(
    context: &mut WalletContext,
    sender: SomaAddress,
    kind: TransactionKind,
    tx_args: TxProcessingArgs,
) -> Result<ModelCommandResponse> {
    let result =
        crate::client_commands::execute_or_serialize(context, sender, kind, None, tx_args).await?;

    // Convert ClientCommandResponse to ModelCommandResponse
    match result {
        crate::response::ClientCommandResponse::Transaction(tx) => {
            Ok(ModelCommandResponse::Transaction(tx))
        }
        crate::response::ClientCommandResponse::SerializedUnsignedTransaction(s) => {
            Ok(ModelCommandResponse::SerializedTransaction { serialized_unsigned_transaction: s })
        }
        crate::response::ClientCommandResponse::SerializedSignedTransaction(s) => {
            Ok(ModelCommandResponse::SerializedTransaction { serialized_unsigned_transaction: s })
        }
        crate::response::ClientCommandResponse::TransactionDigest(d) => {
            Ok(ModelCommandResponse::TransactionDigest(d))
        }
        crate::response::ClientCommandResponse::Simulation(sim) => {
            Ok(ModelCommandResponse::Simulation(sim))
        }
        _ => bail!("Unexpected response type from transaction execution"),
    }
}

// =============================================================================
// Query helpers
// =============================================================================

#[derive(Debug, Clone, Copy, Serialize, PartialEq, Eq)]
pub enum ModelStatus {
    Pending,
    Active,
    Inactive,
}

impl Display for ModelStatus {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        match self {
            ModelStatus::Pending => write!(f, "{}", "Pending".yellow()),
            ModelStatus::Active => write!(f, "{}", "Active".green()),
            ModelStatus::Inactive => write!(f, "{}", "Inactive".red()),
        }
    }
}

#[derive(Debug, Clone, Serialize)]
pub struct ModelSummary {
    pub model_id: ModelId,
    pub owner: SomaAddress,
    pub status: ModelStatus,
    pub architecture_version: ArchitectureVersion,
    pub commission_rate: u64,
    pub commit_epoch: u64,
    pub stake_balance: u64,
    pub has_pending_update: bool,
}

fn model_to_summary(model_id: &ModelId, model: &Model, status: ModelStatus) -> ModelSummary {
    ModelSummary {
        model_id: *model_id,
        owner: model.owner,
        status,
        architecture_version: model.architecture_version,
        commission_rate: model.commission_rate,
        commit_epoch: model.commit_epoch,
        stake_balance: model.staking_pool.soma_balance,
        has_pending_update: model.has_pending_update(),
    }
}

fn find_model(
    system_state: &SystemState,
    model_id: &ModelId,
) -> Option<(ModelStatus, ModelSummary)> {
    if let Some(model) = system_state.model_registry.active_models.get(model_id) {
        let summary = model_to_summary(model_id, model, ModelStatus::Active);
        return Some((ModelStatus::Active, summary));
    }

    if let Some(model) = system_state.model_registry.pending_models.get(model_id) {
        let summary = model_to_summary(model_id, model, ModelStatus::Pending);
        return Some((ModelStatus::Pending, summary));
    }

    if let Some(model) = system_state.model_registry.inactive_models.get(model_id) {
        let summary = model_to_summary(model_id, model, ModelStatus::Inactive);
        return Some((ModelStatus::Inactive, summary));
    }

    None
}

fn list_all_models(system_state: &SystemState) -> Vec<ModelSummary> {
    let registry = &system_state.model_registry;
    let mut models = Vec::new();

    for (id, model) in &registry.active_models {
        models.push(model_to_summary(id, model, ModelStatus::Active));
    }
    for (id, model) in &registry.pending_models {
        models.push(model_to_summary(id, model, ModelStatus::Pending));
    }
    for (id, model) in &registry.inactive_models {
        models.push(model_to_summary(id, model, ModelStatus::Inactive));
    }

    models
}

// =============================================================================
// Response types
// =============================================================================

#[derive(Debug, Serialize)]
#[serde(untagged)]
pub enum ModelCommandResponse {
    Transaction(TransactionResponse),
    CommitSuccess { model_id: ObjectID, inner: Box<ModelCommandResponse> },
    RevealSuccess { model_id: ObjectID, inner: Box<ModelCommandResponse> },
    SerializedTransaction { serialized_unsigned_transaction: String },
    TransactionDigest(types::digests::TransactionDigest),
    Simulation(crate::response::SimulationResponse),
    Info(ModelInfoOutput),
    List(ModelListOutput),
    Downloaded(ModelDownloadOutput),
}

#[derive(Debug, Serialize)]
pub struct ModelInfoOutput {
    pub model_id: ModelId,
    pub status: ModelStatus,
    pub summary: ModelSummary,
}

#[derive(Debug, Serialize)]
pub struct ModelListOutput {
    pub models: Vec<ModelSummary>,
}

#[derive(Debug, Serialize)]
pub struct ModelDownloadOutput {
    pub model_id: ModelId,
    pub output_path: PathBuf,
    pub size_bytes: usize,
}

impl Display for ModelCommandResponse {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        match self {
            ModelCommandResponse::Transaction(tx_response) => {
                write!(f, "{}", tx_response)
            }
            ModelCommandResponse::CommitSuccess { model_id, inner } => {
                write!(f, "{}", inner)?;
                writeln!(f)?;
                writeln!(f, "  {}", "Next step: Reveal your model weights.".cyan().bold())?;
                writeln!(f)?;
                writeln!(f, "  In the {} epoch, run:", "next".bold())?;
                writeln!(
                    f,
                    "  {} \\",
                    "soma model reveal".bold()
                )?;
                writeln!(f, "    --model-id {} \\", model_id)?;
                writeln!(f, "    --weights-url <url> \\")?;
                writeln!(f, "    --weights-checksum <hex> \\")?;
                writeln!(f, "    --weights-size <bytes> \\")?;
                writeln!(f, "    --decryption-key <hex> \\")?;
                writeln!(f, "    --embedding <f32,f32,...>")?;
                Ok(())
            }
            ModelCommandResponse::RevealSuccess { model_id, inner } => {
                write!(f, "{}", inner)?;
                writeln!(f)?;
                writeln!(
                    f,
                    "  {}",
                    "Your model is now registered and accepting stakes.".green().bold()
                )?;
                writeln!(f, "  View it: {} --model-id {}", "soma model info".bold(), model_id)?;
                Ok(())
            }
            ModelCommandResponse::SerializedTransaction { serialized_unsigned_transaction } => {
                writeln!(f, "{}", "Serialized Unsigned Transaction".cyan().bold())?;
                writeln!(f)?;
                writeln!(f, "{}", serialized_unsigned_transaction)?;
                writeln!(f)?;
                writeln!(
                    f,
                    "{}",
                    "Use 'soma client execute-signed-tx' to submit after signing.".yellow()
                )
            }
            ModelCommandResponse::TransactionDigest(digest) => {
                writeln!(f, "{}: {}", "Transaction Digest".bold(), digest)
            }
            ModelCommandResponse::Simulation(sim) => write!(f, "{}", sim),
            ModelCommandResponse::Info(info) => write!(f, "{}", info),
            ModelCommandResponse::List(list) => write!(f, "{}", list),
            ModelCommandResponse::Downloaded(dl) => write!(f, "{}", dl),
        }
    }
}

impl Display for ModelDownloadOutput {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        writeln!(f, "{}", "Model Downloaded Successfully".green().bold())?;
        writeln!(f)?;
        writeln!(f, "{}: {}", "Model ID".bold(), self.model_id)?;
        writeln!(f, "{}: {}", "Output".bold(), self.output_path.display())?;
        writeln!(f, "{}: {} bytes", "Size".bold(), self.size_bytes)
    }
}

impl Display for ModelInfoOutput {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        let s = &self.summary;
        let mut builder = TableBuilder::default();
        builder.push_record(["Model ID", &s.model_id.to_string()]);
        builder.push_record(["Owner", &s.owner.to_string()]);
        builder.push_record(["Status", &s.status.to_string()]);
        builder.push_record(["Architecture", &s.architecture_version.to_string()]);
        builder
            .push_record(["Commission Rate", &format!("{:.2}%", s.commission_rate as f64 / 100.0)]);
        builder.push_record(["Commit Epoch", &s.commit_epoch.to_string()]);
        builder.push_record(["Stake Balance", &format!("{} SHANNONS", s.stake_balance)]);
        if s.has_pending_update {
            builder.push_record(["Pending Update", "Yes"]);
        }

        let mut table = builder.build();
        table.with(TableStyle::rounded());
        table.with(TablePanel::header("Model Information"));
        table.with(HorizontalLine::new(1, TableStyle::modern().get_horizontal()));
        table.with(tabled::settings::style::BorderSpanCorrection);
        writeln!(f, "{}", table)
    }
}

impl Display for ModelListOutput {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        if self.models.is_empty() {
            return writeln!(f, "{}", "No models registered.".yellow());
        }

        let mut builder = TableBuilder::default();
        builder.push_record(["Model ID", "Owner", "Status", "Arch", "Stake", "Epoch"]);

        for s in &self.models {
            builder.push_record([
                truncate_id(&s.model_id.to_string()),
                truncate_id(&s.owner.to_string()),
                s.status.to_string(),
                s.architecture_version.to_string(),
                format!("{}", s.stake_balance),
                s.commit_epoch.to_string(),
            ]);
        }

        let mut table = builder.build();
        table.with(TableStyle::rounded());
        table.with(TablePanel::header(format!("Registered Models ({} total)", self.models.len())));
        table.with(HorizontalLine::new(1, TableStyle::modern().get_horizontal()));
        table.with(HorizontalLine::new(2, TableStyle::modern().get_horizontal()));
        table.with(tabled::settings::style::BorderSpanCorrection);
        writeln!(f, "{}", table)
    }
}

impl ModelCommandResponse {
    pub fn print(&self, json: bool) {
        if json {
            match serde_json::to_string_pretty(self) {
                Ok(s) => println!("{}", s),
                Err(e) => eprintln!("Failed to serialize response: {}", e),
            }
        } else {
            print!("{}", self);
        }
    }
}

fn truncate_id(s: &str) -> String {
    if s.len() <= 16 { s.to_string() } else { format!("{}...{}", &s[..10], &s[s.len() - 6..]) }
}
