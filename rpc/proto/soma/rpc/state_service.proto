syntax = "proto3";

package soma.rpc;

import "google/protobuf/field_mask.proto";
import "google/protobuf/struct.proto";
import "soma/rpc/executed_transaction.proto";
import "soma/rpc/object.proto";
import "soma/rpc/system_state.proto";
import "soma/rpc/transaction.proto";


service StateService {
  rpc ListOwnedObjects(ListOwnedObjectsRequest) returns (ListOwnedObjectsResponse);
  rpc GetBalance(GetBalanceRequest) returns (GetBalanceResponse);
  rpc GetTarget(GetTargetRequest) returns (GetTargetResponse);
  rpc ListTargets(ListTargetsRequest) returns (ListTargetsResponse);
  rpc GetChallenge(GetChallengeRequest) returns (GetChallengeResponse);
  rpc ListChallenges(ListChallengesRequest) returns (ListChallengesResponse);
}

// Request message for `LiveDataService.GetBalance`.
message GetBalanceRequest {
  // Required. The owner's Sui address.
  optional string owner = 1;
}

// Response message for `LiveDataService.GetBalance`.
// Return the total coin balance for coin, owned by the address owner.
message GetBalanceResponse {
  optional uint64 balance = 1;
}

message ListOwnedObjectsRequest {
  // Required. The address of the account that owns the objects.
  optional string owner = 1;

  // The maximum number of entries return. The service may return fewer than this value.
  // If unspecified, at most `50` entries will be returned.
  // The maximum value is `1000`; values above `1000` will be coerced to `1000`.
  optional uint32 page_size = 2;

  // A page token, received from a previous `ListOwnedObjects` call.
  // Provide this to retrieve the subsequent page.
  //
  // When paginating, all other parameters provided to `ListOwnedObjects` must
  // match the call that provided the page token.
  optional bytes page_token = 3;

  // Mask specifying which fields to read.
  // If no mask is specified, defaults to `object_id,version,object_type`.
  optional google.protobuf.FieldMask read_mask = 4;

  // Optional type filter to limit the types of objects listed.
  //
  // Providing an object type with no type params will return objects of that
  // type with any type parameter.
  optional string object_type = 5;
}

message ListOwnedObjectsResponse {
  // Page of dynamic fields owned by the specified parent.
  repeated Object objects = 1;

  // A token, which can be sent as `page_token` to retrieve the next page.
  // If this field is omitted, there are no subsequent pages.
  optional bytes next_page_token = 2;
}

// Request message for `StateService.GetTarget`.
message GetTargetRequest {
  // Required. The target ID (ObjectID hex string).
  optional string target_id = 1;

  // Mask specifying which fields to read.
  // If no mask is specified, all fields are returned.
  optional google.protobuf.FieldMask read_mask = 2;
}

// Response message for `StateService.GetTarget`.
message GetTargetResponse {
  optional Target target = 1;
}

// Request message for `StateService.ListTargets`.
message ListTargetsRequest {
  // Optional status filter: "open", "filled", or "claimed".
  // If not specified, returns targets of all statuses.
  optional string status_filter = 1;

  // Optional epoch filter. If specified, only returns targets with
  // generation_epoch equal to this value.
  optional uint64 epoch_filter = 2;

  // The maximum number of entries to return. The service may return fewer.
  // If unspecified, at most `50` entries will be returned.
  // The maximum value is `1000`; values above `1000` will be coerced to `1000`.
  optional uint32 page_size = 3;

  // A page token, received from a previous `ListTargets` call.
  // Provide this to retrieve the subsequent page.
  optional bytes page_token = 4;

  // Mask specifying which fields to read on each target.
  // If no mask is specified, all fields are returned.
  optional google.protobuf.FieldMask read_mask = 5;
}

// Response message for `StateService.ListTargets`.
message ListTargetsResponse {
  // Page of targets matching the filters.
  repeated Target targets = 1;

  // A token, which can be sent as `page_token` to retrieve the next page.
  // If this field is omitted, there are no subsequent pages.
  optional bytes next_page_token = 2;
}

// Request message for `StateService.GetChallenge`.
message GetChallengeRequest {
  // Required. The challenge ID (ObjectID hex string).
  optional string challenge_id = 1;

  // Mask specifying which fields to read.
  // If no mask is specified, all fields are returned.
  optional google.protobuf.FieldMask read_mask = 2;
}

// Response message for `StateService.GetChallenge`.
message GetChallengeResponse {
  optional Challenge challenge = 1;
}

// Request message for `StateService.ListChallenges`.
message ListChallengesRequest {
  // Optional target ID filter. If specified, only returns challenges for this target.
  optional string target_id = 1;

  // Optional status filter: "pending" or "resolved".
  // If not specified, returns challenges of all statuses.
  optional string status_filter = 2;

  // Optional epoch filter. If specified, only returns challenges with
  // challenge_epoch equal to this value.
  optional uint64 epoch_filter = 3;

  // The maximum number of entries to return. The service may return fewer.
  // If unspecified, at most `50` entries will be returned.
  // The maximum value is `1000`; values above `1000` will be coerced to `1000`.
  optional uint32 page_size = 4;

  // A page token, received from a previous `ListChallenges` call.
  // Provide this to retrieve the subsequent page.
  optional bytes page_token = 5;

  // Mask specifying which fields to read on each challenge.
  // If no mask is specified, all fields are returned.
  optional google.protobuf.FieldMask read_mask = 6;
}

// Response message for `StateService.ListChallenges`.
message ListChallengesResponse {
  // Page of challenges matching the filters.
  repeated Challenge challenges = 1;

  // A token, which can be sent as `page_token` to retrieve the next page.
  // If this field is omitted, there are no subsequent pages.
  optional bytes next_page_token = 2;
}