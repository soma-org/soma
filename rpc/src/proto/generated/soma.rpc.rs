// This file is @generated by prost-build.
/// The delta, or change, in balance for an address for a particular `Coin` type.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BalanceChange {
    /// The account address that is affected by this balance change event.
    #[prost(string, optional, tag = "1")]
    pub address: ::core::option::Option<::prost::alloc::string::String>,
    /// The amount or change in balance.
    #[prost(string, optional, tag = "2")]
    pub amount: ::core::option::Option<::prost::alloc::string::String>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Checkpoint {
    /// The height of this checkpoint.
    #[prost(uint64, optional, tag = "1")]
    pub sequence_number: ::core::option::Option<u64>,
    /// The digest of this Checkpoint's CheckpointSummary.
    #[prost(string, optional, tag = "2")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// The `CheckpointSummary` for this checkpoint.
    #[prost(message, optional, tag = "3")]
    pub summary: ::core::option::Option<CheckpointSummary>,
    /// An aggregated quorum signature from the validator committee that
    /// certified this checkpoint.
    #[prost(message, optional, tag = "4")]
    pub signature: ::core::option::Option<ValidatorAggregatedSignature>,
    /// The `CheckpointContents` for this checkpoint.
    #[prost(message, optional, tag = "5")]
    pub contents: ::core::option::Option<CheckpointContents>,
    /// List of transactions included in this checkpoint.
    #[prost(message, repeated, tag = "6")]
    pub transactions: ::prost::alloc::vec::Vec<ExecutedTransaction>,
    /// Set of objects either referenced as inputs or produced as
    /// outputs by transactions included in this checkpoint.
    ///
    /// In order to benefit from deduplication of objects that
    /// appear in multiple transactions in this checkpoint, objects
    /// will only be present here and the `transactions.objects`
    /// field will not be populated.
    #[prost(message, optional, tag = "7")]
    pub objects: ::core::option::Option<ObjectSet>,
}
/// The committed to contents of a checkpoint.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckpointContents {
    /// The digest of this CheckpointContents.
    #[prost(string, optional, tag = "1")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Version of this CheckpointContents
    #[prost(int32, optional, tag = "2")]
    pub version: ::core::option::Option<i32>,
    /// Set of transactions committed to in this checkpoint.
    #[prost(message, repeated, tag = "3")]
    pub transactions: ::prost::alloc::vec::Vec<CheckpointedTransactionInfo>,
}
/// Transaction information committed to in a checkpoint.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckpointedTransactionInfo {
    /// Digest of the transaction.
    #[prost(string, optional, tag = "1")]
    pub transaction: ::core::option::Option<::prost::alloc::string::String>,
    /// Digest of the effects.
    #[prost(string, optional, tag = "2")]
    pub effects: ::core::option::Option<::prost::alloc::string::String>,
    /// Set of user signatures that authorized the transaction.
    #[prost(message, repeated, tag = "3")]
    pub signatures: ::prost::alloc::vec::Vec<UserSignature>,
}
/// A header for a checkpoint on the SOMA blockchain.
///
/// On the SOMA network, checkpoints define the history of the blockchain. They are quite similar to
/// the concept of blocks used by other blockchains like Bitcoin or Ethereum. The SOMA blockchain,
/// however, forms checkpoints after transaction execution has already happened to provide a
/// certified history of the chain, instead of being formed before execution.
///
/// Checkpoints commit to a variety of state, including but not limited to:
/// - The hash of the previous checkpoint.
/// - The set of transaction digests, their corresponding effects digests, as well as the set of
///    user signatures that authorized its execution.
/// - The objects produced by a transaction.
/// - The set of live objects that make up the current state of the chain.
/// - On epoch transitions, the next validator committee.
///
/// `CheckpointSummary`s themselves don't directly include all of the previous information but they
/// are the top-level type by which all the information is committed to transitively via cryptographic
/// hashes included in the summary. `CheckpointSummary`s are signed and certified by a quorum of
/// the validator committee in a given epoch to allow verification of the chain's state.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckpointSummary {
    /// The digest of this CheckpointSummary.
    #[prost(string, optional, tag = "1")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Epoch that this checkpoint belongs to.
    #[prost(uint64, optional, tag = "2")]
    pub epoch: ::core::option::Option<u64>,
    /// The height of this checkpoint.
    #[prost(uint64, optional, tag = "3")]
    pub sequence_number: ::core::option::Option<u64>,
    /// Total number of transactions committed since genesis, including those in this
    /// checkpoint.
    #[prost(uint64, optional, tag = "4")]
    pub total_network_transactions: ::core::option::Option<u64>,
    /// The hash of the `CheckpointContents` for this checkpoint.
    #[prost(string, optional, tag = "5")]
    pub content_digest: ::core::option::Option<::prost::alloc::string::String>,
    /// The hash of the previous `CheckpointSummary`.
    ///
    /// This will be `None` only for the first, or genesis, checkpoint.
    #[prost(string, optional, tag = "6")]
    pub previous_digest: ::core::option::Option<::prost::alloc::string::String>,
    /// The running total fees of all transactions included in the current epoch so far
    /// until this checkpoint.
    #[prost(message, optional, tag = "7")]
    pub epoch_rolling_transaction_fees: ::core::option::Option<TransactionFee>,
    /// Timestamp of the checkpoint - number of milliseconds from the Unix epoch
    /// Checkpoint timestamps are monotonic, but not strongly monotonic - subsequent
    /// checkpoints can have the same timestamp if they originate from the same underlining consensus commit.
    #[prost(message, optional, tag = "8")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Commitments to checkpoint-specific state.
    #[prost(message, repeated, tag = "9")]
    pub commitments: ::prost::alloc::vec::Vec<CheckpointCommitment>,
    /// Extra data only present in the final checkpoint of an epoch.
    #[prost(message, optional, tag = "10")]
    pub end_of_epoch_data: ::core::option::Option<EndOfEpochData>,
}
/// Data, which when included in a `CheckpointSummary`, signals the end of an `Epoch`.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EndOfEpochData {
    /// The set of validators that will be in the `ValidatorCommittee` for the next epoch.
    #[prost(message, optional, tag = "1")]
    pub next_epoch_validator_committee: ::core::option::Option<ValidatorCommittee>,
    /// The protocol version that is in effect during the next epoch.
    #[prost(uint64, optional, tag = "4")]
    pub next_epoch_protocol_version: ::core::option::Option<u64>,
    /// Commitments to epoch specific state (live object set)
    #[prost(message, repeated, tag = "5")]
    pub epoch_commitments: ::prost::alloc::vec::Vec<CheckpointCommitment>,
}
/// A commitment made by a checkpoint.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckpointCommitment {
    #[prost(
        enumeration = "checkpoint_commitment::CheckpointCommitmentKind",
        optional,
        tag = "1"
    )]
    pub kind: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `CheckpointCommitment`.
pub mod checkpoint_commitment {
    #[non_exhaustive]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CheckpointCommitmentKind {
        Unknown = 0,
        /// An elliptic curve multiset hash attesting to the set of objects that
        /// comprise the live state of the SOMA blockchain.
        EcmhLiveObjectSet = 1,
        /// Digest of the checkpoint artifacts.
        CheckpointArtifacts = 2,
    }
    impl CheckpointCommitmentKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "CHECKPOINT_COMMITMENT_KIND_UNKNOWN",
                Self::EcmhLiveObjectSet => "ECMH_LIVE_OBJECT_SET",
                Self::CheckpointArtifacts => "CHECKPOINT_ARTIFACTS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CHECKPOINT_COMMITMENT_KIND_UNKNOWN" => Some(Self::Unknown),
                "ECMH_LIVE_OBJECT_SET" => Some(Self::EcmhLiveObjectSet),
                "CHECKPOINT_ARTIFACTS" => Some(Self::CheckpointArtifacts),
                _ => None,
            }
        }
    }
}
/// The effects of executing a transaction.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionEffects {
    /// The status of the execution.
    #[prost(message, optional, tag = "1")]
    pub status: ::core::option::Option<ExecutionStatus>,
    /// The epoch when this transaction was executed.
    #[prost(uint64, optional, tag = "2")]
    pub epoch: ::core::option::Option<u64>,
    /// The transaction fee
    #[prost(message, optional, tag = "3")]
    pub fee: ::core::option::Option<TransactionFee>,
    /// The transaction digest.
    #[prost(string, optional, tag = "4")]
    pub transaction_digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Information about the gas object. Also present in the `changed_objects` vector.
    ///
    /// System transactions that don't require gas will leave this as `None`.
    #[prost(uint32, optional, tag = "5")]
    pub gas_object_index: ::core::option::Option<u32>,
    /// The set of transaction digests this transaction depends on.
    #[prost(string, repeated, tag = "6")]
    pub dependencies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The version number of all the written objects (excluding packages) by this transaction.
    #[prost(uint64, optional, tag = "7")]
    pub lamport_version: ::core::option::Option<u64>,
    /// Objects whose state are changed by this transaction.
    #[prost(message, repeated, tag = "8")]
    pub changed_objects: ::prost::alloc::vec::Vec<ChangedObject>,
    /// Shared objects that are not mutated in this transaction. Unlike owned objects,
    /// read-only shared objects' version are not committed in the transaction,
    /// and in order for a node to catch up and execute it without consensus sequencing,
    /// the version needs to be committed in the effects.
    #[prost(message, repeated, tag = "9")]
    pub unchanged_shared_objects: ::prost::alloc::vec::Vec<UnchangedSharedObject>,
}
/// Input/output state of an object that was changed during execution.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangedObject {
    /// ID of the object.
    #[prost(string, optional, tag = "1")]
    pub object_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "changed_object::InputObjectState", optional, tag = "2")]
    pub input_state: ::core::option::Option<i32>,
    /// Version of the object before this transaction executed.
    #[prost(uint64, optional, tag = "3")]
    pub input_version: ::core::option::Option<u64>,
    /// Digest of the object before this transaction executed.
    #[prost(string, optional, tag = "4")]
    pub input_digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Owner of the object before this transaction executed.
    #[prost(message, optional, tag = "5")]
    pub input_owner: ::core::option::Option<Owner>,
    #[prost(enumeration = "changed_object::OutputObjectState", optional, tag = "6")]
    pub output_state: ::core::option::Option<i32>,
    /// Version of the object after this transaction executed.
    #[prost(uint64, optional, tag = "7")]
    pub output_version: ::core::option::Option<u64>,
    /// Digest of the object after this transaction executed.
    #[prost(string, optional, tag = "8")]
    pub output_digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Owner of the object after this transaction executed.
    #[prost(message, optional, tag = "9")]
    pub output_owner: ::core::option::Option<Owner>,
    /// What happened to an `ObjectId` during execution.
    #[prost(enumeration = "changed_object::IdOperation", optional, tag = "10")]
    pub id_operation: ::core::option::Option<i32>,
    /// Type information is not provided by the effects structure but is instead
    /// provided by an indexing layer
    #[prost(string, optional, tag = "11")]
    pub object_type: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `ChangedObject`.
pub mod changed_object {
    #[non_exhaustive]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InputObjectState {
        Unknown = 0,
        DoesNotExist = 1,
        Exists = 2,
    }
    impl InputObjectState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "INPUT_OBJECT_STATE_UNKNOWN",
                Self::DoesNotExist => "INPUT_OBJECT_STATE_DOES_NOT_EXIST",
                Self::Exists => "INPUT_OBJECT_STATE_EXISTS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INPUT_OBJECT_STATE_UNKNOWN" => Some(Self::Unknown),
                "INPUT_OBJECT_STATE_DOES_NOT_EXIST" => Some(Self::DoesNotExist),
                "INPUT_OBJECT_STATE_EXISTS" => Some(Self::Exists),
                _ => None,
            }
        }
    }
    #[non_exhaustive]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OutputObjectState {
        Unknown = 0,
        DoesNotExist = 1,
        ObjectWrite = 2,
    }
    impl OutputObjectState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "OUTPUT_OBJECT_STATE_UNKNOWN",
                Self::DoesNotExist => "OUTPUT_OBJECT_STATE_DOES_NOT_EXIST",
                Self::ObjectWrite => "OUTPUT_OBJECT_STATE_OBJECT_WRITE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OUTPUT_OBJECT_STATE_UNKNOWN" => Some(Self::Unknown),
                "OUTPUT_OBJECT_STATE_DOES_NOT_EXIST" => Some(Self::DoesNotExist),
                "OUTPUT_OBJECT_STATE_OBJECT_WRITE" => Some(Self::ObjectWrite),
                _ => None,
            }
        }
    }
    #[non_exhaustive]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum IdOperation {
        Unknown = 0,
        None = 1,
        Created = 2,
        Deleted = 3,
    }
    impl IdOperation {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "ID_OPERATION_UNKNOWN",
                Self::None => "NONE",
                Self::Created => "CREATED",
                Self::Deleted => "DELETED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ID_OPERATION_UNKNOWN" => Some(Self::Unknown),
                "NONE" => Some(Self::None),
                "CREATED" => Some(Self::Created),
                "DELETED" => Some(Self::Deleted),
                _ => None,
            }
        }
    }
}
/// A shared object that wasn't changed during execution.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnchangedSharedObject {
    #[prost(
        enumeration = "unchanged_shared_object::UnchangedSharedObjectKind",
        optional,
        tag = "1"
    )]
    pub kind: ::core::option::Option<i32>,
    /// ObjectId of the consensus object.
    #[prost(string, optional, tag = "2")]
    pub object_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Version of the consensus object.
    #[prost(uint64, optional, tag = "3")]
    pub version: ::core::option::Option<u64>,
    /// Digest of the consensus object.
    #[prost(string, optional, tag = "4")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Type information is not provided by the effects structure but is instead
    /// provided by an indexing layer
    #[prost(string, optional, tag = "5")]
    pub object_type: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `UnchangedSharedObject`.
pub mod unchanged_shared_object {
    #[non_exhaustive]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UnchangedSharedObjectKind {
        Unknown = 0,
        /// Read-only shared object from the input.
        ReadOnlyRoot = 1,
        /// / Deleted shared objects that appear mutably/owned in the input
        MutatedDeleted = 2,
        /// Deleted shared objects that appear as read-only in the input.
        ReadDeleted = 3,
        /// Consensus objects that were congested and resulted in this transaction being
        /// canceled.
        Canceled = 4,
    }
    impl UnchangedSharedObjectKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNCHANGED_SHARED_OBJECT_KIND_UNKNOWN",
                Self::ReadOnlyRoot => "READ_ONLY_ROOT",
                Self::MutatedDeleted => "MUTATED_DELETED",
                Self::ReadDeleted => "READ_DELETED",
                Self::Canceled => "CANCELED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNCHANGED_SHARED_OBJECT_KIND_UNKNOWN" => Some(Self::Unknown),
                "READ_ONLY_ROOT" => Some(Self::ReadOnlyRoot),
                "MUTATED_DELETED" => Some(Self::MutatedDeleted),
                "READ_DELETED" => Some(Self::ReadDeleted),
                "CANCELED" => Some(Self::Canceled),
                _ => None,
            }
        }
    }
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Epoch {
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    /// The committee governing this epoch.
    #[prost(message, optional, tag = "2")]
    pub committee: ::core::option::Option<ValidatorCommittee>,
    /// Snapshot of SystemState at the
    /// beginning of the epoch, for past epochs, or the current state for the
    /// current epoch.
    #[prost(message, optional, boxed, tag = "3")]
    pub system_state: ::core::option::Option<::prost::alloc::boxed::Box<SystemState>>,
    #[prost(uint64, optional, tag = "4")]
    pub first_checkpoint: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "5")]
    pub last_checkpoint: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "6")]
    pub start: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub end: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub protocol_config: ::core::option::Option<ProtocolConfig>,
}
#[non_exhaustive]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ErrorReason {
    Unknown = 0,
    FieldInvalid = 1,
    FieldMissing = 2,
}
impl ErrorReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "ERROR_REASON_UNKNOWN",
            Self::FieldInvalid => "FIELD_INVALID",
            Self::FieldMissing => "FIELD_MISSING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ERROR_REASON_UNKNOWN" => Some(Self::Unknown),
            "FIELD_INVALID" => Some(Self::FieldInvalid),
            "FIELD_MISSING" => Some(Self::FieldMissing),
            _ => None,
        }
    }
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutedTransaction {
    /// The digest of this Transaction.
    #[prost(string, optional, tag = "1")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// The transaction itself.
    #[prost(message, optional, tag = "2")]
    pub transaction: ::core::option::Option<Transaction>,
    /// List of user signatures that are used to authorize the
    /// execution of this transaction.
    #[prost(message, repeated, tag = "3")]
    pub signatures: ::prost::alloc::vec::Vec<UserSignature>,
    /// The `TransactionEffects` for this transaction.
    #[prost(message, optional, tag = "4")]
    pub effects: ::core::option::Option<TransactionEffects>,
    /// The checkpoint index that includes this transaction.
    #[prost(uint64, optional, tag = "5")]
    pub checkpoint: ::core::option::Option<u64>,
    /// The Unix timestamp of the checkpoint that includes this transaction.
    #[prost(message, optional, tag = "6")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, repeated, tag = "7")]
    pub balance_changes: ::prost::alloc::vec::Vec<BalanceChange>,
    /// Set of objects either referenced as inputs or produced as
    /// outputs from this Transaction.
    #[prost(message, optional, tag = "9")]
    pub objects: ::core::option::Option<ObjectSet>,
}
/// The status of an executed transaction.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutionStatus {
    /// Indicates if the transaction was successful or not.
    #[prost(bool, optional, tag = "1")]
    pub success: ::core::option::Option<bool>,
    /// The error if `success` is false.
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<ExecutionError>,
}
/// An error that can occur during the execution of a transaction.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutionError {
    /// A human readable description of the error
    #[prost(string, optional, tag = "1")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "execution_error::ExecutionErrorKind", optional, tag = "2")]
    pub kind: ::core::option::Option<i32>,
    #[prost(oneof = "execution_error::ErrorDetails", tags = "3, 4")]
    pub error_details: ::core::option::Option<execution_error::ErrorDetails>,
}
/// Nested message and enum types in `ExecutionError`.
pub mod execution_error {
    #[non_exhaustive]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExecutionErrorKind {
        Unknown = 0,
        /// Insufficient gas.
        InsufficientGas = 1,
        /// Invalid owner for object.
        InvalidOwnership = 2,
        /// Object not found.
        ObjectNotFound = 3,
        /// Invalid object type.
        InvalidObjectType = 4,
        /// Invalid transaction type
        InvalidTransactionType = 5,
        /// Invalid arguments for transaction
        InvalidArguments = 6,
        /// Adding avalidator that already exists
        DuplicateValidator = 7,
        /// Trying to remove a validator that doesn't exist
        NotAValidator = 8,
        /// Removing a validator that was already removed
        ValidatorAlreadyRemoved = 9,
        /// Advancing to unexpected epoch
        AdvancedToWrongEpoch = 10,
        /// Model not found
        ModelNotFound = 11,
        /// Sender is not the model owner
        NotModelOwner = 12,
        /// Model is not in active state
        ModelNotActive = 13,
        /// Insufficient coin balance for requested operation.
        InsufficientCoinBalance = 14,
        /// Coin balance overflowed an u64.
        CoinBalanceOverflow = 15,
        /// Validator not found
        ValidatorNotFound = 16,
        /// Staking pool not found
        StakingPoolNotFound = 18,
        /// Validator cannot report oneself
        CannotReportOneself = 19,
        /// Unreported record cannot be undone
        ReportRecordNotFound = 20,
        InputObjectDeleted = 21,
        CertificateDenied = 22,
        SharedObjectCongestion = 23,
        /// Other error.
        OtherError = 24,
        /// Model is not in pending (committed) state
        ModelNotPending = 25,
        /// Model is already inactive
        ModelAlreadyInactive = 26,
        /// Model reveal epoch mismatch
        ModelRevealEpochMismatch = 27,
        /// Model embedding commitment mismatch
        ModelEmbeddingCommitmentMismatch = 28,
        /// Model has no pending update
        ModelNoPendingUpdate = 29,
        /// Model architecture version mismatch
        ModelArchitectureVersionMismatch = 30,
        /// Model commission rate exceeds maximum
        ModelCommissionRateTooHigh = 31,
        /// Model minimum stake requirement not met
        ModelMinStakeNotMet = 32,
        /// No active models available for target generation
        NoActiveModels = 33,
        /// Target not found
        TargetNotFound = 34,
        /// Target is not open for submissions
        TargetNotOpen = 35,
        /// Target has expired
        TargetExpired = 36,
        /// Target is not filled
        TargetNotFilled = 37,
        /// Challenge window is still open
        ChallengeWindowOpen = 38,
        /// Target rewards have already been claimed
        TargetAlreadyClaimed = 39,
        /// Model is not assigned to target
        ModelNotInTarget = 40,
        /// Embedding dimension mismatch
        EmbeddingDimensionMismatch = 41,
        /// Distance score exceeds threshold
        DistanceExceedsThreshold = 42,
        /// Insufficient bond for submission
        InsufficientBond = 43,
        /// Insufficient emission pool balance
        InsufficientEmissionBalance = 44,
        /// Challenge window has closed
        ChallengeWindowClosed = 45,
        /// Insufficient challenger bond
        InsufficientChallengerBond = 46,
        /// Challenge not found
        ChallengeNotFound = 47,
        /// Challenge is not pending
        ChallengeNotPending = 48,
        /// Challenge has expired
        ChallengeExpired = 49,
        /// Invalid challenge result
        InvalidChallengeResult = 50,
        /// Invalid challenge quorum
        InvalidChallengeQuorum = 51,
        /// Data exceeds maximum allowed size
        DataExceedsMaxSize = 52,
        /// Challenge already exists for this target
        ChallengeAlreadyExists = 53,
        /// Duplicate validator metadata (key or address conflicts with existing validator)
        DuplicateValidatorMetadata = 54,
        /// Missing proof of possession for protocol key change
        MissingProofOfPossession = 55,
        /// Invalid proof of possession signature
        InvalidProofOfPossession = 56,
        /// Model decryption key commitment mismatch
        ModelDecryptionKeyCommitmentMismatch = 57,
    }
    impl ExecutionErrorKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "EXECUTION_ERROR_KIND_UNKNOWN",
                Self::InsufficientGas => "INSUFFICIENT_GAS",
                Self::InvalidOwnership => "INVALID_OWNERSHIP",
                Self::ObjectNotFound => "OBJECT_NOT_FOUND",
                Self::InvalidObjectType => "INVALID_OBJECT_TYPE",
                Self::InvalidTransactionType => "INVALID_TRANSACTION_TYPE",
                Self::InvalidArguments => "INVALID_ARGUMENTS",
                Self::DuplicateValidator => "DUPLICATE_VALIDATOR",
                Self::NotAValidator => "NOT_A_VALIDATOR",
                Self::ValidatorAlreadyRemoved => "VALIDATOR_ALREADY_REMOVED",
                Self::AdvancedToWrongEpoch => "ADVANCED_TO_WRONG_EPOCH",
                Self::ModelNotFound => "MODEL_NOT_FOUND",
                Self::NotModelOwner => "NOT_MODEL_OWNER",
                Self::ModelNotActive => "MODEL_NOT_ACTIVE",
                Self::InsufficientCoinBalance => "INSUFFICIENT_COIN_BALANCE",
                Self::CoinBalanceOverflow => "COIN_BALANCE_OVERFLOW",
                Self::ValidatorNotFound => "VALIDATOR_NOT_FOUND",
                Self::StakingPoolNotFound => "STAKING_POOL_NOT_FOUND",
                Self::CannotReportOneself => "CANNOT_REPORT_ONESELF",
                Self::ReportRecordNotFound => "REPORT_RECORD_NOT_FOUND",
                Self::InputObjectDeleted => "INPUT_OBJECT_DELETED",
                Self::CertificateDenied => "CERTIFICATE_DENIED",
                Self::SharedObjectCongestion => "SHARED_OBJECT_CONGESTION",
                Self::OtherError => "OTHER_ERROR",
                Self::ModelNotPending => "MODEL_NOT_PENDING",
                Self::ModelAlreadyInactive => "MODEL_ALREADY_INACTIVE",
                Self::ModelRevealEpochMismatch => "MODEL_REVEAL_EPOCH_MISMATCH",
                Self::ModelEmbeddingCommitmentMismatch => {
                    "MODEL_EMBEDDING_COMMITMENT_MISMATCH"
                }
                Self::ModelNoPendingUpdate => "MODEL_NO_PENDING_UPDATE",
                Self::ModelArchitectureVersionMismatch => {
                    "MODEL_ARCHITECTURE_VERSION_MISMATCH"
                }
                Self::ModelCommissionRateTooHigh => "MODEL_COMMISSION_RATE_TOO_HIGH",
                Self::ModelMinStakeNotMet => "MODEL_MIN_STAKE_NOT_MET",
                Self::NoActiveModels => "NO_ACTIVE_MODELS",
                Self::TargetNotFound => "TARGET_NOT_FOUND",
                Self::TargetNotOpen => "TARGET_NOT_OPEN",
                Self::TargetExpired => "TARGET_EXPIRED",
                Self::TargetNotFilled => "TARGET_NOT_FILLED",
                Self::ChallengeWindowOpen => "CHALLENGE_WINDOW_OPEN",
                Self::TargetAlreadyClaimed => "TARGET_ALREADY_CLAIMED",
                Self::ModelNotInTarget => "MODEL_NOT_IN_TARGET",
                Self::EmbeddingDimensionMismatch => "EMBEDDING_DIMENSION_MISMATCH",
                Self::DistanceExceedsThreshold => "DISTANCE_EXCEEDS_THRESHOLD",
                Self::InsufficientBond => "INSUFFICIENT_BOND",
                Self::InsufficientEmissionBalance => "INSUFFICIENT_EMISSION_BALANCE",
                Self::ChallengeWindowClosed => "CHALLENGE_WINDOW_CLOSED",
                Self::InsufficientChallengerBond => "INSUFFICIENT_CHALLENGER_BOND",
                Self::ChallengeNotFound => "CHALLENGE_NOT_FOUND",
                Self::ChallengeNotPending => "CHALLENGE_NOT_PENDING",
                Self::ChallengeExpired => "CHALLENGE_EXPIRED",
                Self::InvalidChallengeResult => "INVALID_CHALLENGE_RESULT",
                Self::InvalidChallengeQuorum => "INVALID_CHALLENGE_QUORUM",
                Self::DataExceedsMaxSize => "DATA_EXCEEDS_MAX_SIZE",
                Self::ChallengeAlreadyExists => "CHALLENGE_ALREADY_EXISTS",
                Self::DuplicateValidatorMetadata => "DUPLICATE_VALIDATOR_METADATA",
                Self::MissingProofOfPossession => "MISSING_PROOF_OF_POSSESSION",
                Self::InvalidProofOfPossession => "INVALID_PROOF_OF_POSSESSION",
                Self::ModelDecryptionKeyCommitmentMismatch => {
                    "MODEL_DECRYPTION_KEY_COMMITMENT_MISMATCH"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EXECUTION_ERROR_KIND_UNKNOWN" => Some(Self::Unknown),
                "INSUFFICIENT_GAS" => Some(Self::InsufficientGas),
                "INVALID_OWNERSHIP" => Some(Self::InvalidOwnership),
                "OBJECT_NOT_FOUND" => Some(Self::ObjectNotFound),
                "INVALID_OBJECT_TYPE" => Some(Self::InvalidObjectType),
                "INVALID_TRANSACTION_TYPE" => Some(Self::InvalidTransactionType),
                "INVALID_ARGUMENTS" => Some(Self::InvalidArguments),
                "DUPLICATE_VALIDATOR" => Some(Self::DuplicateValidator),
                "NOT_A_VALIDATOR" => Some(Self::NotAValidator),
                "VALIDATOR_ALREADY_REMOVED" => Some(Self::ValidatorAlreadyRemoved),
                "ADVANCED_TO_WRONG_EPOCH" => Some(Self::AdvancedToWrongEpoch),
                "MODEL_NOT_FOUND" => Some(Self::ModelNotFound),
                "NOT_MODEL_OWNER" => Some(Self::NotModelOwner),
                "MODEL_NOT_ACTIVE" => Some(Self::ModelNotActive),
                "INSUFFICIENT_COIN_BALANCE" => Some(Self::InsufficientCoinBalance),
                "COIN_BALANCE_OVERFLOW" => Some(Self::CoinBalanceOverflow),
                "VALIDATOR_NOT_FOUND" => Some(Self::ValidatorNotFound),
                "STAKING_POOL_NOT_FOUND" => Some(Self::StakingPoolNotFound),
                "CANNOT_REPORT_ONESELF" => Some(Self::CannotReportOneself),
                "REPORT_RECORD_NOT_FOUND" => Some(Self::ReportRecordNotFound),
                "INPUT_OBJECT_DELETED" => Some(Self::InputObjectDeleted),
                "CERTIFICATE_DENIED" => Some(Self::CertificateDenied),
                "SHARED_OBJECT_CONGESTION" => Some(Self::SharedObjectCongestion),
                "OTHER_ERROR" => Some(Self::OtherError),
                "MODEL_NOT_PENDING" => Some(Self::ModelNotPending),
                "MODEL_ALREADY_INACTIVE" => Some(Self::ModelAlreadyInactive),
                "MODEL_REVEAL_EPOCH_MISMATCH" => Some(Self::ModelRevealEpochMismatch),
                "MODEL_EMBEDDING_COMMITMENT_MISMATCH" => {
                    Some(Self::ModelEmbeddingCommitmentMismatch)
                }
                "MODEL_NO_PENDING_UPDATE" => Some(Self::ModelNoPendingUpdate),
                "MODEL_ARCHITECTURE_VERSION_MISMATCH" => {
                    Some(Self::ModelArchitectureVersionMismatch)
                }
                "MODEL_COMMISSION_RATE_TOO_HIGH" => {
                    Some(Self::ModelCommissionRateTooHigh)
                }
                "MODEL_MIN_STAKE_NOT_MET" => Some(Self::ModelMinStakeNotMet),
                "NO_ACTIVE_MODELS" => Some(Self::NoActiveModels),
                "TARGET_NOT_FOUND" => Some(Self::TargetNotFound),
                "TARGET_NOT_OPEN" => Some(Self::TargetNotOpen),
                "TARGET_EXPIRED" => Some(Self::TargetExpired),
                "TARGET_NOT_FILLED" => Some(Self::TargetNotFilled),
                "CHALLENGE_WINDOW_OPEN" => Some(Self::ChallengeWindowOpen),
                "TARGET_ALREADY_CLAIMED" => Some(Self::TargetAlreadyClaimed),
                "MODEL_NOT_IN_TARGET" => Some(Self::ModelNotInTarget),
                "EMBEDDING_DIMENSION_MISMATCH" => Some(Self::EmbeddingDimensionMismatch),
                "DISTANCE_EXCEEDS_THRESHOLD" => Some(Self::DistanceExceedsThreshold),
                "INSUFFICIENT_BOND" => Some(Self::InsufficientBond),
                "INSUFFICIENT_EMISSION_BALANCE" => {
                    Some(Self::InsufficientEmissionBalance)
                }
                "CHALLENGE_WINDOW_CLOSED" => Some(Self::ChallengeWindowClosed),
                "INSUFFICIENT_CHALLENGER_BOND" => Some(Self::InsufficientChallengerBond),
                "CHALLENGE_NOT_FOUND" => Some(Self::ChallengeNotFound),
                "CHALLENGE_NOT_PENDING" => Some(Self::ChallengeNotPending),
                "CHALLENGE_EXPIRED" => Some(Self::ChallengeExpired),
                "INVALID_CHALLENGE_RESULT" => Some(Self::InvalidChallengeResult),
                "INVALID_CHALLENGE_QUORUM" => Some(Self::InvalidChallengeQuorum),
                "DATA_EXCEEDS_MAX_SIZE" => Some(Self::DataExceedsMaxSize),
                "CHALLENGE_ALREADY_EXISTS" => Some(Self::ChallengeAlreadyExists),
                "DUPLICATE_VALIDATOR_METADATA" => Some(Self::DuplicateValidatorMetadata),
                "MISSING_PROOF_OF_POSSESSION" => Some(Self::MissingProofOfPossession),
                "INVALID_PROOF_OF_POSSESSION" => Some(Self::InvalidProofOfPossession),
                "MODEL_DECRYPTION_KEY_COMMITMENT_MISMATCH" => {
                    Some(Self::ModelDecryptionKeyCommitmentMismatch)
                }
                _ => None,
            }
        }
    }
    #[non_exhaustive]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ErrorDetails {
        #[prost(string, tag = "3")]
        ObjectId(::prost::alloc::string::String),
        #[prost(string, tag = "4")]
        OtherError(::prost::alloc::string::String),
    }
}
#[non_exhaustive]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetServiceInfoRequest {}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetServiceInfoResponse {
    /// The chain identifier of the chain that this node is on.
    ///
    /// The chain identifier is the digest of the genesis checkpoint, the
    /// checkpoint with sequence number 0.
    #[prost(string, optional, tag = "1")]
    pub chain_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Human-readable name of the chain that this node is on.
    ///
    /// This is intended to be a human-readable name like `mainnet`, `testnet`, and so on.
    #[prost(string, optional, tag = "2")]
    pub chain: ::core::option::Option<::prost::alloc::string::String>,
    /// Current epoch of the node based on its highest executed checkpoint.
    #[prost(uint64, optional, tag = "3")]
    pub epoch: ::core::option::Option<u64>,
    /// Checkpoint height of the most recently executed checkpoint.
    #[prost(uint64, optional, tag = "4")]
    pub checkpoint_height: ::core::option::Option<u64>,
    /// Unix timestamp of the most recently executed checkpoint.
    #[prost(message, optional, tag = "5")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// The lowest checkpoint for which checkpoints and transaction data are available.
    #[prost(uint64, optional, tag = "6")]
    pub lowest_available_checkpoint: ::core::option::Option<u64>,
    /// The lowest checkpoint for which object data is available.
    #[prost(uint64, optional, tag = "7")]
    pub lowest_available_checkpoint_objects: ::core::option::Option<u64>,
    /// Software version of the service. Similar to the `server` http header.
    #[prost(string, optional, tag = "8")]
    pub server: ::core::option::Option<::prost::alloc::string::String>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetObjectRequest {
    /// Required. The `ObjectId` of the requested object.
    #[prost(string, optional, tag = "1")]
    pub object_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Request a specific version of the object.
    /// If no version is specified, and the object is live, then the latest
    /// version of the object is returned.
    #[prost(uint64, optional, tag = "2")]
    pub version: ::core::option::Option<u64>,
    /// Mask specifying which fields to read.
    /// If no mask is specified, defaults to `object_id,version,digest`.
    #[prost(message, optional, tag = "3")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetObjectResponse {
    #[prost(message, optional, tag = "1")]
    pub object: ::core::option::Option<Object>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchGetObjectsRequest {
    #[prost(message, repeated, tag = "1")]
    pub requests: ::prost::alloc::vec::Vec<GetObjectRequest>,
    /// Mask specifying which fields to read.
    /// If no mask is specified, defaults to `object_id,version,digest`.
    #[prost(message, optional, tag = "2")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchGetObjectsResponse {
    #[prost(message, repeated, tag = "1")]
    pub objects: ::prost::alloc::vec::Vec<GetObjectResult>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetObjectResult {
    #[prost(oneof = "get_object_result::Result", tags = "1, 2")]
    pub result: ::core::option::Option<get_object_result::Result>,
}
/// Nested message and enum types in `GetObjectResult`.
pub mod get_object_result {
    #[non_exhaustive]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(message, tag = "1")]
        Object(super::Object),
        #[prost(message, tag = "2")]
        Error(crate::proto::google::rpc::Status),
    }
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTransactionRequest {
    /// Required. The digest of the requested transaction.
    #[prost(string, optional, tag = "1")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Mask specifying which fields to read.
    /// If no mask is specified, defaults to `digest`.
    #[prost(message, optional, tag = "2")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTransactionResponse {
    #[prost(message, optional, tag = "1")]
    pub transaction: ::core::option::Option<ExecutedTransaction>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchGetTransactionsRequest {
    /// Required. The digests of the requested transactions.
    #[prost(string, repeated, tag = "1")]
    pub digests: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Mask specifying which fields to read.
    /// If no mask is specified, defaults to `digest`.
    #[prost(message, optional, tag = "2")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchGetTransactionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub transactions: ::prost::alloc::vec::Vec<GetTransactionResult>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTransactionResult {
    #[prost(oneof = "get_transaction_result::Result", tags = "1, 2")]
    pub result: ::core::option::Option<get_transaction_result::Result>,
}
/// Nested message and enum types in `GetTransactionResult`.
pub mod get_transaction_result {
    #[non_exhaustive]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(message, tag = "1")]
        Transaction(super::ExecutedTransaction),
        #[prost(message, tag = "2")]
        Error(crate::proto::google::rpc::Status),
    }
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCheckpointRequest {
    /// Mask specifying which fields to read.
    /// If no mask is specified, defaults to `sequence_number,digest`.
    #[prost(message, optional, tag = "3")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// If neither is provided, return the latest
    #[prost(oneof = "get_checkpoint_request::CheckpointId", tags = "1, 2")]
    pub checkpoint_id: ::core::option::Option<get_checkpoint_request::CheckpointId>,
}
/// Nested message and enum types in `GetCheckpointRequest`.
pub mod get_checkpoint_request {
    /// If neither is provided, return the latest
    #[non_exhaustive]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum CheckpointId {
        /// The sequence number of the requested checkpoint.
        #[prost(uint64, tag = "1")]
        SequenceNumber(u64),
        /// The digest of the requested checkpoint.
        #[prost(string, tag = "2")]
        Digest(::prost::alloc::string::String),
    }
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCheckpointResponse {
    #[prost(message, optional, tag = "1")]
    pub checkpoint: ::core::option::Option<Checkpoint>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEpochRequest {
    /// The requested epoch.
    /// If no epoch is provided the current epoch will be returned.
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    /// Mask specifying which fields to read.
    /// If no mask is specified, defaults to `epoch`.
    #[prost(message, optional, tag = "2")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEpochResponse {
    #[prost(message, optional, tag = "1")]
    pub epoch: ::core::option::Option<Epoch>,
}
/// Generated client implementations.
pub mod ledger_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct LedgerServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl LedgerServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> LedgerServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> LedgerServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            LedgerServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Query the service for general information about its current state.
        pub async fn get_service_info(
            &mut self,
            request: impl tonic::IntoRequest<super::GetServiceInfoRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetServiceInfoResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/soma.rpc.LedgerService/GetServiceInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("soma.rpc.LedgerService", "GetServiceInfo"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_object(
            &mut self,
            request: impl tonic::IntoRequest<super::GetObjectRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetObjectResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/soma.rpc.LedgerService/GetObject",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("soma.rpc.LedgerService", "GetObject"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn batch_get_objects(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchGetObjectsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchGetObjectsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/soma.rpc.LedgerService/BatchGetObjects",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("soma.rpc.LedgerService", "BatchGetObjects"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_transaction(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTransactionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetTransactionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/soma.rpc.LedgerService/GetTransaction",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("soma.rpc.LedgerService", "GetTransaction"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn batch_get_transactions(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchGetTransactionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchGetTransactionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/soma.rpc.LedgerService/BatchGetTransactions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("soma.rpc.LedgerService", "BatchGetTransactions"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_checkpoint(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCheckpointRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetCheckpointResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/soma.rpc.LedgerService/GetCheckpoint",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("soma.rpc.LedgerService", "GetCheckpoint"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_epoch(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEpochRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetEpochResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/soma.rpc.LedgerService/GetEpoch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("soma.rpc.LedgerService", "GetEpoch"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod ledger_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with LedgerServiceServer.
    #[async_trait]
    pub trait LedgerService: std::marker::Send + std::marker::Sync + 'static {
        /// Query the service for general information about its current state.
        async fn get_service_info(
            &self,
            request: tonic::Request<super::GetServiceInfoRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetServiceInfoResponse>,
            tonic::Status,
        >;
        async fn get_object(
            &self,
            request: tonic::Request<super::GetObjectRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetObjectResponse>,
            tonic::Status,
        >;
        async fn batch_get_objects(
            &self,
            request: tonic::Request<super::BatchGetObjectsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchGetObjectsResponse>,
            tonic::Status,
        >;
        async fn get_transaction(
            &self,
            request: tonic::Request<super::GetTransactionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetTransactionResponse>,
            tonic::Status,
        >;
        async fn batch_get_transactions(
            &self,
            request: tonic::Request<super::BatchGetTransactionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchGetTransactionsResponse>,
            tonic::Status,
        >;
        async fn get_checkpoint(
            &self,
            request: tonic::Request<super::GetCheckpointRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetCheckpointResponse>,
            tonic::Status,
        >;
        async fn get_epoch(
            &self,
            request: tonic::Request<super::GetEpochRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetEpochResponse>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct LedgerServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> LedgerServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for LedgerServiceServer<T>
    where
        T: LedgerService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/soma.rpc.LedgerService/GetServiceInfo" => {
                    #[allow(non_camel_case_types)]
                    struct GetServiceInfoSvc<T: LedgerService>(pub Arc<T>);
                    impl<
                        T: LedgerService,
                    > tonic::server::UnaryService<super::GetServiceInfoRequest>
                    for GetServiceInfoSvc<T> {
                        type Response = super::GetServiceInfoResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetServiceInfoRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LedgerService>::get_service_info(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetServiceInfoSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/soma.rpc.LedgerService/GetObject" => {
                    #[allow(non_camel_case_types)]
                    struct GetObjectSvc<T: LedgerService>(pub Arc<T>);
                    impl<
                        T: LedgerService,
                    > tonic::server::UnaryService<super::GetObjectRequest>
                    for GetObjectSvc<T> {
                        type Response = super::GetObjectResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetObjectRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LedgerService>::get_object(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetObjectSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/soma.rpc.LedgerService/BatchGetObjects" => {
                    #[allow(non_camel_case_types)]
                    struct BatchGetObjectsSvc<T: LedgerService>(pub Arc<T>);
                    impl<
                        T: LedgerService,
                    > tonic::server::UnaryService<super::BatchGetObjectsRequest>
                    for BatchGetObjectsSvc<T> {
                        type Response = super::BatchGetObjectsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::BatchGetObjectsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LedgerService>::batch_get_objects(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = BatchGetObjectsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/soma.rpc.LedgerService/GetTransaction" => {
                    #[allow(non_camel_case_types)]
                    struct GetTransactionSvc<T: LedgerService>(pub Arc<T>);
                    impl<
                        T: LedgerService,
                    > tonic::server::UnaryService<super::GetTransactionRequest>
                    for GetTransactionSvc<T> {
                        type Response = super::GetTransactionResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetTransactionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LedgerService>::get_transaction(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetTransactionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/soma.rpc.LedgerService/BatchGetTransactions" => {
                    #[allow(non_camel_case_types)]
                    struct BatchGetTransactionsSvc<T: LedgerService>(pub Arc<T>);
                    impl<
                        T: LedgerService,
                    > tonic::server::UnaryService<super::BatchGetTransactionsRequest>
                    for BatchGetTransactionsSvc<T> {
                        type Response = super::BatchGetTransactionsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::BatchGetTransactionsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LedgerService>::batch_get_transactions(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = BatchGetTransactionsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/soma.rpc.LedgerService/GetCheckpoint" => {
                    #[allow(non_camel_case_types)]
                    struct GetCheckpointSvc<T: LedgerService>(pub Arc<T>);
                    impl<
                        T: LedgerService,
                    > tonic::server::UnaryService<super::GetCheckpointRequest>
                    for GetCheckpointSvc<T> {
                        type Response = super::GetCheckpointResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetCheckpointRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LedgerService>::get_checkpoint(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetCheckpointSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/soma.rpc.LedgerService/GetEpoch" => {
                    #[allow(non_camel_case_types)]
                    struct GetEpochSvc<T: LedgerService>(pub Arc<T>);
                    impl<
                        T: LedgerService,
                    > tonic::server::UnaryService<super::GetEpochRequest>
                    for GetEpochSvc<T> {
                        type Response = super::GetEpochResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetEpochRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LedgerService>::get_epoch(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetEpochSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(
                            tonic::body::Body::default(),
                        );
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for LedgerServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "soma.rpc.LedgerService";
    impl<T> tonic::server::NamedService for LedgerServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// An object on the Sui blockchain.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Object {
    /// `ObjectId` for this object.
    #[prost(string, optional, tag = "1")]
    pub object_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Version of the object.
    #[prost(uint64, optional, tag = "2")]
    pub version: ::core::option::Option<u64>,
    /// The digest of this Object.
    #[prost(string, optional, tag = "3")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Owner of the object.
    #[prost(message, optional, tag = "4")]
    pub owner: ::core::option::Option<Owner>,
    /// The type of this object.
    #[prost(string, optional, tag = "5")]
    pub object_type: ::core::option::Option<::prost::alloc::string::String>,
    /// BCS bytes of a struct value.
    #[prost(bytes = "bytes", optional, tag = "6")]
    pub contents: ::core::option::Option<::prost::bytes::Bytes>,
    /// The digest of the transaction that created or last mutated this object
    #[prost(string, optional, tag = "7")]
    pub previous_transaction: ::core::option::Option<::prost::alloc::string::String>,
}
/// Set of Objects
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectSet {
    /// Objects are sorted by the key `(object_id, version)`.
    #[prost(message, repeated, tag = "1")]
    pub objects: ::prost::alloc::vec::Vec<Object>,
}
/// Reference to an object.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectReference {
    /// The object id of this object.
    #[prost(string, optional, tag = "1")]
    pub object_id: ::core::option::Option<::prost::alloc::string::String>,
    /// The version of this object.
    #[prost(uint64, optional, tag = "2")]
    pub version: ::core::option::Option<u64>,
    /// The digest of this object.
    #[prost(string, optional, tag = "3")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
}
/// Enum of different types of ownership for an object.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Owner {
    #[prost(enumeration = "owner::OwnerKind", optional, tag = "1")]
    pub kind: ::core::option::Option<i32>,
    /// Address or ObjectId of the owner
    #[prost(string, optional, tag = "2")]
    pub address: ::core::option::Option<::prost::alloc::string::String>,
    /// The `initial_shared_version` if kind is `SHARED`.
    #[prost(uint64, optional, tag = "3")]
    pub version: ::core::option::Option<u64>,
}
/// Nested message and enum types in `Owner`.
pub mod owner {
    #[non_exhaustive]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OwnerKind {
        Unknown = 0,
        Address = 1,
        Shared = 2,
        Immutable = 3,
    }
    impl OwnerKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "OWNER_KIND_UNKNOWN",
                Self::Address => "ADDRESS",
                Self::Shared => "SHARED",
                Self::Immutable => "IMMUTABLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OWNER_KIND_UNKNOWN" => Some(Self::Unknown),
                "ADDRESS" => Some(Self::Address),
                "SHARED" => Some(Self::Shared),
                "IMMUTABLE" => Some(Self::Immutable),
                _ => None,
            }
        }
    }
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtocolConfig {
    #[prost(uint64, optional, tag = "1")]
    pub protocol_version: ::core::option::Option<u64>,
    #[prost(btree_map = "string, bool", tag = "2")]
    pub feature_flags: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        bool,
    >,
    #[prost(btree_map = "string, string", tag = "3")]
    pub attributes: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// A signature from a user.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserSignature {
    /// The signature scheme of this signature.
    #[prost(enumeration = "SignatureScheme", optional, tag = "1")]
    pub scheme: ::core::option::Option<i32>,
    #[prost(oneof = "user_signature::Signature", tags = "2, 3")]
    pub signature: ::core::option::Option<user_signature::Signature>,
}
/// Nested message and enum types in `UserSignature`.
pub mod user_signature {
    #[non_exhaustive]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Signature {
        /// Simple signature if scheme is ed25519.
        #[prost(message, tag = "2")]
        Simple(super::SimpleSignature),
        /// The multisig aggregated signature if scheme is `MULTISIG`.
        #[prost(message, tag = "3")]
        Multisig(super::MultisigAggregatedSignature),
    }
}
/// Either an ed25519, secp256k1 or secp256r1 signature
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SimpleSignature {
    /// The signature scheme of this signature.
    #[prost(enumeration = "SignatureScheme", optional, tag = "1")]
    pub scheme: ::core::option::Option<i32>,
    /// Signature bytes
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub signature: ::core::option::Option<::prost::bytes::Bytes>,
    /// Public key bytes
    #[prost(bytes = "bytes", optional, tag = "3")]
    pub public_key: ::core::option::Option<::prost::bytes::Bytes>,
}
/// Set of valid public keys for multisig committee members.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultisigMemberPublicKey {
    /// The signature scheme of this public key.
    #[prost(enumeration = "SignatureScheme", optional, tag = "1")]
    pub scheme: ::core::option::Option<i32>,
    /// Public key bytes if scheme is ed25519.
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub public_key: ::core::option::Option<::prost::bytes::Bytes>,
}
/// A member in a multisig committee.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultisigMember {
    /// The public key of the committee member.
    #[prost(message, optional, tag = "1")]
    pub public_key: ::core::option::Option<MultisigMemberPublicKey>,
    /// The weight of this member's signature.
    #[prost(uint32, optional, tag = "2")]
    pub weight: ::core::option::Option<u32>,
}
/// A multisig committee.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultisigCommittee {
    /// A list of committee members and their corresponding weight.
    #[prost(message, repeated, tag = "1")]
    pub members: ::prost::alloc::vec::Vec<MultisigMember>,
    /// The threshold of signatures needed to validate a signature from
    /// this committee.
    #[prost(uint32, optional, tag = "2")]
    pub threshold: ::core::option::Option<u32>,
}
/// Aggregated signature from members of a multisig committee.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultisigAggregatedSignature {
    /// The plain signatures encoded with signature scheme.
    ///
    /// The signatures must be in the same order as they are listed in the committee.
    #[prost(message, repeated, tag = "1")]
    pub signatures: ::prost::alloc::vec::Vec<MultisigMemberSignature>,
    /// Bitmap indicating which committee members contributed to the
    /// signature.
    #[prost(uint32, optional, tag = "2")]
    pub bitmap: ::core::option::Option<u32>,
    /// The committee to use to validate this signature.
    #[prost(message, optional, tag = "3")]
    pub committee: ::core::option::Option<MultisigCommittee>,
}
/// A signature from a member of a multisig committee.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultisigMemberSignature {
    /// The signature scheme of this signature.
    #[prost(enumeration = "SignatureScheme", optional, tag = "1")]
    pub scheme: ::core::option::Option<i32>,
    /// Signature bytes if scheme is ed25519.
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub signature: ::core::option::Option<::prost::bytes::Bytes>,
}
/// The validator set for a particular epoch.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatorCommittee {
    /// The epoch where this committee governs.
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    /// The committee members.
    #[prost(message, repeated, tag = "2")]
    pub members: ::prost::alloc::vec::Vec<ValidatorCommitteeMember>,
}
/// A member of a validator committee with full authority information.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatorCommitteeMember {
    /// The BLS12381 public key bytes (becomes AuthorityName)
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub authority_key: ::core::option::Option<::prost::bytes::Bytes>,
    /// Voting weight this validator possesses.
    #[prost(uint64, optional, tag = "2")]
    pub weight: ::core::option::Option<u64>,
    /// Network metadata for this validator
    #[prost(message, optional, tag = "3")]
    pub network_metadata: ::core::option::Option<ValidatorNetworkMetadata>,
}
/// Network and protocol information for a validator
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatorNetworkMetadata {
    /// Multiaddr for consensus communication (as string)
    #[prost(string, optional, tag = "1")]
    pub consensus_address: ::core::option::Option<::prost::alloc::string::String>,
    /// Hostname for metrics and logging
    #[prost(string, optional, tag = "2")]
    pub hostname: ::core::option::Option<::prost::alloc::string::String>,
    /// Ed25519 protocol public key bytes
    #[prost(bytes = "bytes", optional, tag = "3")]
    pub protocol_key: ::core::option::Option<::prost::bytes::Bytes>,
    /// Ed25519 network public key bytes
    #[prost(bytes = "bytes", optional, tag = "4")]
    pub network_key: ::core::option::Option<::prost::bytes::Bytes>,
}
/// / An aggregated signature from multiple validators.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatorAggregatedSignature {
    /// The epoch when this signature was produced.
    ///
    /// This can be used to lookup the `ValidatorCommittee` from this epoch
    /// to verify this signature.
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    /// The 48-byte Bls12381 aggregated signature.
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub signature: ::core::option::Option<::prost::bytes::Bytes>,
    /// Bitmap indicating which members of the committee contributed to
    /// this signature.
    #[prost(uint32, repeated, tag = "3")]
    pub bitmap: ::prost::alloc::vec::Vec<u32>,
}
/// Flag use to disambiguate the signature schemes supported by SOMA.
///
/// Note: the enum values defined by this proto message exactly match their
/// expected BCS serialized values when serialized as a u8.
#[non_exhaustive]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SignatureScheme {
    Ed25519 = 0,
    Bls12381 = 1,
    Multisig = 2,
}
impl SignatureScheme {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Ed25519 => "ED25519",
            Self::Bls12381 => "BLS12381",
            Self::Multisig => "MULTISIG",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ED25519" => Some(Self::Ed25519),
            "BLS12381" => Some(Self::Bls12381),
            "MULTISIG" => Some(Self::Multisig),
            _ => None,
        }
    }
}
/// Request message for `LiveDataService.GetBalance`.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBalanceRequest {
    /// Required. The owner's Sui address.
    #[prost(string, optional, tag = "1")]
    pub owner: ::core::option::Option<::prost::alloc::string::String>,
}
/// Response message for `LiveDataService.GetBalance`.
/// Return the total coin balance for coin, owned by the address owner.
#[non_exhaustive]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetBalanceResponse {
    #[prost(uint64, optional, tag = "1")]
    pub balance: ::core::option::Option<u64>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListOwnedObjectsRequest {
    /// Required. The address of the account that owns the objects.
    #[prost(string, optional, tag = "1")]
    pub owner: ::core::option::Option<::prost::alloc::string::String>,
    /// The maximum number of entries return. The service may return fewer than this value.
    /// If unspecified, at most `50` entries will be returned.
    /// The maximum value is `1000`; values above `1000` will be coerced to `1000`.
    #[prost(uint32, optional, tag = "2")]
    pub page_size: ::core::option::Option<u32>,
    /// A page token, received from a previous `ListOwnedObjects` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListOwnedObjects` must
    /// match the call that provided the page token.
    #[prost(bytes = "bytes", optional, tag = "3")]
    pub page_token: ::core::option::Option<::prost::bytes::Bytes>,
    /// Mask specifying which fields to read.
    /// If no mask is specified, defaults to `object_id,version,object_type`.
    #[prost(message, optional, tag = "4")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Optional type filter to limit the types of objects listed.
    ///
    /// Providing an object type with no type params will return objects of that
    /// type with any type parameter.
    #[prost(string, optional, tag = "5")]
    pub object_type: ::core::option::Option<::prost::alloc::string::String>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListOwnedObjectsResponse {
    /// Page of dynamic fields owned by the specified parent.
    #[prost(message, repeated, tag = "1")]
    pub objects: ::prost::alloc::vec::Vec<Object>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub next_page_token: ::core::option::Option<::prost::bytes::Bytes>,
}
/// Request message for `StateService.GetTarget`.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTargetRequest {
    /// Required. The target ID (ObjectID hex string).
    #[prost(string, optional, tag = "1")]
    pub target_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Mask specifying which fields to read.
    /// If no mask is specified, all fields are returned.
    #[prost(message, optional, tag = "2")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Response message for `StateService.GetTarget`.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTargetResponse {
    #[prost(message, optional, tag = "1")]
    pub target: ::core::option::Option<Target>,
}
/// Request message for `StateService.ListTargets`.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTargetsRequest {
    /// Optional status filter: "open", "filled", or "claimed".
    /// If not specified, returns targets of all statuses.
    #[prost(string, optional, tag = "1")]
    pub status_filter: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional epoch filter. If specified, only returns targets with
    /// generation_epoch equal to this value.
    #[prost(uint64, optional, tag = "2")]
    pub epoch_filter: ::core::option::Option<u64>,
    /// The maximum number of entries to return. The service may return fewer.
    /// If unspecified, at most `50` entries will be returned.
    /// The maximum value is `1000`; values above `1000` will be coerced to `1000`.
    #[prost(uint32, optional, tag = "3")]
    pub page_size: ::core::option::Option<u32>,
    /// A page token, received from a previous `ListTargets` call.
    /// Provide this to retrieve the subsequent page.
    #[prost(bytes = "bytes", optional, tag = "4")]
    pub page_token: ::core::option::Option<::prost::bytes::Bytes>,
    /// Mask specifying which fields to read on each target.
    /// If no mask is specified, all fields are returned.
    #[prost(message, optional, tag = "5")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Response message for `StateService.ListTargets`.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTargetsResponse {
    /// Page of targets matching the filters.
    #[prost(message, repeated, tag = "1")]
    pub targets: ::prost::alloc::vec::Vec<Target>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub next_page_token: ::core::option::Option<::prost::bytes::Bytes>,
}
/// Request message for `StateService.GetChallenge`.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetChallengeRequest {
    /// Required. The challenge ID (ObjectID hex string).
    #[prost(string, optional, tag = "1")]
    pub challenge_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Mask specifying which fields to read.
    /// If no mask is specified, all fields are returned.
    #[prost(message, optional, tag = "2")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Response message for `StateService.GetChallenge`.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetChallengeResponse {
    #[prost(message, optional, tag = "1")]
    pub challenge: ::core::option::Option<Challenge>,
}
/// Request message for `StateService.ListChallenges`.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListChallengesRequest {
    /// Optional target ID filter. If specified, only returns challenges for this target.
    #[prost(string, optional, tag = "1")]
    pub target_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional status filter: "pending" or "resolved".
    /// If not specified, returns challenges of all statuses.
    #[prost(string, optional, tag = "2")]
    pub status_filter: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional epoch filter. If specified, only returns challenges with
    /// challenge_epoch equal to this value.
    #[prost(uint64, optional, tag = "3")]
    pub epoch_filter: ::core::option::Option<u64>,
    /// The maximum number of entries to return. The service may return fewer.
    /// If unspecified, at most `50` entries will be returned.
    /// The maximum value is `1000`; values above `1000` will be coerced to `1000`.
    #[prost(uint32, optional, tag = "4")]
    pub page_size: ::core::option::Option<u32>,
    /// A page token, received from a previous `ListChallenges` call.
    /// Provide this to retrieve the subsequent page.
    #[prost(bytes = "bytes", optional, tag = "5")]
    pub page_token: ::core::option::Option<::prost::bytes::Bytes>,
    /// Mask specifying which fields to read on each challenge.
    /// If no mask is specified, all fields are returned.
    #[prost(message, optional, tag = "6")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Response message for `StateService.ListChallenges`.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListChallengesResponse {
    /// Page of challenges matching the filters.
    #[prost(message, repeated, tag = "1")]
    pub challenges: ::prost::alloc::vec::Vec<Challenge>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub next_page_token: ::core::option::Option<::prost::bytes::Bytes>,
}
/// Generated client implementations.
pub mod state_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct StateServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl StateServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> StateServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> StateServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            StateServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn list_owned_objects(
            &mut self,
            request: impl tonic::IntoRequest<super::ListOwnedObjectsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListOwnedObjectsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/soma.rpc.StateService/ListOwnedObjects",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("soma.rpc.StateService", "ListOwnedObjects"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_balance(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBalanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetBalanceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/soma.rpc.StateService/GetBalance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("soma.rpc.StateService", "GetBalance"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_target(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTargetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetTargetResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/soma.rpc.StateService/GetTarget",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("soma.rpc.StateService", "GetTarget"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn list_targets(
            &mut self,
            request: impl tonic::IntoRequest<super::ListTargetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListTargetsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/soma.rpc.StateService/ListTargets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("soma.rpc.StateService", "ListTargets"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_challenge(
            &mut self,
            request: impl tonic::IntoRequest<super::GetChallengeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetChallengeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/soma.rpc.StateService/GetChallenge",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("soma.rpc.StateService", "GetChallenge"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn list_challenges(
            &mut self,
            request: impl tonic::IntoRequest<super::ListChallengesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListChallengesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/soma.rpc.StateService/ListChallenges",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("soma.rpc.StateService", "ListChallenges"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod state_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with StateServiceServer.
    #[async_trait]
    pub trait StateService: std::marker::Send + std::marker::Sync + 'static {
        async fn list_owned_objects(
            &self,
            request: tonic::Request<super::ListOwnedObjectsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListOwnedObjectsResponse>,
            tonic::Status,
        >;
        async fn get_balance(
            &self,
            request: tonic::Request<super::GetBalanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetBalanceResponse>,
            tonic::Status,
        >;
        async fn get_target(
            &self,
            request: tonic::Request<super::GetTargetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetTargetResponse>,
            tonic::Status,
        >;
        async fn list_targets(
            &self,
            request: tonic::Request<super::ListTargetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListTargetsResponse>,
            tonic::Status,
        >;
        async fn get_challenge(
            &self,
            request: tonic::Request<super::GetChallengeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetChallengeResponse>,
            tonic::Status,
        >;
        async fn list_challenges(
            &self,
            request: tonic::Request<super::ListChallengesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListChallengesResponse>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct StateServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> StateServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for StateServiceServer<T>
    where
        T: StateService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/soma.rpc.StateService/ListOwnedObjects" => {
                    #[allow(non_camel_case_types)]
                    struct ListOwnedObjectsSvc<T: StateService>(pub Arc<T>);
                    impl<
                        T: StateService,
                    > tonic::server::UnaryService<super::ListOwnedObjectsRequest>
                    for ListOwnedObjectsSvc<T> {
                        type Response = super::ListOwnedObjectsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListOwnedObjectsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StateService>::list_owned_objects(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListOwnedObjectsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/soma.rpc.StateService/GetBalance" => {
                    #[allow(non_camel_case_types)]
                    struct GetBalanceSvc<T: StateService>(pub Arc<T>);
                    impl<
                        T: StateService,
                    > tonic::server::UnaryService<super::GetBalanceRequest>
                    for GetBalanceSvc<T> {
                        type Response = super::GetBalanceResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetBalanceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StateService>::get_balance(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetBalanceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/soma.rpc.StateService/GetTarget" => {
                    #[allow(non_camel_case_types)]
                    struct GetTargetSvc<T: StateService>(pub Arc<T>);
                    impl<
                        T: StateService,
                    > tonic::server::UnaryService<super::GetTargetRequest>
                    for GetTargetSvc<T> {
                        type Response = super::GetTargetResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetTargetRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StateService>::get_target(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetTargetSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/soma.rpc.StateService/ListTargets" => {
                    #[allow(non_camel_case_types)]
                    struct ListTargetsSvc<T: StateService>(pub Arc<T>);
                    impl<
                        T: StateService,
                    > tonic::server::UnaryService<super::ListTargetsRequest>
                    for ListTargetsSvc<T> {
                        type Response = super::ListTargetsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListTargetsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StateService>::list_targets(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListTargetsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/soma.rpc.StateService/GetChallenge" => {
                    #[allow(non_camel_case_types)]
                    struct GetChallengeSvc<T: StateService>(pub Arc<T>);
                    impl<
                        T: StateService,
                    > tonic::server::UnaryService<super::GetChallengeRequest>
                    for GetChallengeSvc<T> {
                        type Response = super::GetChallengeResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetChallengeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StateService>::get_challenge(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetChallengeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/soma.rpc.StateService/ListChallenges" => {
                    #[allow(non_camel_case_types)]
                    struct ListChallengesSvc<T: StateService>(pub Arc<T>);
                    impl<
                        T: StateService,
                    > tonic::server::UnaryService<super::ListChallengesRequest>
                    for ListChallengesSvc<T> {
                        type Response = super::ListChallengesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListChallengesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StateService>::list_challenges(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListChallengesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(
                            tonic::body::Body::default(),
                        );
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for StateServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "soma.rpc.StateService";
    impl<T> tonic::server::NamedService for StateServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for SubscriptionService.SubscribeCheckpoints
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeCheckpointsRequest {
    /// Optional. Mask for specifying which parts of the
    /// SubscribeCheckpointsResponse should be returned.
    #[prost(message, optional, tag = "1")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Response message for SubscriptionService.SubscribeCheckpoints
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeCheckpointsResponse {
    /// Required. The checkpoint sequence number and value of the current cursor
    /// into the checkpoint stream
    #[prost(uint64, optional, tag = "1")]
    pub cursor: ::core::option::Option<u64>,
    /// The requested data for this checkpoint
    #[prost(message, optional, tag = "2")]
    pub checkpoint: ::core::option::Option<Checkpoint>,
}
/// Generated client implementations.
pub mod subscription_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct SubscriptionServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SubscriptionServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SubscriptionServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SubscriptionServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SubscriptionServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Subscribe to the stream of checkpoints.
        ///
        /// This API provides a subscription to the checkpoint stream for the Sui
        /// blockchain. When a subscription is initialized the stream will begin with
        /// the latest executed checkpoint as seen by the server. Responses are
        /// guaranteed to return checkpoints in-order and without gaps. This enables
        /// clients to know exactly the last checkpoint they have processed and in the
        /// event the subscription terminates (either by the client/server or by the
        /// connection breaking), clients will be able to reinitialize a subscription
        /// and then leverage other APIs in order to request data for the checkpoints
        /// they missed.
        pub async fn subscribe_checkpoints(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribeCheckpointsRequest>,
        ) -> std::result::Result<
            tonic::Response<
                tonic::codec::Streaming<super::SubscribeCheckpointsResponse>,
            >,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/soma.rpc.SubscriptionService/SubscribeCheckpoints",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "soma.rpc.SubscriptionService",
                        "SubscribeCheckpoints",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod subscription_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with SubscriptionServiceServer.
    #[async_trait]
    pub trait SubscriptionService: std::marker::Send + std::marker::Sync + 'static {
        /// Server streaming response type for the SubscribeCheckpoints method.
        type SubscribeCheckpointsStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<
                    super::SubscribeCheckpointsResponse,
                    tonic::Status,
                >,
            >
            + std::marker::Send
            + 'static;
        /// Subscribe to the stream of checkpoints.
        ///
        /// This API provides a subscription to the checkpoint stream for the Sui
        /// blockchain. When a subscription is initialized the stream will begin with
        /// the latest executed checkpoint as seen by the server. Responses are
        /// guaranteed to return checkpoints in-order and without gaps. This enables
        /// clients to know exactly the last checkpoint they have processed and in the
        /// event the subscription terminates (either by the client/server or by the
        /// connection breaking), clients will be able to reinitialize a subscription
        /// and then leverage other APIs in order to request data for the checkpoints
        /// they missed.
        async fn subscribe_checkpoints(
            &self,
            request: tonic::Request<super::SubscribeCheckpointsRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::SubscribeCheckpointsStream>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct SubscriptionServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> SubscriptionServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for SubscriptionServiceServer<T>
    where
        T: SubscriptionService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/soma.rpc.SubscriptionService/SubscribeCheckpoints" => {
                    #[allow(non_camel_case_types)]
                    struct SubscribeCheckpointsSvc<T: SubscriptionService>(pub Arc<T>);
                    impl<
                        T: SubscriptionService,
                    > tonic::server::ServerStreamingService<
                        super::SubscribeCheckpointsRequest,
                    > for SubscribeCheckpointsSvc<T> {
                        type Response = super::SubscribeCheckpointsResponse;
                        type ResponseStream = T::SubscribeCheckpointsStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SubscribeCheckpointsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SubscriptionService>::subscribe_checkpoints(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SubscribeCheckpointsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(
                            tonic::body::Body::default(),
                        );
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for SubscriptionServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "soma.rpc.SubscriptionService";
    impl<T> tonic::server::NamedService for SubscriptionServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SystemState {
    /// Core epoch information
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub epoch_start_timestamp_ms: ::core::option::Option<u64>,
    /// The protocol version
    #[prost(uint64, optional, tag = "3")]
    pub protocol_version: ::core::option::Option<u64>,
    /// System parameters
    #[prost(message, optional, tag = "4")]
    pub parameters: ::core::option::Option<SystemParameters>,
    /// Validator set
    #[prost(message, optional, tag = "5")]
    pub validators: ::core::option::Option<ValidatorSet>,
    /// Report records
    #[prost(btree_map = "string, message", tag = "6")]
    pub validator_report_records: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ReporterSet,
    >,
    /// Emission pool
    #[prost(message, optional, tag = "7")]
    pub emission_pool: ::core::option::Option<EmissionPool>,
    /// Target state (difficulty thresholds, EMAs, reward per target)
    #[prost(message, optional, tag = "12")]
    pub target_state: ::core::option::Option<TargetState>,
    /// Model registry
    #[prost(message, optional, tag = "11")]
    pub model_registry: ::core::option::Option<ModelRegistry>,
    /// Submission report records (target_id hex -> reporter addresses)
    #[prost(btree_map = "string, message", tag = "13")]
    pub submission_report_records: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ReporterSet,
    >,
    /// Safe mode fields
    #[prost(bool, optional, tag = "14")]
    pub safe_mode: ::core::option::Option<bool>,
    #[prost(uint64, optional, tag = "15")]
    pub safe_mode_accumulated_fees: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "16")]
    pub safe_mode_accumulated_emissions: ::core::option::Option<u64>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReporterSet {
    #[prost(string, repeated, tag = "1")]
    pub reporters: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[non_exhaustive]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SystemParameters {
    #[prost(uint64, optional, tag = "1")]
    pub epoch_duration_ms: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub validator_reward_allocation_bps: ::core::option::Option<u64>,
    /// Model parameters
    #[prost(uint64, optional, tag = "3")]
    pub model_min_stake: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "4")]
    pub model_architecture_version: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "5")]
    pub model_reveal_slash_rate_bps: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "6")]
    pub model_tally_slash_rate_bps: ::core::option::Option<u64>,
    /// Fee parameters
    #[prost(uint64, optional, tag = "7")]
    pub target_epoch_fee_collection: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "8")]
    pub base_fee: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "9")]
    pub write_object_fee: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "10")]
    pub value_fee_bps: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "11")]
    pub min_value_fee_bps: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "12")]
    pub max_value_fee_bps: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "13")]
    pub fee_adjustment_rate_bps: ::core::option::Option<u64>,
    /// Target/Submission parameters
    #[prost(uint64, optional, tag = "14")]
    pub target_models_per_target: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "15")]
    pub target_embedding_dim: ::core::option::Option<u64>,
    #[prost(float, optional, tag = "16")]
    pub target_initial_distance_threshold: ::core::option::Option<f32>,
    #[prost(uint64, optional, tag = "17")]
    pub target_reward_allocation_bps: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "18")]
    pub target_hits_per_epoch: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "19")]
    pub target_hits_ema_decay_bps: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "20")]
    pub target_difficulty_adjustment_rate_bps: ::core::option::Option<u64>,
    #[prost(float, optional, tag = "21")]
    pub target_max_distance_threshold: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "22")]
    pub target_min_distance_threshold: ::core::option::Option<f32>,
    #[prost(uint64, optional, tag = "23")]
    pub target_initial_targets_per_epoch: ::core::option::Option<u64>,
    /// Reward distribution parameters
    #[prost(uint64, optional, tag = "24")]
    pub target_submitter_reward_share_bps: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "25")]
    pub target_model_reward_share_bps: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "26")]
    pub target_claimer_incentive_bps: ::core::option::Option<u64>,
    /// Submission parameters
    #[prost(uint64, optional, tag = "27")]
    pub submission_bond_per_byte: ::core::option::Option<u64>,
    /// Challenge parameters
    ///
    /// challenge_distance_epsilon removed - using Burn's Tolerance::permissive() instead
    #[prost(uint64, optional, tag = "28")]
    pub challenger_bond_per_byte: ::core::option::Option<u64>,
    /// Data size limit
    #[prost(uint64, optional, tag = "30")]
    pub max_submission_data_size: ::core::option::Option<u64>,
}
#[non_exhaustive]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EmissionPool {
    #[prost(uint64, optional, tag = "1")]
    pub balance: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub emission_per_epoch: ::core::option::Option<u64>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatorSet {
    #[prost(uint64, optional, tag = "1")]
    pub total_stake: ::core::option::Option<u64>,
    #[prost(message, repeated, tag = "2")]
    pub validators: ::prost::alloc::vec::Vec<Validator>,
    #[prost(message, repeated, tag = "3")]
    pub pending_validators: ::prost::alloc::vec::Vec<Validator>,
    #[prost(uint32, repeated, tag = "4")]
    pub pending_removals: ::prost::alloc::vec::Vec<u32>,
    /// pool_id -> validator_address
    #[prost(btree_map = "string, string", tag = "5")]
    pub staking_pool_mappings: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// pool_id -> validator
    #[prost(btree_map = "string, message", tag = "6")]
    pub inactive_validators: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        Validator,
    >,
    /// address -> epochs_at_risk
    #[prost(btree_map = "string, uint64", tag = "7")]
    pub at_risk_validators: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        u64,
    >,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Validator {
    #[prost(string, optional, tag = "1")]
    pub soma_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub protocol_pubkey: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", optional, tag = "3")]
    pub network_pubkey: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", optional, tag = "4")]
    pub worker_pubkey: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(string, optional, tag = "5")]
    pub net_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "6")]
    pub p2p_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "7")]
    pub primary_address: ::core::option::Option<::prost::alloc::string::String>,
    /// HTTP proxy address for serving data/model downloads
    #[prost(string, optional, tag = "19")]
    pub proxy_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "8")]
    pub voting_power: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "9")]
    pub commission_rate: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "10")]
    pub next_epoch_stake: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "11")]
    pub next_epoch_commission_rate: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "12")]
    pub staking_pool: ::core::option::Option<StakingPool>,
    /// Next epoch metadata (only if set)
    #[prost(bytes = "bytes", optional, tag = "13")]
    pub next_epoch_protocol_pubkey: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", optional, tag = "14")]
    pub next_epoch_network_pubkey: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", optional, tag = "15")]
    pub next_epoch_worker_pubkey: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(string, optional, tag = "16")]
    pub next_epoch_net_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "17")]
    pub next_epoch_p2p_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "18")]
    pub next_epoch_primary_address: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    /// HTTP proxy address for next epoch
    #[prost(string, optional, tag = "20")]
    pub next_epoch_proxy_address: ::core::option::Option<::prost::alloc::string::String>,
    /// Proof of possession for the protocol key (BLS signature)
    #[prost(bytes = "bytes", optional, tag = "21")]
    pub proof_of_possession: ::core::option::Option<::prost::bytes::Bytes>,
    /// Next epoch proof of possession (when protocol key is being changed)
    #[prost(bytes = "bytes", optional, tag = "22")]
    pub next_epoch_proof_of_possession: ::core::option::Option<::prost::bytes::Bytes>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StakingPool {
    #[prost(string, optional, tag = "1")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "2")]
    pub activation_epoch: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub deactivation_epoch: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "4")]
    pub soma_balance: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "5")]
    pub rewards_pool: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "6")]
    pub pool_token_balance: ::core::option::Option<u64>,
    #[prost(btree_map = "uint64, message", tag = "7")]
    pub exchange_rates: ::prost::alloc::collections::BTreeMap<
        u64,
        PoolTokenExchangeRate,
    >,
    #[prost(uint64, optional, tag = "8")]
    pub pending_stake: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "9")]
    pub pending_total_soma_withdraw: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "10")]
    pub pending_pool_token_withdraw: ::core::option::Option<u64>,
}
#[non_exhaustive]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PoolTokenExchangeRate {
    #[prost(uint64, optional, tag = "1")]
    pub soma_amount: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub pool_token_amount: ::core::option::Option<u64>,
}
/// A registered model in the data submission system.
/// Status derived from fields (same pattern as validators):
///    Committed: decryption_key absent, staking_pool.deactivation_epoch absent
///    Active:    decryption_key present, staking_pool.deactivation_epoch absent
///    Inactive:  staking_pool.deactivation_epoch present
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Model {
    #[prost(string, optional, tag = "1")]
    pub owner: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "2")]
    pub architecture_version: ::core::option::Option<u64>,
    /// Manifest (URL + checksum + size), set at commit
    #[prost(message, optional, tag = "3")]
    pub manifest: ::core::option::Option<Manifest>,
    /// 32-byte digest
    #[prost(bytes = "bytes", optional, tag = "4")]
    pub weights_commitment: ::core::option::Option<::prost::bytes::Bytes>,
    /// 32-byte hash of BCS-serialized embedding
    #[prost(bytes = "bytes", optional, tag = "5")]
    pub embedding_commitment: ::core::option::Option<::prost::bytes::Bytes>,
    /// 32-byte hash of decryption key
    #[prost(bytes = "bytes", optional, tag = "6")]
    pub decryption_key_commitment: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(uint64, optional, tag = "7")]
    pub commit_epoch: ::core::option::Option<u64>,
    /// 32-byte AES-256 key (absent while committed)
    #[prost(bytes = "bytes", optional, tag = "8")]
    pub decryption_key: ::core::option::Option<::prost::bytes::Bytes>,
    /// Model embedding (absent while committed)
    #[prost(float, repeated, tag = "9")]
    pub embedding: ::prost::alloc::vec::Vec<f32>,
    #[prost(message, optional, tag = "10")]
    pub staking_pool: ::core::option::Option<StakingPool>,
    #[prost(uint64, optional, tag = "11")]
    pub commission_rate: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "12")]
    pub next_epoch_commission_rate: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "13")]
    pub pending_update: ::core::option::Option<PendingModelUpdate>,
}
/// Registry of all models in the data submission system.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModelRegistry {
    /// ModelId (ObjectID hex) -> Model
    #[prost(btree_map = "string, message", tag = "1")]
    pub active_models: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        Model,
    >,
    /// ModelId (ObjectID hex) -> Model
    #[prost(btree_map = "string, message", tag = "2")]
    pub pending_models: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        Model,
    >,
    /// pool ObjectID hex -> ModelId hex
    #[prost(btree_map = "string, string", tag = "3")]
    pub staking_pool_mappings: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// ModelId (ObjectID hex) -> Model
    #[prost(btree_map = "string, message", tag = "4")]
    pub inactive_models: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        Model,
    >,
    #[prost(uint64, optional, tag = "5")]
    pub total_model_stake: ::core::option::Option<u64>,
    /// ModelId hex -> reporter addresses
    #[prost(btree_map = "string, message", tag = "6")]
    pub model_report_records: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ReporterSet,
    >,
}
/// Target state coordination (stored in SystemState).
/// Tracks difficulty thresholds and statistics for target generation.
#[non_exhaustive]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TargetState {
    /// Current distance threshold for new targets (f32 cosine distance)
    #[prost(float, optional, tag = "1")]
    pub distance_threshold: ::core::option::Option<f32>,
    /// Count of targets generated this epoch
    #[prost(uint64, optional, tag = "2")]
    pub targets_generated_this_epoch: ::core::option::Option<u64>,
    /// Count of successful hits this epoch
    #[prost(uint64, optional, tag = "3")]
    pub hits_this_epoch: ::core::option::Option<u64>,
    /// EMA of hits per epoch (absolute count)
    /// 0 indicates bootstrap mode (no data yet)
    #[prost(uint64, optional, tag = "4")]
    pub hits_ema: ::core::option::Option<u64>,
    /// Reward per target for current epoch (in shannons)
    #[prost(uint64, optional, tag = "5")]
    pub reward_per_target: ::core::option::Option<u64>,
}
/// A target in the SOMA data submission competition.
/// Targets are shared objects that submitters compete to fill.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Target {
    /// Target ID (ObjectID hex)
    #[prost(string, optional, tag = "1")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    /// Center embedding point (f32 values)
    #[prost(float, repeated, tag = "2")]
    pub embedding: ::prost::alloc::vec::Vec<f32>,
    /// Models assigned to this target (ModelId hex strings)
    #[prost(string, repeated, tag = "3")]
    pub model_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Distance threshold (f32 cosine distance)
    #[prost(float, optional, tag = "4")]
    pub distance_threshold: ::core::option::Option<f32>,
    /// Pre-allocated reward amount (in shannons)
    #[prost(uint64, optional, tag = "5")]
    pub reward_pool: ::core::option::Option<u64>,
    /// Epoch in which this target was generated
    #[prost(uint64, optional, tag = "6")]
    pub generation_epoch: ::core::option::Option<u64>,
    /// Status: "open", "filled", or "claimed"
    #[prost(string, optional, tag = "7")]
    pub status: ::core::option::Option<::prost::alloc::string::String>,
    /// Fill epoch (only present if status is "filled")
    #[prost(uint64, optional, tag = "8")]
    pub fill_epoch: ::core::option::Option<u64>,
    /// Submitter address who filled (only present if filled)
    #[prost(string, optional, tag = "9")]
    pub submitter: ::core::option::Option<::prost::alloc::string::String>,
    /// Model used by the submitter (only present if filled)
    #[prost(string, optional, tag = "10")]
    pub winning_model_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Model owner address at fill time (only present if filled)
    #[prost(string, optional, tag = "11")]
    pub winning_model_owner: ::core::option::Option<::prost::alloc::string::String>,
    /// Bond amount held (in shannons, only present if filled)
    #[prost(uint64, optional, tag = "12")]
    pub bond_amount: ::core::option::Option<u64>,
}
/// A data submission to a target.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Submission {
    /// Submitter address
    #[prost(string, optional, tag = "1")]
    pub submitter: ::core::option::Option<::prost::alloc::string::String>,
    /// Commitment to raw data: hash(data_bytes), 32-byte digest
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub data_commitment: ::core::option::Option<::prost::bytes::Bytes>,
    /// Manifest for submitted data
    #[prost(message, optional, tag = "3")]
    pub data_manifest: ::core::option::Option<SubmissionManifest>,
    /// Model ID used for this submission
    #[prost(string, optional, tag = "4")]
    pub model_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Embedding vector (f32 values)
    #[prost(float, repeated, tag = "5")]
    pub embedding: ::prost::alloc::vec::Vec<f32>,
    /// Distance score reported by submitter (f32 cosine distance)
    #[prost(float, optional, tag = "6")]
    pub distance_score: ::core::option::Option<f32>,
    /// Bond amount locked (in shannons)
    #[prost(uint64, optional, tag = "7")]
    pub bond_amount: ::core::option::Option<u64>,
    /// Epoch when submission was made
    #[prost(uint64, optional, tag = "9")]
    pub submit_epoch: ::core::option::Option<u64>,
}
/// A challenge against a filled target's submission.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Challenge {
    /// Challenge ID (ObjectID hex)
    #[prost(string, optional, tag = "1")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    /// Target being challenged (TargetId hex)
    #[prost(string, optional, tag = "2")]
    pub target_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Address of the challenger
    #[prost(string, optional, tag = "3")]
    pub challenger: ::core::option::Option<::prost::alloc::string::String>,
    /// Bond locked by challenger (in shannons)
    #[prost(uint64, optional, tag = "4")]
    pub challenger_bond: ::core::option::Option<u64>,
    /// Epoch when challenge was initiated
    #[prost(uint64, optional, tag = "5")]
    pub challenge_epoch: ::core::option::Option<u64>,
    /// Status: "pending" or "resolved"
    #[prost(string, optional, tag = "6")]
    pub status: ::core::option::Option<::prost::alloc::string::String>,
    /// Verdict (only if resolved): "challenger_won" or "challenger_lost"
    /// Simplified: reports indicate "challenger is wrong". If 2f+1 report, challenger loses.
    #[prost(string, optional, tag = "7")]
    pub verdict: ::core::option::Option<::prost::alloc::string::String>,
    /// Win reason is no longer used in simplified design (field kept for backwards compatibility)
    #[prost(string, optional, tag = "8")]
    pub win_reason: ::core::option::Option<::prost::alloc::string::String>,
    /// Distance threshold of target (f32 cosine distance)
    #[prost(float, optional, tag = "9")]
    pub distance_threshold: ::core::option::Option<f32>,
    /// Claimed distance score by submitter (f32 cosine distance)
    #[prost(float, optional, tag = "10")]
    pub winning_distance_score: ::core::option::Option<f32>,
    /// Winning model ID used by submitter
    #[prost(string, optional, tag = "11")]
    pub winning_model_id: ::core::option::Option<::prost::alloc::string::String>,
}
/// A transaction.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Transaction {
    /// The digest of this Transaction.
    #[prost(string, optional, tag = "1")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    pub kind: ::core::option::Option<TransactionKind>,
    #[prost(string, optional, tag = "3")]
    pub sender: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "4")]
    pub gas_payment: ::prost::alloc::vec::Vec<ObjectReference>,
}
/// Transaction type.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionKind {
    #[prost(
        oneof = "transaction_kind::Kind",
        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 28, 29, 26, 30, 31, 32"
    )]
    pub kind: ::core::option::Option<transaction_kind::Kind>,
}
/// Nested message and enum types in `TransactionKind`.
pub mod transaction_kind {
    #[non_exhaustive]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        /// Transaction used to initialize the chain state.
        ///
        /// Only valid if in the genesis checkpoint (0) and if this is the very first transaction ever
        /// executed on the chain.
        #[prost(message, tag = "1")]
        Genesis(super::GenesisTransaction),
        /// Consensus commit update.
        #[prost(message, tag = "2")]
        ConsensusCommitPrologue(super::ConsensusCommitPrologue),
        /// System transaction used to end an epoch..
        #[prost(message, tag = "3")]
        ChangeEpoch(super::ChangeEpoch),
        #[prost(message, tag = "4")]
        AddValidator(super::AddValidator),
        #[prost(message, tag = "5")]
        RemoveValidator(super::RemoveValidator),
        #[prost(message, tag = "6")]
        ReportValidator(super::ReportValidator),
        #[prost(message, tag = "7")]
        UndoReportValidator(super::UndoReportValidator),
        #[prost(message, tag = "8")]
        UpdateValidatorMetadata(super::UpdateValidatorMetadata),
        #[prost(message, tag = "9")]
        SetCommissionRate(super::SetCommissionRate),
        #[prost(message, tag = "10")]
        TransferCoin(super::TransferCoin),
        #[prost(message, tag = "11")]
        PayCoins(super::PayCoins),
        #[prost(message, tag = "12")]
        TransferObjects(super::TransferObjects),
        #[prost(message, tag = "13")]
        AddStake(super::AddStake),
        #[prost(message, tag = "14")]
        WithdrawStake(super::WithdrawStake),
        /// Model transactions
        #[prost(message, tag = "15")]
        CommitModel(super::CommitModel),
        #[prost(message, tag = "16")]
        RevealModel(super::RevealModel),
        #[prost(message, tag = "17")]
        CommitModelUpdate(super::CommitModelUpdate),
        #[prost(message, tag = "18")]
        RevealModelUpdate(super::RevealModelUpdate),
        #[prost(message, tag = "19")]
        AddStakeToModel(super::AddStakeToModel),
        #[prost(message, tag = "20")]
        SetModelCommissionRate(super::SetModelCommissionRate),
        #[prost(message, tag = "21")]
        DeactivateModel(super::DeactivateModel),
        #[prost(message, tag = "22")]
        ReportModel(super::ReportModel),
        #[prost(message, tag = "23")]
        UndoReportModel(super::UndoReportModel),
        /// Submission transactions
        #[prost(message, tag = "24")]
        SubmitData(super::SubmitData),
        #[prost(message, tag = "25")]
        ClaimRewards(super::ClaimRewards),
        #[prost(message, tag = "28")]
        ReportSubmission(super::ReportSubmission),
        #[prost(message, tag = "29")]
        UndoReportSubmission(super::UndoReportSubmission),
        /// Challenge transactions
        #[prost(message, tag = "26")]
        InitiateChallenge(super::InitiateChallenge),
        /// Field 27 was ResolveAudit (removed)
        #[prost(message, tag = "30")]
        ReportChallenge(super::ReportChallenge),
        #[prost(message, tag = "31")]
        UndoReportChallenge(super::UndoReportChallenge),
        #[prost(message, tag = "32")]
        ClaimChallengeBond(super::ClaimChallengeBond),
    }
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddValidator {
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub pubkey_bytes: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub network_pubkey_bytes: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", optional, tag = "3")]
    pub worker_pubkey_bytes: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", optional, tag = "4")]
    pub net_address: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", optional, tag = "5")]
    pub p2p_address: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", optional, tag = "6")]
    pub primary_address: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", optional, tag = "7")]
    pub proxy_address: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", optional, tag = "8")]
    pub proof_of_possession: ::core::option::Option<::prost::bytes::Bytes>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveValidator {
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub pubkey_bytes: ::core::option::Option<::prost::bytes::Bytes>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReportValidator {
    #[prost(string, optional, tag = "1")]
    pub reportee: ::core::option::Option<::prost::alloc::string::String>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UndoReportValidator {
    #[prost(string, optional, tag = "1")]
    pub reportee: ::core::option::Option<::prost::alloc::string::String>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateValidatorMetadata {
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub next_epoch_network_address: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub next_epoch_p2p_address: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", optional, tag = "3")]
    pub next_epoch_primary_address: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", optional, tag = "4")]
    pub next_epoch_proxy_address: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", optional, tag = "5")]
    pub next_epoch_protocol_pubkey: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", optional, tag = "6")]
    pub next_epoch_worker_pubkey: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", optional, tag = "7")]
    pub next_epoch_network_pubkey: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", optional, tag = "8")]
    pub next_epoch_proof_of_possession: ::core::option::Option<::prost::bytes::Bytes>,
}
#[non_exhaustive]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetCommissionRate {
    #[prost(uint64, optional, tag = "1")]
    pub new_rate: ::core::option::Option<u64>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransferCoin {
    #[prost(message, optional, tag = "1")]
    pub coin: ::core::option::Option<ObjectReference>,
    #[prost(uint64, optional, tag = "2")]
    pub amount: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3")]
    pub recipient: ::core::option::Option<::prost::alloc::string::String>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PayCoins {
    #[prost(message, repeated, tag = "1")]
    pub coins: ::prost::alloc::vec::Vec<ObjectReference>,
    #[prost(uint64, repeated, tag = "2")]
    pub amounts: ::prost::alloc::vec::Vec<u64>,
    #[prost(string, repeated, tag = "3")]
    pub recipients: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransferObjects {
    #[prost(message, repeated, tag = "1")]
    pub objects: ::prost::alloc::vec::Vec<ObjectReference>,
    #[prost(string, optional, tag = "2")]
    pub recipient: ::core::option::Option<::prost::alloc::string::String>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddStake {
    #[prost(string, optional, tag = "1")]
    pub address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    pub coin_ref: ::core::option::Option<ObjectReference>,
    #[prost(uint64, optional, tag = "3")]
    pub amount: ::core::option::Option<u64>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WithdrawStake {
    #[prost(message, optional, tag = "1")]
    pub staked_soma: ::core::option::Option<ObjectReference>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Metadata {
    #[prost(oneof = "metadata::Version", tags = "1")]
    pub version: ::core::option::Option<metadata::Version>,
}
/// Nested message and enum types in `Metadata`.
pub mod metadata {
    #[non_exhaustive]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Version {
        #[prost(message, tag = "1")]
        V1(super::MetadataV1),
    }
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataV1 {
    /// 32-byte digest
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub checksum: ::core::option::Option<::prost::bytes::Bytes>,
    /// Size in bytes
    #[prost(uint64, optional, tag = "2")]
    pub size: ::core::option::Option<u64>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Manifest {
    #[prost(oneof = "manifest::Version", tags = "1")]
    pub version: ::core::option::Option<manifest::Version>,
}
/// Nested message and enum types in `Manifest`.
pub mod manifest {
    #[non_exhaustive]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Version {
        #[prost(message, tag = "1")]
        V1(super::ManifestV1),
    }
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ManifestV1 {
    #[prost(string, optional, tag = "1")]
    pub url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    pub metadata: ::core::option::Option<Metadata>,
}
/// Model weights manifest: URL + metadata + decryption key.
/// Used by RevealModel and RevealModelUpdate transactions, and by Model in system state.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModelWeightsManifest {
    #[prost(message, optional, tag = "1")]
    pub manifest: ::core::option::Option<Manifest>,
    /// 32-byte AES-256 key
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub decryption_key: ::core::option::Option<::prost::bytes::Bytes>,
}
/// Pending update to an active model's weights (commit phase).
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PendingModelUpdate {
    #[prost(message, optional, tag = "1")]
    pub manifest: ::core::option::Option<Manifest>,
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub weights_commitment: ::core::option::Option<::prost::bytes::Bytes>,
    /// 32-byte hash
    #[prost(bytes = "bytes", optional, tag = "3")]
    pub embedding_commitment: ::core::option::Option<::prost::bytes::Bytes>,
    /// 32-byte hash
    #[prost(bytes = "bytes", optional, tag = "4")]
    pub decryption_key_commitment: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(uint64, optional, tag = "5")]
    pub commit_epoch: ::core::option::Option<u64>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommitModel {
    #[prost(message, optional, tag = "1")]
    pub manifest: ::core::option::Option<Manifest>,
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub weights_commitment: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(uint64, optional, tag = "3")]
    pub architecture_version: ::core::option::Option<u64>,
    /// 32-byte hash of BCS-serialized embedding
    #[prost(bytes = "bytes", optional, tag = "4")]
    pub embedding_commitment: ::core::option::Option<::prost::bytes::Bytes>,
    /// 32-byte hash of decryption key
    #[prost(bytes = "bytes", optional, tag = "5")]
    pub decryption_key_commitment: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(uint64, optional, tag = "6")]
    pub stake_amount: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "7")]
    pub commission_rate: ::core::option::Option<u64>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RevealModel {
    #[prost(string, optional, tag = "1")]
    pub model_id: ::core::option::Option<::prost::alloc::string::String>,
    /// 32-byte AES-256 key
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub decryption_key: ::core::option::Option<::prost::bytes::Bytes>,
    /// Full model embedding revealed here
    #[prost(float, repeated, tag = "3")]
    pub embedding: ::prost::alloc::vec::Vec<f32>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommitModelUpdate {
    #[prost(string, optional, tag = "1")]
    pub model_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    pub manifest: ::core::option::Option<Manifest>,
    #[prost(bytes = "bytes", optional, tag = "3")]
    pub weights_commitment: ::core::option::Option<::prost::bytes::Bytes>,
    /// 32-byte hash of BCS-serialized embedding
    #[prost(bytes = "bytes", optional, tag = "4")]
    pub embedding_commitment: ::core::option::Option<::prost::bytes::Bytes>,
    /// 32-byte hash of decryption key
    #[prost(bytes = "bytes", optional, tag = "5")]
    pub decryption_key_commitment: ::core::option::Option<::prost::bytes::Bytes>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RevealModelUpdate {
    #[prost(string, optional, tag = "1")]
    pub model_id: ::core::option::Option<::prost::alloc::string::String>,
    /// 32-byte AES-256 key
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub decryption_key: ::core::option::Option<::prost::bytes::Bytes>,
    /// Full updated model embedding
    #[prost(float, repeated, tag = "3")]
    pub embedding: ::prost::alloc::vec::Vec<f32>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddStakeToModel {
    #[prost(string, optional, tag = "1")]
    pub model_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    pub coin_ref: ::core::option::Option<ObjectReference>,
    #[prost(uint64, optional, tag = "3")]
    pub amount: ::core::option::Option<u64>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetModelCommissionRate {
    #[prost(string, optional, tag = "1")]
    pub model_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "2")]
    pub new_rate: ::core::option::Option<u64>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeactivateModel {
    #[prost(string, optional, tag = "1")]
    pub model_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReportModel {
    #[prost(string, optional, tag = "1")]
    pub model_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UndoReportModel {
    #[prost(string, optional, tag = "1")]
    pub model_id: ::core::option::Option<::prost::alloc::string::String>,
}
/// Report a submission as fraudulent (validators only)
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReportSubmission {
    #[prost(string, optional, tag = "1")]
    pub target_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional challenger to attribute fraud to (for tally-based bond distribution)
    #[prost(string, optional, tag = "2")]
    pub challenger: ::core::option::Option<::prost::alloc::string::String>,
}
/// Undo a previous submission report
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UndoReportSubmission {
    #[prost(string, optional, tag = "1")]
    pub target_id: ::core::option::Option<::prost::alloc::string::String>,
}
/// System transaction used to change the epoch.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangeEpoch {
    /// The next (to become) epoch ID.
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    /// Unix timestamp when epoch started.
    #[prost(message, optional, tag = "2")]
    pub epoch_start_timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// The protocol version in effect in the new epoch.
    #[prost(uint64, optional, tag = "3")]
    pub protocol_version: ::core::option::Option<u64>,
    /// The total amount of fees charged during the epoch.
    #[prost(uint64, optional, tag = "4")]
    pub fees: ::core::option::Option<u64>,
    /// / Epoch randomness
    #[prost(bytes = "bytes", optional, tag = "5")]
    pub epoch_randomness: ::core::option::Option<::prost::bytes::Bytes>,
}
/// The genesis transaction.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenesisTransaction {
    /// Set of genesis objects.
    #[prost(message, repeated, tag = "1")]
    pub objects: ::prost::alloc::vec::Vec<Object>,
}
/// Consensus commit prologue system transaction.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsensusCommitPrologue {
    /// Epoch of the commit prologue transaction.
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    /// Consensus round of the commit.
    #[prost(uint64, optional, tag = "2")]
    pub round: ::core::option::Option<u64>,
    /// The sub DAG index of the consensus commit. This field is populated if there
    /// are multiple consensus commits per round.
    #[prost(uint64, optional, tag = "3")]
    pub sub_dag_index: ::core::option::Option<u64>,
    /// Unix timestamp from consensus.
    #[prost(message, optional, tag = "4")]
    pub commit_timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Digest of consensus output.
    #[prost(string, optional, tag = "5")]
    pub consensus_commit_digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Digest of any additional state computed by the consensus handler.
    /// Used to detect forking bugs as early as possible.
    #[prost(string, optional, tag = "6")]
    pub additional_state_digest: ::core::option::Option<::prost::alloc::string::String>,
}
/// Submit data to a target in the data submission competition.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitData {
    #[prost(string, optional, tag = "1")]
    pub target_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Field 2 removed (was data_commitment)
    #[prost(message, optional, tag = "3")]
    pub data_manifest: ::core::option::Option<SubmissionManifest>,
    #[prost(string, optional, tag = "4")]
    pub model_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(float, repeated, tag = "5")]
    pub embedding: ::prost::alloc::vec::Vec<f32>,
    #[prost(float, optional, tag = "6")]
    pub distance_score: ::core::option::Option<f32>,
    #[prost(message, optional, tag = "7")]
    pub bond_coin: ::core::option::Option<ObjectReference>,
    #[prost(float, repeated, tag = "8")]
    pub loss_score: ::prost::alloc::vec::Vec<f32>,
}
/// Claim rewards from a filled or expired target.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClaimRewards {
    /// Target ID (ObjectID hex string)
    #[prost(string, optional, tag = "1")]
    pub target_id: ::core::option::Option<::prost::alloc::string::String>,
}
/// Manifest for submitted data (URL + metadata).
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmissionManifest {
    #[prost(message, optional, tag = "1")]
    pub manifest: ::core::option::Option<Manifest>,
}
/// Initiate a challenge against a filled target.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InitiateChallenge {
    /// Target ID (ObjectID hex string) to challenge
    #[prost(string, optional, tag = "1")]
    pub target_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Type of challenge (e.g., "data_unavailable", "model_unavailable", "data_fraud", "score_fraud")
    #[prost(string, optional, tag = "2")]
    pub challenge_type: ::core::option::Option<::prost::alloc::string::String>,
    /// For ModelUnavailable challenges: the model ID that is unavailable
    #[prost(string, optional, tag = "3")]
    pub model_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Bond coin reference
    #[prost(message, optional, tag = "4")]
    pub bond_coin: ::core::option::Option<ObjectReference>,
}
/// Report a challenge (validators only).
/// Reports indicate "the challenger is wrong" (i.e., the submission is valid).
/// If 2f+1 validators report, the challenger loses their bond.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReportChallenge {
    /// Challenge ID (ObjectID hex string)
    #[prost(string, optional, tag = "1")]
    pub challenge_id: ::core::option::Option<::prost::alloc::string::String>,
}
/// Undo a previous challenge report.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UndoReportChallenge {
    /// Challenge ID (ObjectID hex string)
    #[prost(string, optional, tag = "1")]
    pub challenge_id: ::core::option::Option<::prost::alloc::string::String>,
}
/// Claim the challenger's bond after challenge window closes.
/// Distributes bond based on tally-based report quorum.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClaimChallengeBond {
    /// Challenge ID (ObjectID hex string)
    #[prost(string, optional, tag = "1")]
    pub challenge_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteTransactionRequest {
    /// The transaction to execute.
    #[prost(message, optional, tag = "1")]
    pub transaction: ::core::option::Option<Transaction>,
    /// Set of `UserSignature`s authorizing the execution of the provided
    /// transaction.
    #[prost(message, repeated, tag = "2")]
    pub signatures: ::prost::alloc::vec::Vec<UserSignature>,
    /// Mask specifying which fields to read.
    /// If no mask is specified, defaults to `effects.status,checkpoint`.
    #[prost(message, optional, tag = "3")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Response message for `NodeService.ExecuteTransaction`.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteTransactionResponse {
    #[prost(message, optional, tag = "1")]
    pub transaction: ::core::option::Option<ExecutedTransaction>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SimulateTransactionRequest {
    #[prost(message, optional, tag = "1")]
    pub transaction: ::core::option::Option<Transaction>,
    /// Mask specifying which fields to read.
    #[prost(message, optional, tag = "2")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Specify whether checks should be ENABLED (default) or DISABLED while executing the transaction
    #[prost(
        enumeration = "simulate_transaction_request::TransactionChecks",
        optional,
        tag = "3"
    )]
    pub checks: ::core::option::Option<i32>,
}
/// Nested message and enum types in `SimulateTransactionRequest`.
pub mod simulate_transaction_request {
    /// buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX
    #[non_exhaustive]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TransactionChecks {
        Enabled = 0,
        Disabled = 1,
    }
    impl TransactionChecks {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Enabled => "ENABLED",
                Self::Disabled => "DISABLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ENABLED" => Some(Self::Enabled),
                "DISABLED" => Some(Self::Disabled),
                _ => None,
            }
        }
    }
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SimulateTransactionResponse {
    #[prost(message, optional, tag = "1")]
    pub transaction: ::core::option::Option<ExecutedTransaction>,
}
/// Generated client implementations.
pub mod transaction_execution_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct TransactionExecutionServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl TransactionExecutionServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> TransactionExecutionServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> TransactionExecutionServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            TransactionExecutionServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn execute_transaction(
            &mut self,
            request: impl tonic::IntoRequest<super::ExecuteTransactionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ExecuteTransactionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/soma.rpc.TransactionExecutionService/ExecuteTransaction",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "soma.rpc.TransactionExecutionService",
                        "ExecuteTransaction",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn simulate_transaction(
            &mut self,
            request: impl tonic::IntoRequest<super::SimulateTransactionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SimulateTransactionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/soma.rpc.TransactionExecutionService/SimulateTransaction",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "soma.rpc.TransactionExecutionService",
                        "SimulateTransaction",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod transaction_execution_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with TransactionExecutionServiceServer.
    #[async_trait]
    pub trait TransactionExecutionService: std::marker::Send + std::marker::Sync + 'static {
        async fn execute_transaction(
            &self,
            request: tonic::Request<super::ExecuteTransactionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ExecuteTransactionResponse>,
            tonic::Status,
        >;
        async fn simulate_transaction(
            &self,
            request: tonic::Request<super::SimulateTransactionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SimulateTransactionResponse>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct TransactionExecutionServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> TransactionExecutionServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for TransactionExecutionServiceServer<T>
    where
        T: TransactionExecutionService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/soma.rpc.TransactionExecutionService/ExecuteTransaction" => {
                    #[allow(non_camel_case_types)]
                    struct ExecuteTransactionSvc<T: TransactionExecutionService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: TransactionExecutionService,
                    > tonic::server::UnaryService<super::ExecuteTransactionRequest>
                    for ExecuteTransactionSvc<T> {
                        type Response = super::ExecuteTransactionResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ExecuteTransactionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TransactionExecutionService>::execute_transaction(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ExecuteTransactionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/soma.rpc.TransactionExecutionService/SimulateTransaction" => {
                    #[allow(non_camel_case_types)]
                    struct SimulateTransactionSvc<T: TransactionExecutionService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: TransactionExecutionService,
                    > tonic::server::UnaryService<super::SimulateTransactionRequest>
                    for SimulateTransactionSvc<T> {
                        type Response = super::SimulateTransactionResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SimulateTransactionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TransactionExecutionService>::simulate_transaction(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SimulateTransactionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(
                            tonic::body::Body::default(),
                        );
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for TransactionExecutionServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "soma.rpc.TransactionExecutionService";
    impl<T> tonic::server::NamedService for TransactionExecutionServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Summary of the fee for this transaction.
#[non_exhaustive]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TransactionFee {
    /// base transaction fee.
    #[prost(uint64, optional, tag = "1")]
    pub base_fee: ::core::option::Option<u64>,
    /// Fee for each object operation (reads and writes).
    #[prost(uint64, optional, tag = "2")]
    pub operation_fee: ::core::option::Option<u64>,
    /// Fee based on transaction value.
    #[prost(uint64, optional, tag = "3")]
    pub value_fee: ::core::option::Option<u64>,
    /// Total fee deducted.
    #[prost(uint64, optional, tag = "4")]
    pub total_fee: ::core::option::Option<u64>,
}
