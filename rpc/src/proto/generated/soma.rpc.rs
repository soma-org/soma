// This file is @generated by prost-build.
/// An argument to a programmable transaction command.
#[non_exhaustive]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Argument {
    #[prost(enumeration = "argument::ArgumentKind", optional, tag = "1")]
    pub kind: ::core::option::Option<i32>,
    /// Index of an input when `kind` is `INPUT`.
    #[prost(uint32, optional, tag = "2")]
    pub input: ::core::option::Option<u32>,
    /// Index of a result when `kind` is `RESULT`.
    #[prost(uint32, optional, tag = "3")]
    pub result: ::core::option::Option<u32>,
    /// Used to access a nested result when `kind` is `RESULT`.
    #[prost(uint32, optional, tag = "4")]
    pub subresult: ::core::option::Option<u32>,
}
/// Nested message and enum types in `Argument`.
pub mod argument {
    #[non_exhaustive]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ArgumentKind {
        Unknown = 0,
        /// The gas coin.
        Gas = 1,
        /// One of the input objects or primitive values (from
        /// `ProgrammableTransaction` inputs).
        Input = 2,
        /// The result of another command (from `ProgrammableTransaction` commands).
        Result = 3,
    }
    impl ArgumentKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "ARGUMENT_KIND_UNKNOWN",
                Self::Gas => "GAS",
                Self::Input => "INPUT",
                Self::Result => "RESULT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ARGUMENT_KIND_UNKNOWN" => Some(Self::Unknown),
                "GAS" => Some(Self::Gas),
                "INPUT" => Some(Self::Input),
                "RESULT" => Some(Self::Result),
                _ => None,
            }
        }
    }
}
/// The delta, or change, in balance for an address for a particular `Coin` type.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BalanceChange {
    /// The account address that is affected by this balance change event.
    #[prost(string, optional, tag = "1")]
    pub address: ::core::option::Option<::prost::alloc::string::String>,
    /// The `Coin` type of this balance change event.
    #[prost(string, optional, tag = "2")]
    pub coin_type: ::core::option::Option<::prost::alloc::string::String>,
    /// The amount or change in balance.
    #[prost(string, optional, tag = "3")]
    pub amount: ::core::option::Option<::prost::alloc::string::String>,
}
/// `Bcs` contains an arbitrary type that is serialized using the BCS
/// format as well as a name that identifies the type of the serialized value.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Bcs {
    /// Name that identifies the type of the serialized value.
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// Bytes of a BCS serialized value.
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub value: ::core::option::Option<::prost::bytes::Bytes>,
}
/// The effects of executing a transaction.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionEffects {
    /// This TransactionEffects serialized as BCS.
    #[prost(message, optional, tag = "1")]
    pub bcs: ::core::option::Option<Bcs>,
    /// The digest of this TransactionEffects.
    #[prost(string, optional, tag = "2")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Version of this TransactionEffects.
    #[prost(int32, optional, tag = "3")]
    pub version: ::core::option::Option<i32>,
    /// The status of the execution.
    #[prost(message, optional, tag = "4")]
    pub status: ::core::option::Option<ExecutionStatus>,
    /// The epoch when this transaction was executed.
    #[prost(uint64, optional, tag = "5")]
    pub epoch: ::core::option::Option<u64>,
    /// The gas used by this transaction.
    #[prost(message, optional, tag = "6")]
    pub gas_used: ::core::option::Option<GasCostSummary>,
    /// The transaction digest.
    #[prost(string, optional, tag = "7")]
    pub transaction_digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Information about the gas object. Also present in the `changed_objects` vector.
    ///
    /// System transaction that don't require gas will leave this as `None`.
    #[prost(message, optional, tag = "8")]
    pub gas_object: ::core::option::Option<ChangedObject>,
    /// The digest of the events emitted during execution,
    /// can be `None` if the transaction does not emit any event.
    #[prost(string, optional, tag = "9")]
    pub events_digest: ::core::option::Option<::prost::alloc::string::String>,
    /// The set of transaction digests this transaction depends on.
    #[prost(string, repeated, tag = "10")]
    pub dependencies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The version number of all the written objects (excluding packages) by this transaction.
    #[prost(uint64, optional, tag = "11")]
    pub lamport_version: ::core::option::Option<u64>,
    /// Objects whose state are changed by this transaction.
    #[prost(message, repeated, tag = "12")]
    pub changed_objects: ::prost::alloc::vec::Vec<ChangedObject>,
    /// Consensus objects that are not mutated in this transaction. Unlike owned objects,
    /// read-only consensus objects' version are not committed in the transaction,
    /// and in order for a node to catch up and execute it without consensus sequencing,
    /// the version needs to be committed in the effects.
    #[prost(message, repeated, tag = "13")]
    pub unchanged_consensus_objects: ::prost::alloc::vec::Vec<UnchangedConsensusObject>,
    /// Auxiliary data that are not protocol-critical, generated as part of the effects but are stored separately.
    /// Storing it separately allows us to avoid bloating the effects with data that are not critical.
    /// It also provides more flexibility on the format and type of the data.
    #[prost(string, optional, tag = "14")]
    pub auxiliary_data_digest: ::core::option::Option<::prost::alloc::string::String>,
}
/// Input/output state of an object that was changed during execution.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangedObject {
    /// ID of the object.
    #[prost(string, optional, tag = "1")]
    pub object_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "changed_object::InputObjectState", optional, tag = "2")]
    pub input_state: ::core::option::Option<i32>,
    /// Version of the object before this transaction executed.
    #[prost(uint64, optional, tag = "3")]
    pub input_version: ::core::option::Option<u64>,
    /// Digest of the object before this transaction executed.
    #[prost(string, optional, tag = "4")]
    pub input_digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Owner of the object before this transaction executed.
    #[prost(message, optional, tag = "5")]
    pub input_owner: ::core::option::Option<Owner>,
    #[prost(enumeration = "changed_object::OutputObjectState", optional, tag = "6")]
    pub output_state: ::core::option::Option<i32>,
    /// Version of the object after this transaction executed.
    #[prost(uint64, optional, tag = "7")]
    pub output_version: ::core::option::Option<u64>,
    /// Digest of the object after this transaction executed.
    #[prost(string, optional, tag = "8")]
    pub output_digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Owner of the object after this transaction executed.
    #[prost(message, optional, tag = "9")]
    pub output_owner: ::core::option::Option<Owner>,
    /// What happened to an `ObjectId` during execution.
    #[prost(enumeration = "changed_object::IdOperation", optional, tag = "10")]
    pub id_operation: ::core::option::Option<i32>,
    /// Type information is not provided by the effects structure but is instead
    /// provided by an indexing layer
    #[prost(string, optional, tag = "11")]
    pub object_type: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `ChangedObject`.
pub mod changed_object {
    #[non_exhaustive]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InputObjectState {
        Unknown = 0,
        DoesNotExist = 1,
        Exists = 2,
    }
    impl InputObjectState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "INPUT_OBJECT_STATE_UNKNOWN",
                Self::DoesNotExist => "INPUT_OBJECT_STATE_DOES_NOT_EXIST",
                Self::Exists => "INPUT_OBJECT_STATE_EXISTS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INPUT_OBJECT_STATE_UNKNOWN" => Some(Self::Unknown),
                "INPUT_OBJECT_STATE_DOES_NOT_EXIST" => Some(Self::DoesNotExist),
                "INPUT_OBJECT_STATE_EXISTS" => Some(Self::Exists),
                _ => None,
            }
        }
    }
    #[non_exhaustive]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OutputObjectState {
        Unknown = 0,
        DoesNotExist = 1,
        ObjectWrite = 2,
        PackageWrite = 3,
    }
    impl OutputObjectState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "OUTPUT_OBJECT_STATE_UNKNOWN",
                Self::DoesNotExist => "OUTPUT_OBJECT_STATE_DOES_NOT_EXIST",
                Self::ObjectWrite => "OUTPUT_OBJECT_STATE_OBJECT_WRITE",
                Self::PackageWrite => "OUTPUT_OBJECT_STATE_PACKAGE_WRITE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OUTPUT_OBJECT_STATE_UNKNOWN" => Some(Self::Unknown),
                "OUTPUT_OBJECT_STATE_DOES_NOT_EXIST" => Some(Self::DoesNotExist),
                "OUTPUT_OBJECT_STATE_OBJECT_WRITE" => Some(Self::ObjectWrite),
                "OUTPUT_OBJECT_STATE_PACKAGE_WRITE" => Some(Self::PackageWrite),
                _ => None,
            }
        }
    }
    #[non_exhaustive]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum IdOperation {
        Unknown = 0,
        None = 1,
        Created = 2,
        Deleted = 3,
    }
    impl IdOperation {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "ID_OPERATION_UNKNOWN",
                Self::None => "NONE",
                Self::Created => "CREATED",
                Self::Deleted => "DELETED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ID_OPERATION_UNKNOWN" => Some(Self::Unknown),
                "NONE" => Some(Self::None),
                "CREATED" => Some(Self::Created),
                "DELETED" => Some(Self::Deleted),
                _ => None,
            }
        }
    }
}
/// A consensus object that wasn't changed during execution.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnchangedConsensusObject {
    #[prost(
        enumeration = "unchanged_consensus_object::UnchangedConsensusObjectKind",
        optional,
        tag = "1"
    )]
    pub kind: ::core::option::Option<i32>,
    /// ObjectId of the consensus object.
    #[prost(string, optional, tag = "2")]
    pub object_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Version of the consensus object.
    #[prost(uint64, optional, tag = "3")]
    pub version: ::core::option::Option<u64>,
    /// Digest of the consensus object.
    #[prost(string, optional, tag = "4")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Type information is not provided by the effects structure but is instead
    /// provided by an indexing layer
    #[prost(string, optional, tag = "5")]
    pub object_type: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `UnchangedConsensusObject`.
pub mod unchanged_consensus_object {
    #[non_exhaustive]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UnchangedConsensusObjectKind {
        Unknown = 0,
        /// Read-only consensus object from the input.
        ReadOnlyRoot = 1,
        /// Objects with ended consensus streams that appear mutably/owned in the input.
        MutateConsensusStreamEnded = 2,
        /// Objects with ended consensus streams objects that appear as read-only in the input.
        ReadConsensusStreamEnded = 3,
        /// Consensus objects that were congested and resulted in this transaction being
        /// canceled.
        Canceled = 4,
        /// Read of a per-epoch config object that should remain the same during an
        /// epoch. This optionally will indicate the sequence number of the config
        /// object at the start of the epoch.
        PerEpochConfig = 5,
    }
    impl UnchangedConsensusObjectKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNCHANGED_CONSENSUS_OBJECT_KIND_UNKNOWN",
                Self::ReadOnlyRoot => "READ_ONLY_ROOT",
                Self::MutateConsensusStreamEnded => "MUTATE_CONSENSUS_STREAM_ENDED",
                Self::ReadConsensusStreamEnded => "READ_CONSENSUS_STREAM_ENDED",
                Self::Canceled => "CANCELED",
                Self::PerEpochConfig => "PER_EPOCH_CONFIG",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNCHANGED_CONSENSUS_OBJECT_KIND_UNKNOWN" => Some(Self::Unknown),
                "READ_ONLY_ROOT" => Some(Self::ReadOnlyRoot),
                "MUTATE_CONSENSUS_STREAM_ENDED" => Some(Self::MutateConsensusStreamEnded),
                "READ_CONSENSUS_STREAM_ENDED" => Some(Self::ReadConsensusStreamEnded),
                "CANCELED" => Some(Self::Canceled),
                "PER_EPOCH_CONFIG" => Some(Self::PerEpochConfig),
                _ => None,
            }
        }
    }
}
#[non_exhaustive]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ErrorReason {
    Unknown = 0,
    FieldInvalid = 1,
    FieldMissing = 2,
}
impl ErrorReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "ERROR_REASON_UNKNOWN",
            Self::FieldInvalid => "FIELD_INVALID",
            Self::FieldMissing => "FIELD_MISSING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ERROR_REASON_UNKNOWN" => Some(Self::Unknown),
            "FIELD_INVALID" => Some(Self::FieldInvalid),
            "FIELD_MISSING" => Some(Self::FieldMissing),
            _ => None,
        }
    }
}
/// Events emitted during the successful execution of a transaction.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionEvents {
    /// This TransactionEvents serialized as BCS.
    #[prost(message, optional, tag = "1")]
    pub bcs: ::core::option::Option<Bcs>,
    /// The digest of this TransactionEvents.
    #[prost(string, optional, tag = "2")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Set of events emitted by a transaction.
    #[prost(message, repeated, tag = "3")]
    pub events: ::prost::alloc::vec::Vec<Event>,
}
/// An event.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Event {
    /// Package ID of the top-level function invoked by a `MoveCall` command that triggered this
    /// event to be emitted.
    #[prost(string, optional, tag = "1")]
    pub package_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Module name of the top-level function invoked by a `MoveCall` command that triggered this
    /// event to be emitted.
    #[prost(string, optional, tag = "2")]
    pub module: ::core::option::Option<::prost::alloc::string::String>,
    /// Address of the account that sent the transaction where this event was emitted.
    #[prost(string, optional, tag = "3")]
    pub sender: ::core::option::Option<::prost::alloc::string::String>,
    /// The type of the event emitted.
    #[prost(string, optional, tag = "4")]
    pub event_type: ::core::option::Option<::prost::alloc::string::String>,
    /// BCS serialized bytes of the event.
    #[prost(message, optional, tag = "5")]
    pub contents: ::core::option::Option<Bcs>,
    /// JSON rendering of the event.
    #[prost(message, optional, boxed, tag = "6")]
    pub json: ::core::option::Option<::prost::alloc::boxed::Box<::prost_types::Value>>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutedTransaction {
    /// The digest of this Transaction.
    #[prost(string, optional, tag = "1")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// The transaction itself.
    #[prost(message, optional, tag = "2")]
    pub transaction: ::core::option::Option<Transaction>,
    /// List of user signatures that are used to authorize the
    /// execution of this transaction.
    #[prost(message, repeated, tag = "3")]
    pub signatures: ::prost::alloc::vec::Vec<UserSignature>,
    /// The `TransactionEffects` for this transaction.
    #[prost(message, optional, tag = "4")]
    pub effects: ::core::option::Option<TransactionEffects>,
    /// The `TransactionEvents` for this transaction.
    ///
    /// This field might be empty, even if it was explicitly requested, if the
    /// transaction didn't produce any events.
    /// `sui.types.TransactionEffects.events_digest` is populated if the
    /// transaction produced any events.
    #[prost(message, optional, tag = "5")]
    pub events: ::core::option::Option<TransactionEvents>,
    /// The sequence number for the checkpoint that includes this transaction.
    #[prost(uint64, optional, tag = "6")]
    pub checkpoint: ::core::option::Option<u64>,
    /// The Unix timestamp of the checkpoint that includes this transaction.
    #[prost(message, optional, tag = "7")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, repeated, tag = "8")]
    pub balance_changes: ::prost::alloc::vec::Vec<BalanceChange>,
    /// Set of input objects used during the execution of this transaction.
    #[prost(message, repeated, tag = "10")]
    pub input_objects: ::prost::alloc::vec::Vec<Object>,
    /// Set of output objects produced from the execution of this transaction.
    #[prost(message, repeated, tag = "11")]
    pub output_objects: ::prost::alloc::vec::Vec<Object>,
}
/// The status of an executed transaction.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutionStatus {
    /// Indicates if the transaction was successful or not.
    #[prost(bool, optional, tag = "1")]
    pub success: ::core::option::Option<bool>,
    /// The error if `success` is false.
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<ExecutionError>,
}
/// An error that can occur during the execution of a transaction.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutionError {
    /// A human readable description of the error
    #[prost(string, optional, tag = "1")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    /// The command, if any, during which the error occurred.
    #[prost(uint64, optional, tag = "2")]
    pub command: ::core::option::Option<u64>,
    #[prost(enumeration = "execution_error::ExecutionErrorKind", optional, tag = "3")]
    pub kind: ::core::option::Option<i32>,
    #[prost(
        oneof = "execution_error::ErrorDetails",
        tags = "4, 5, 6, 7, 8, 9, 10, 11, 12"
    )]
    pub error_details: ::core::option::Option<execution_error::ErrorDetails>,
}
/// Nested message and enum types in `ExecutionError`.
pub mod execution_error {
    #[non_exhaustive]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExecutionErrorKind {
        Unknown = 0,
        /// Insufficient gas.
        InsufficientGas = 1,
        /// Invalid `Gas` object.
        InvalidGasObject = 2,
        /// Invariant violation.
        InvariantViolation = 3,
        /// Attempted to use feature that is not supported yet.
        FeatureNotYetSupported = 4,
        /// Move object is larger than the maximum allowed size.
        ObjectTooBig = 5,
        /// Package is larger than the maximum allowed size.
        PackageTooBig = 6,
        /// Circular object ownership.
        CircularObjectOwnership = 7,
        /// Insufficient coin balance for requested operation.
        InsufficientCoinBalance = 8,
        /// Coin balance overflowed an u64.
        CoinBalanceOverflow = 9,
        /// Publish error, non-zero address.
        /// The modules in the package must have their self-addresses set to zero.
        PublishErrorNonZeroAddress = 10,
        /// Sui Move bytecode verification error.
        SuiMoveVerificationError = 11,
        /// Error from a non-abort instruction.
        /// Possible causes:
        ///      Arithmetic error, stack overflow, max value depth, or similar.
        MovePrimitiveRuntimeError = 12,
        /// Move runtime abort.
        MoveAbort = 13,
        /// Bytecode verification error.
        VmVerificationOrDeserializationError = 14,
        /// MoveVm invariant violation.
        VmInvariantViolation = 15,
        /// Function not found.
        FunctionNotFound = 16,
        /// Parity mismatch for Move function.
        /// The number of arguments does not match the number of parameters.
        ArityMismatch = 17,
        /// Type parity mismatch for Move function.
        /// Mismatch between the number of actual versus expected type arguments.
        TypeArityMismatch = 18,
        /// Non-entry function invoked. Move Call must start with an entry function.
        NonEntryFunctionInvoked = 19,
        /// Invalid command argument.
        CommandArgumentError = 20,
        /// Type argument error.
        TypeArgumentError = 21,
        /// Unused result without the drop ability.
        UnusedValueWithoutDrop = 22,
        /// Invalid public Move function signature.
        /// Unsupported return type for return value.
        InvalidPublicFunctionReturnType = 23,
        /// Invalid transfer object, object does not have public transfer.
        InvalidTransferObject = 24,
        /// Effects from the transaction are too large.
        EffectsTooLarge = 25,
        /// Publish or Upgrade is missing dependency.
        PublishUpgradeMissingDependency = 26,
        /// Publish or upgrade dependency downgrade.
        ///
        /// Indirect (transitive) dependency of published or upgraded package has been assigned an
        /// on-chain version that is less than the version required by one of the package's
        /// transitive dependencies.
        PublishUpgradeDependencyDowngrade = 27,
        /// Invalid package upgrade.
        PackageUpgradeError = 28,
        /// Indicates the transaction tried to write objects too large to storage.
        WrittenObjectsTooLarge = 29,
        /// Certificate is on the deny list.
        CertificateDenied = 30,
        /// Sui Move bytecode verification timed out.
        SuiMoveVerificationTimedout = 31,
        /// The requested consensus object operation is not allowed.
        ConsensusObjectOperationNotAllowed = 32,
        /// Requested consensus object has been deleted.
        InputObjectDeleted = 33,
        /// Certificate is canceled due to congestion on consensus objects.
        ExecutionCanceledDueToConsensusObjectCongestion = 34,
        /// Address is denied for this coin type.
        AddressDeniedForCoin = 35,
        /// Coin type is globally paused for use.
        CoinTypeGlobalPause = 36,
        /// Certificate is canceled because randomness could not be generated this epoch.
        ExecutionCanceledDueToRandomnessUnavailable = 37,
        MoveVectorElemTooBig = 38,
        MoveRawValueTooBig = 39,
        InvalidLinkage = 40,
    }
    impl ExecutionErrorKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "EXECUTION_ERROR_KIND_UNKNOWN",
                Self::InsufficientGas => "INSUFFICIENT_GAS",
                Self::InvalidGasObject => "INVALID_GAS_OBJECT",
                Self::InvariantViolation => "INVARIANT_VIOLATION",
                Self::FeatureNotYetSupported => "FEATURE_NOT_YET_SUPPORTED",
                Self::ObjectTooBig => "OBJECT_TOO_BIG",
                Self::PackageTooBig => "PACKAGE_TOO_BIG",
                Self::CircularObjectOwnership => "CIRCULAR_OBJECT_OWNERSHIP",
                Self::InsufficientCoinBalance => "INSUFFICIENT_COIN_BALANCE",
                Self::CoinBalanceOverflow => "COIN_BALANCE_OVERFLOW",
                Self::PublishErrorNonZeroAddress => "PUBLISH_ERROR_NON_ZERO_ADDRESS",
                Self::SuiMoveVerificationError => "SUI_MOVE_VERIFICATION_ERROR",
                Self::MovePrimitiveRuntimeError => "MOVE_PRIMITIVE_RUNTIME_ERROR",
                Self::MoveAbort => "MOVE_ABORT",
                Self::VmVerificationOrDeserializationError => {
                    "VM_VERIFICATION_OR_DESERIALIZATION_ERROR"
                }
                Self::VmInvariantViolation => "VM_INVARIANT_VIOLATION",
                Self::FunctionNotFound => "FUNCTION_NOT_FOUND",
                Self::ArityMismatch => "ARITY_MISMATCH",
                Self::TypeArityMismatch => "TYPE_ARITY_MISMATCH",
                Self::NonEntryFunctionInvoked => "NON_ENTRY_FUNCTION_INVOKED",
                Self::CommandArgumentError => "COMMAND_ARGUMENT_ERROR",
                Self::TypeArgumentError => "TYPE_ARGUMENT_ERROR",
                Self::UnusedValueWithoutDrop => "UNUSED_VALUE_WITHOUT_DROP",
                Self::InvalidPublicFunctionReturnType => {
                    "INVALID_PUBLIC_FUNCTION_RETURN_TYPE"
                }
                Self::InvalidTransferObject => "INVALID_TRANSFER_OBJECT",
                Self::EffectsTooLarge => "EFFECTS_TOO_LARGE",
                Self::PublishUpgradeMissingDependency => {
                    "PUBLISH_UPGRADE_MISSING_DEPENDENCY"
                }
                Self::PublishUpgradeDependencyDowngrade => {
                    "PUBLISH_UPGRADE_DEPENDENCY_DOWNGRADE"
                }
                Self::PackageUpgradeError => "PACKAGE_UPGRADE_ERROR",
                Self::WrittenObjectsTooLarge => "WRITTEN_OBJECTS_TOO_LARGE",
                Self::CertificateDenied => "CERTIFICATE_DENIED",
                Self::SuiMoveVerificationTimedout => "SUI_MOVE_VERIFICATION_TIMEDOUT",
                Self::ConsensusObjectOperationNotAllowed => {
                    "CONSENSUS_OBJECT_OPERATION_NOT_ALLOWED"
                }
                Self::InputObjectDeleted => "INPUT_OBJECT_DELETED",
                Self::ExecutionCanceledDueToConsensusObjectCongestion => {
                    "EXECUTION_CANCELED_DUE_TO_CONSENSUS_OBJECT_CONGESTION"
                }
                Self::AddressDeniedForCoin => "ADDRESS_DENIED_FOR_COIN",
                Self::CoinTypeGlobalPause => "COIN_TYPE_GLOBAL_PAUSE",
                Self::ExecutionCanceledDueToRandomnessUnavailable => {
                    "EXECUTION_CANCELED_DUE_TO_RANDOMNESS_UNAVAILABLE"
                }
                Self::MoveVectorElemTooBig => "MOVE_VECTOR_ELEM_TOO_BIG",
                Self::MoveRawValueTooBig => "MOVE_RAW_VALUE_TOO_BIG",
                Self::InvalidLinkage => "INVALID_LINKAGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EXECUTION_ERROR_KIND_UNKNOWN" => Some(Self::Unknown),
                "INSUFFICIENT_GAS" => Some(Self::InsufficientGas),
                "INVALID_GAS_OBJECT" => Some(Self::InvalidGasObject),
                "INVARIANT_VIOLATION" => Some(Self::InvariantViolation),
                "FEATURE_NOT_YET_SUPPORTED" => Some(Self::FeatureNotYetSupported),
                "OBJECT_TOO_BIG" => Some(Self::ObjectTooBig),
                "PACKAGE_TOO_BIG" => Some(Self::PackageTooBig),
                "CIRCULAR_OBJECT_OWNERSHIP" => Some(Self::CircularObjectOwnership),
                "INSUFFICIENT_COIN_BALANCE" => Some(Self::InsufficientCoinBalance),
                "COIN_BALANCE_OVERFLOW" => Some(Self::CoinBalanceOverflow),
                "PUBLISH_ERROR_NON_ZERO_ADDRESS" => {
                    Some(Self::PublishErrorNonZeroAddress)
                }
                "SUI_MOVE_VERIFICATION_ERROR" => Some(Self::SuiMoveVerificationError),
                "MOVE_PRIMITIVE_RUNTIME_ERROR" => Some(Self::MovePrimitiveRuntimeError),
                "MOVE_ABORT" => Some(Self::MoveAbort),
                "VM_VERIFICATION_OR_DESERIALIZATION_ERROR" => {
                    Some(Self::VmVerificationOrDeserializationError)
                }
                "VM_INVARIANT_VIOLATION" => Some(Self::VmInvariantViolation),
                "FUNCTION_NOT_FOUND" => Some(Self::FunctionNotFound),
                "ARITY_MISMATCH" => Some(Self::ArityMismatch),
                "TYPE_ARITY_MISMATCH" => Some(Self::TypeArityMismatch),
                "NON_ENTRY_FUNCTION_INVOKED" => Some(Self::NonEntryFunctionInvoked),
                "COMMAND_ARGUMENT_ERROR" => Some(Self::CommandArgumentError),
                "TYPE_ARGUMENT_ERROR" => Some(Self::TypeArgumentError),
                "UNUSED_VALUE_WITHOUT_DROP" => Some(Self::UnusedValueWithoutDrop),
                "INVALID_PUBLIC_FUNCTION_RETURN_TYPE" => {
                    Some(Self::InvalidPublicFunctionReturnType)
                }
                "INVALID_TRANSFER_OBJECT" => Some(Self::InvalidTransferObject),
                "EFFECTS_TOO_LARGE" => Some(Self::EffectsTooLarge),
                "PUBLISH_UPGRADE_MISSING_DEPENDENCY" => {
                    Some(Self::PublishUpgradeMissingDependency)
                }
                "PUBLISH_UPGRADE_DEPENDENCY_DOWNGRADE" => {
                    Some(Self::PublishUpgradeDependencyDowngrade)
                }
                "PACKAGE_UPGRADE_ERROR" => Some(Self::PackageUpgradeError),
                "WRITTEN_OBJECTS_TOO_LARGE" => Some(Self::WrittenObjectsTooLarge),
                "CERTIFICATE_DENIED" => Some(Self::CertificateDenied),
                "SUI_MOVE_VERIFICATION_TIMEDOUT" => {
                    Some(Self::SuiMoveVerificationTimedout)
                }
                "CONSENSUS_OBJECT_OPERATION_NOT_ALLOWED" => {
                    Some(Self::ConsensusObjectOperationNotAllowed)
                }
                "INPUT_OBJECT_DELETED" => Some(Self::InputObjectDeleted),
                "EXECUTION_CANCELED_DUE_TO_CONSENSUS_OBJECT_CONGESTION" => {
                    Some(Self::ExecutionCanceledDueToConsensusObjectCongestion)
                }
                "ADDRESS_DENIED_FOR_COIN" => Some(Self::AddressDeniedForCoin),
                "COIN_TYPE_GLOBAL_PAUSE" => Some(Self::CoinTypeGlobalPause),
                "EXECUTION_CANCELED_DUE_TO_RANDOMNESS_UNAVAILABLE" => {
                    Some(Self::ExecutionCanceledDueToRandomnessUnavailable)
                }
                "MOVE_VECTOR_ELEM_TOO_BIG" => Some(Self::MoveVectorElemTooBig),
                "MOVE_RAW_VALUE_TOO_BIG" => Some(Self::MoveRawValueTooBig),
                "INVALID_LINKAGE" => Some(Self::InvalidLinkage),
                _ => None,
            }
        }
    }
    #[non_exhaustive]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ErrorDetails {
        #[prost(message, tag = "4")]
        Abort(super::MoveAbort),
        #[prost(message, tag = "5")]
        SizeError(super::SizeError),
        #[prost(message, tag = "6")]
        CommandArgumentError(super::CommandArgumentError),
        #[prost(message, tag = "7")]
        TypeArgumentError(super::TypeArgumentError),
        #[prost(message, tag = "8")]
        PackageUpgradeError(super::PackageUpgradeError),
        #[prost(message, tag = "9")]
        IndexError(super::IndexError),
        #[prost(string, tag = "10")]
        ObjectId(::prost::alloc::string::String),
        #[prost(message, tag = "11")]
        CoinDenyListError(super::CoinDenyListError),
        /// Set of objects that were congested, leading to the transaction's cancellation.
        #[prost(message, tag = "12")]
        CongestedObjects(super::CongestedObjects),
    }
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveAbort {
    #[prost(uint64, optional, tag = "1")]
    pub abort_code: ::core::option::Option<u64>,
    /// Location in Move where the error occurred.
    #[prost(message, optional, tag = "2")]
    pub location: ::core::option::Option<MoveLocation>,
    /// Extra error information if abort code is a "Clever Error"
    #[prost(message, optional, tag = "3")]
    pub clever_error: ::core::option::Option<CleverError>,
}
/// Location in Move bytecode where an error occurred.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveLocation {
    /// The package ID.
    #[prost(string, optional, tag = "1")]
    pub package: ::core::option::Option<::prost::alloc::string::String>,
    /// The module name.
    #[prost(string, optional, tag = "2")]
    pub module: ::core::option::Option<::prost::alloc::string::String>,
    /// The function index.
    #[prost(uint32, optional, tag = "3")]
    pub function: ::core::option::Option<u32>,
    /// Offset of the instruction where the error occurred.
    #[prost(uint32, optional, tag = "4")]
    pub instruction: ::core::option::Option<u32>,
    /// The name of the function, if available.
    #[prost(string, optional, tag = "5")]
    pub function_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CleverError {
    #[prost(uint64, optional, tag = "1")]
    pub error_code: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub line_number: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3")]
    pub constant_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub constant_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(oneof = "clever_error::Value", tags = "5, 6")]
    pub value: ::core::option::Option<clever_error::Value>,
}
/// Nested message and enum types in `CleverError`.
pub mod clever_error {
    #[non_exhaustive]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(string, tag = "5")]
        Rendered(::prost::alloc::string::String),
        #[prost(bytes, tag = "6")]
        Raw(::prost::bytes::Bytes),
    }
}
/// A size error.
#[non_exhaustive]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SizeError {
    /// The offending size.
    #[prost(uint64, optional, tag = "1")]
    pub size: ::core::option::Option<u64>,
    /// The maximum allowable size.
    #[prost(uint64, optional, tag = "2")]
    pub max_size: ::core::option::Option<u64>,
}
#[non_exhaustive]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IndexError {
    /// Index of an input or result.
    #[prost(uint32, optional, tag = "1")]
    pub index: ::core::option::Option<u32>,
    /// Index of a subresult.
    #[prost(uint32, optional, tag = "2")]
    pub subresult: ::core::option::Option<u32>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CoinDenyListError {
    /// Denied address.
    #[prost(string, optional, tag = "1")]
    pub address: ::core::option::Option<::prost::alloc::string::String>,
    /// Coin type.
    #[prost(string, optional, tag = "2")]
    pub coin_type: ::core::option::Option<::prost::alloc::string::String>,
}
/// Set of objects that were congested, leading to the transaction's cancellation.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CongestedObjects {
    #[prost(string, repeated, tag = "1")]
    pub objects: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// An error with an argument to a command.
#[non_exhaustive]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CommandArgumentError {
    /// Position of the problematic argument.
    #[prost(uint32, optional, tag = "1")]
    pub argument: ::core::option::Option<u32>,
    #[prost(
        enumeration = "command_argument_error::CommandArgumentErrorKind",
        optional,
        tag = "2"
    )]
    pub kind: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "3")]
    pub index_error: ::core::option::Option<IndexError>,
}
/// Nested message and enum types in `CommandArgumentError`.
pub mod command_argument_error {
    #[non_exhaustive]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CommandArgumentErrorKind {
        Unknown = 0,
        /// The type of the value does not match the expected type.
        TypeMismatch = 1,
        /// The argument cannot be deserialized into a value of the specified type.
        InvalidBcsBytes = 2,
        /// The argument cannot be instantiated from raw bytes.
        InvalidUsageOfPureArgument = 3,
        /// Invalid argument to private entry function.
        /// Private entry functions cannot take arguments from other Move functions.
        InvalidArgumentToPrivateEntryFunction = 4,
        /// Out of bounds access to input or results.
        ///
        /// `index` field will be set indicating the invalid index value.
        IndexOutOfBounds = 5,
        /// Out of bounds access to subresult.
        ///
        /// `index` and `subresult` fields will be set indicating the invalid index value.
        SecondaryIndexOutOfBounds = 6,
        /// Invalid usage of result.
        /// Expected a single result but found either no return value or multiple.
        /// `index` field will be set indicating the invalid index value.
        InvalidResultArity = 7,
        /// Invalid usage of gas coin.
        /// The gas coin can only be used by-value with a `TransferObject` command.
        InvalidGasCoinUsage = 8,
        /// Invalid usage of Move value.
        ///     - Mutably borrowed values require unique usage.
        ///     - Immutably borrowed values cannot be taken or borrowed mutably.
        ///     - Taken values cannot be used again.
        InvalidValueUsage = 9,
        /// Immutable objects cannot be passed by-value.
        InvalidObjectByValue = 10,
        /// Immutable objects cannot be passed by mutable reference, `&mut`.
        InvalidObjectByMutRef = 11,
        /// Consensus object operations such as wrapping, freezing, or converting to owned are not
        /// allowed.
        ConsensusObjectOperationNotAllowed = 12,
        /// Invalid argument arity. Expected a single argument but found a result that expanded to
        /// multiple arguments.
        InvalidArgumentArity = 13,
    }
    impl CommandArgumentErrorKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "COMMAND_ARGUMENT_ERROR_KIND_UNKNOWN",
                Self::TypeMismatch => "TYPE_MISMATCH",
                Self::InvalidBcsBytes => "INVALID_BCS_BYTES",
                Self::InvalidUsageOfPureArgument => "INVALID_USAGE_OF_PURE_ARGUMENT",
                Self::InvalidArgumentToPrivateEntryFunction => {
                    "INVALID_ARGUMENT_TO_PRIVATE_ENTRY_FUNCTION"
                }
                Self::IndexOutOfBounds => "INDEX_OUT_OF_BOUNDS",
                Self::SecondaryIndexOutOfBounds => "SECONDARY_INDEX_OUT_OF_BOUNDS",
                Self::InvalidResultArity => "INVALID_RESULT_ARITY",
                Self::InvalidGasCoinUsage => "INVALID_GAS_COIN_USAGE",
                Self::InvalidValueUsage => "INVALID_VALUE_USAGE",
                Self::InvalidObjectByValue => "INVALID_OBJECT_BY_VALUE",
                Self::InvalidObjectByMutRef => "INVALID_OBJECT_BY_MUT_REF",
                Self::ConsensusObjectOperationNotAllowed => {
                    "CONSENSUS_OBJECT_OPERATION_NOT_ALLOWED"
                }
                Self::InvalidArgumentArity => "INVALID_ARGUMENT_ARITY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COMMAND_ARGUMENT_ERROR_KIND_UNKNOWN" => Some(Self::Unknown),
                "TYPE_MISMATCH" => Some(Self::TypeMismatch),
                "INVALID_BCS_BYTES" => Some(Self::InvalidBcsBytes),
                "INVALID_USAGE_OF_PURE_ARGUMENT" => {
                    Some(Self::InvalidUsageOfPureArgument)
                }
                "INVALID_ARGUMENT_TO_PRIVATE_ENTRY_FUNCTION" => {
                    Some(Self::InvalidArgumentToPrivateEntryFunction)
                }
                "INDEX_OUT_OF_BOUNDS" => Some(Self::IndexOutOfBounds),
                "SECONDARY_INDEX_OUT_OF_BOUNDS" => Some(Self::SecondaryIndexOutOfBounds),
                "INVALID_RESULT_ARITY" => Some(Self::InvalidResultArity),
                "INVALID_GAS_COIN_USAGE" => Some(Self::InvalidGasCoinUsage),
                "INVALID_VALUE_USAGE" => Some(Self::InvalidValueUsage),
                "INVALID_OBJECT_BY_VALUE" => Some(Self::InvalidObjectByValue),
                "INVALID_OBJECT_BY_MUT_REF" => Some(Self::InvalidObjectByMutRef),
                "CONSENSUS_OBJECT_OPERATION_NOT_ALLOWED" => {
                    Some(Self::ConsensusObjectOperationNotAllowed)
                }
                "INVALID_ARGUMENT_ARITY" => Some(Self::InvalidArgumentArity),
                _ => None,
            }
        }
    }
}
/// An error with upgrading a package.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PackageUpgradeError {
    #[prost(
        enumeration = "package_upgrade_error::PackageUpgradeErrorKind",
        optional,
        tag = "1"
    )]
    pub kind: ::core::option::Option<i32>,
    /// The Package Id.
    #[prost(string, optional, tag = "2")]
    pub package_id: ::core::option::Option<::prost::alloc::string::String>,
    /// A digest.
    #[prost(string, optional, tag = "3")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// The policy.
    #[prost(uint32, optional, tag = "4")]
    pub policy: ::core::option::Option<u32>,
    /// The ticket Id.
    #[prost(string, optional, tag = "5")]
    pub ticket_id: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `PackageUpgradeError`.
pub mod package_upgrade_error {
    #[non_exhaustive]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PackageUpgradeErrorKind {
        Unknown = 0,
        /// Unable to fetch package.
        UnableToFetchPackage = 1,
        /// Object is not a package.
        NotAPackage = 2,
        /// Package upgrade is incompatible with previous version.
        IncompatibleUpgrade = 3,
        /// Digest in upgrade ticket and computed digest differ.
        DigestDoesNotMatch = 4,
        /// Upgrade policy is not valid.
        UnknownUpgradePolicy = 5,
        /// Package ID does not match `PackageId` in upgrade ticket.
        PackageIdDoesNotMatch = 6,
    }
    impl PackageUpgradeErrorKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "PACKAGE_UPGRADE_ERROR_KIND_UNKNOWN",
                Self::UnableToFetchPackage => "UNABLE_TO_FETCH_PACKAGE",
                Self::NotAPackage => "NOT_A_PACKAGE",
                Self::IncompatibleUpgrade => "INCOMPATIBLE_UPGRADE",
                Self::DigestDoesNotMatch => "DIGEST_DOES_NOT_MATCH",
                Self::UnknownUpgradePolicy => "UNKNOWN_UPGRADE_POLICY",
                Self::PackageIdDoesNotMatch => "PACKAGE_ID_DOES_NOT_MATCH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PACKAGE_UPGRADE_ERROR_KIND_UNKNOWN" => Some(Self::Unknown),
                "UNABLE_TO_FETCH_PACKAGE" => Some(Self::UnableToFetchPackage),
                "NOT_A_PACKAGE" => Some(Self::NotAPackage),
                "INCOMPATIBLE_UPGRADE" => Some(Self::IncompatibleUpgrade),
                "DIGEST_DOES_NOT_MATCH" => Some(Self::DigestDoesNotMatch),
                "UNKNOWN_UPGRADE_POLICY" => Some(Self::UnknownUpgradePolicy),
                "PACKAGE_ID_DOES_NOT_MATCH" => Some(Self::PackageIdDoesNotMatch),
                _ => None,
            }
        }
    }
}
/// Type argument error.
#[non_exhaustive]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TypeArgumentError {
    /// Index of the problematic type argument.
    #[prost(uint32, optional, tag = "1")]
    pub type_argument: ::core::option::Option<u32>,
    #[prost(
        enumeration = "type_argument_error::TypeArgumentErrorKind",
        optional,
        tag = "2"
    )]
    pub kind: ::core::option::Option<i32>,
}
/// Nested message and enum types in `TypeArgumentError`.
pub mod type_argument_error {
    #[non_exhaustive]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TypeArgumentErrorKind {
        Unknown = 0,
        /// A type was not found in the module specified.
        TypeNotFound = 1,
        /// A type provided did not match the specified constraint.
        ConstraintNotSatisfied = 2,
    }
    impl TypeArgumentErrorKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "TYPE_ARGUMENT_ERROR_KIND_UNKNOWN",
                Self::TypeNotFound => "TYPE_NOT_FOUND",
                Self::ConstraintNotSatisfied => "CONSTRAINT_NOT_SATISFIED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_ARGUMENT_ERROR_KIND_UNKNOWN" => Some(Self::Unknown),
                "TYPE_NOT_FOUND" => Some(Self::TypeNotFound),
                "CONSTRAINT_NOT_SATISFIED" => Some(Self::ConstraintNotSatisfied),
                _ => None,
            }
        }
    }
}
/// Summary of gas charges.
#[non_exhaustive]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GasCostSummary {
    /// Cost of computation/execution.
    #[prost(uint64, optional, tag = "1")]
    pub computation_cost: ::core::option::Option<u64>,
    /// Storage cost, it's the sum of all storage cost for all objects created or mutated.
    #[prost(uint64, optional, tag = "2")]
    pub storage_cost: ::core::option::Option<u64>,
    /// The amount of storage cost refunded to the user for all objects deleted or mutated in the
    /// transaction.
    #[prost(uint64, optional, tag = "3")]
    pub storage_rebate: ::core::option::Option<u64>,
    /// The fee for the rebate. The portion of the storage rebate kept by the system.
    #[prost(uint64, optional, tag = "4")]
    pub non_refundable_storage_fee: ::core::option::Option<u64>,
}
/// An input to a user transaction.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Input {
    #[prost(enumeration = "input::InputKind", optional, tag = "1")]
    pub kind: ::core::option::Option<i32>,
    /// A move value serialized as BCS.
    ///
    /// For normal operations this is required to be a move primitive type and not contain structs
    /// or objects.
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub pure: ::core::option::Option<::prost::bytes::Bytes>,
    /// `ObjectId` of the object input.
    #[prost(string, optional, tag = "3")]
    pub object_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Requested version of the input object when `kind` is `IMMUTABLE_OR_OWNED`
    /// or `RECEIVING` or if `kind` is `SHARED` this is the initial version of the
    /// object when it was shared
    #[prost(uint64, optional, tag = "4")]
    pub version: ::core::option::Option<u64>,
    /// The digest of this object.
    #[prost(string, optional, tag = "5")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Controls whether the caller asks for a mutable reference to the shared
    /// object.
    #[prost(bool, optional, tag = "6")]
    pub mutable: ::core::option::Option<bool>,
    /// A literal value
    ///
    /// INPUT ONLY
    #[prost(message, optional, boxed, tag = "1000")]
    pub literal: ::core::option::Option<
        ::prost::alloc::boxed::Box<::prost_types::Value>,
    >,
}
/// Nested message and enum types in `Input`.
pub mod input {
    #[non_exhaustive]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InputKind {
        Unknown = 0,
        /// A move value serialized as BCS.
        Pure = 1,
        /// A Move object that is either immutable or address owned.
        ImmutableOrOwned = 2,
        /// A Move object whose owner is "Shared".
        Shared = 3,
        /// A Move object that is attempted to be received in this transaction.
        Receiving = 4,
    }
    impl InputKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "INPUT_KIND_UNKNOWN",
                Self::Pure => "PURE",
                Self::ImmutableOrOwned => "IMMUTABLE_OR_OWNED",
                Self::Shared => "SHARED",
                Self::Receiving => "RECEIVING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INPUT_KIND_UNKNOWN" => Some(Self::Unknown),
                "PURE" => Some(Self::Pure),
                "IMMUTABLE_OR_OWNED" => Some(Self::ImmutableOrOwned),
                "SHARED" => Some(Self::Shared),
                "RECEIVING" => Some(Self::Receiving),
                _ => None,
            }
        }
    }
}
/// A Move Package
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Package {
    /// The PackageId of this package
    ///
    /// A package's `storage_id` is the Sui ObjectId of the package on-chain.
    /// Outside of system packages the `storage_id` for every package version is
    /// different.
    #[prost(string, optional, tag = "1")]
    pub storage_id: ::core::option::Option<::prost::alloc::string::String>,
    /// The PackageId of the first published version of this package.
    ///
    /// A package's `original_id` (sometimes also called its `runtime_id`) is the
    /// `storage_id` of the first version of this package that has been published.
    /// The `original_id`/`runtime_id` is stable across all versions of the
    /// package and does not ever change.
    #[prost(string, optional, tag = "2")]
    pub original_id: ::core::option::Option<::prost::alloc::string::String>,
    /// The version of this package
    #[prost(uint64, optional, tag = "3")]
    pub version: ::core::option::Option<u64>,
    /// The modules defined by this package
    #[prost(message, repeated, tag = "4")]
    pub modules: ::prost::alloc::vec::Vec<Module>,
    /// List of datatype origins for mapping datatypes to a package version where
    /// it was first defined
    #[prost(message, repeated, tag = "5")]
    pub type_origins: ::prost::alloc::vec::Vec<TypeOrigin>,
    /// The package's transitive dependencies as a mapping from the package's
    /// runtime Id (the Id it is referred to by in other packages) to its
    /// storage Id (the Id it is loaded from on chain).
    #[prost(message, repeated, tag = "6")]
    pub linkage: ::prost::alloc::vec::Vec<Linkage>,
}
/// A Move Module.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Module {
    /// Name of this module.
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// Serialized bytecode of the module.
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub contents: ::core::option::Option<::prost::bytes::Bytes>,
    /// List of DataTypes defined by this module.
    #[prost(message, repeated, tag = "3")]
    pub datatypes: ::prost::alloc::vec::Vec<DatatypeDescriptor>,
    /// List of Functions defined by this module.
    #[prost(message, repeated, tag = "4")]
    pub functions: ::prost::alloc::vec::Vec<FunctionDescriptor>,
}
/// Describes a Move Datatype.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatatypeDescriptor {
    /// Fully qualified name of this Datatype.
    ///
    /// This is `<defining_id>::<module>::<name>`
    #[prost(string, optional, tag = "1")]
    pub type_name: ::core::option::Option<::prost::alloc::string::String>,
    /// PackageId of the package where this Datatype is defined.
    ///
    /// A type's `defining_id` is the `storage_id` of the package version that first introduced or added that type.
    #[prost(string, optional, tag = "2")]
    pub defining_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Name of the module where this Datatype is defined
    #[prost(string, optional, tag = "3")]
    pub module: ::core::option::Option<::prost::alloc::string::String>,
    /// Name of this Datatype
    #[prost(string, optional, tag = "4")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// This type's abilities
    #[prost(enumeration = "Ability", repeated, tag = "5")]
    pub abilities: ::prost::alloc::vec::Vec<i32>,
    /// Ability constraints and phantom status for this type's generic type parameters
    #[prost(message, repeated, tag = "6")]
    pub type_parameters: ::prost::alloc::vec::Vec<TypeParameter>,
    /// Indicates whether this datatype is a 'STRUCT' or an 'ENUM'
    #[prost(enumeration = "datatype_descriptor::DatatypeKind", optional, tag = "7")]
    pub kind: ::core::option::Option<i32>,
    /// Set of fields if this Datatype is a struct.
    ///
    /// The order of the entries is the order of how the fields are defined.
    #[prost(message, repeated, tag = "8")]
    pub fields: ::prost::alloc::vec::Vec<FieldDescriptor>,
    /// Set of variants if this Datatype is an enum.
    ///
    /// The order of the entries is the order of how the variants are defined.
    #[prost(message, repeated, tag = "9")]
    pub variants: ::prost::alloc::vec::Vec<VariantDescriptor>,
}
/// Nested message and enum types in `DatatypeDescriptor`.
pub mod datatype_descriptor {
    #[non_exhaustive]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DatatypeKind {
        Unknown = 0,
        Struct = 1,
        Enum = 2,
    }
    impl DatatypeKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "DATATYPE_KIND_UNKNOWN",
                Self::Struct => "STRUCT",
                Self::Enum => "ENUM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DATATYPE_KIND_UNKNOWN" => Some(Self::Unknown),
                "STRUCT" => Some(Self::Struct),
                "ENUM" => Some(Self::Enum),
                _ => None,
            }
        }
    }
}
/// A generic type parameter used in the declaration of a struct or enum.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TypeParameter {
    /// The type parameter constraints
    #[prost(enumeration = "Ability", repeated, tag = "1")]
    pub constraints: ::prost::alloc::vec::Vec<i32>,
    /// Whether the parameter is declared as phantom
    #[prost(bool, optional, tag = "2")]
    pub is_phantom: ::core::option::Option<bool>,
}
/// Descriptor of a field that belongs to a struct or enum variant
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FieldDescriptor {
    /// Name of the field
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// Order or position of the field in the struct or enum variant definition.
    #[prost(uint32, optional, tag = "2")]
    pub position: ::core::option::Option<u32>,
    /// The type of the field
    #[prost(message, optional, tag = "3")]
    pub r#type: ::core::option::Option<OpenSignatureBody>,
}
/// Descriptor of an enum variant
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VariantDescriptor {
    /// Name of the variant
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// Order or position of the variant in the enum definition.
    #[prost(uint32, optional, tag = "2")]
    pub position: ::core::option::Option<u32>,
    /// Set of fields defined by this variant.
    #[prost(message, repeated, tag = "3")]
    pub fields: ::prost::alloc::vec::Vec<FieldDescriptor>,
}
/// Representation of a type signature that could appear as a field type for a struct or enum
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpenSignatureBody {
    /// Type of this signature
    #[prost(enumeration = "open_signature_body::Type", optional, tag = "1")]
    pub r#type: ::core::option::Option<i32>,
    /// Fully qualified name of the datatype when `type` is `DATATYPE`
    #[prost(string, optional, tag = "2")]
    pub type_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Set when `type` is `VECTOR` or `DATATYPE`
    #[prost(message, repeated, tag = "3")]
    pub type_parameter_instantiation: ::prost::alloc::vec::Vec<OpenSignatureBody>,
    /// Position of the type parameter as defined in the containing data type descriptor when `type` is `TYPE_PARAMETER`
    #[prost(uint32, optional, tag = "4")]
    pub type_parameter: ::core::option::Option<u32>,
}
/// Nested message and enum types in `OpenSignatureBody`.
pub mod open_signature_body {
    #[non_exhaustive]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unknown = 0,
        Address = 1,
        Bool = 2,
        U8 = 3,
        U16 = 4,
        U32 = 5,
        U64 = 6,
        U128 = 7,
        U256 = 8,
        Vector = 9,
        Datatype = 10,
        Parameter = 11,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "TYPE_UNKNOWN",
                Self::Address => "ADDRESS",
                Self::Bool => "BOOL",
                Self::U8 => "U8",
                Self::U16 => "U16",
                Self::U32 => "U32",
                Self::U64 => "U64",
                Self::U128 => "U128",
                Self::U256 => "U256",
                Self::Vector => "VECTOR",
                Self::Datatype => "DATATYPE",
                Self::Parameter => "TYPE_PARAMETER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNKNOWN" => Some(Self::Unknown),
                "ADDRESS" => Some(Self::Address),
                "BOOL" => Some(Self::Bool),
                "U8" => Some(Self::U8),
                "U16" => Some(Self::U16),
                "U32" => Some(Self::U32),
                "U64" => Some(Self::U64),
                "U128" => Some(Self::U128),
                "U256" => Some(Self::U256),
                "VECTOR" => Some(Self::Vector),
                "DATATYPE" => Some(Self::Datatype),
                "TYPE_PARAMETER" => Some(Self::Parameter),
                _ => None,
            }
        }
    }
}
/// Descriptor of a Move function
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FunctionDescriptor {
    /// Name of the function
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// Whether the function is `public`, `private` or `public(friend)`
    #[prost(enumeration = "function_descriptor::Visibility", optional, tag = "5")]
    pub visibility: ::core::option::Option<i32>,
    /// Whether the function is marked `entry` or not.
    #[prost(bool, optional, tag = "6")]
    pub is_entry: ::core::option::Option<bool>,
    /// Ability constraints for type parameters
    #[prost(message, repeated, tag = "7")]
    pub type_parameters: ::prost::alloc::vec::Vec<TypeParameter>,
    /// Formal parameter types.
    #[prost(message, repeated, tag = "8")]
    pub parameters: ::prost::alloc::vec::Vec<OpenSignature>,
    /// Return types.
    #[prost(message, repeated, tag = "9")]
    pub returns: ::prost::alloc::vec::Vec<OpenSignature>,
}
/// Nested message and enum types in `FunctionDescriptor`.
pub mod function_descriptor {
    #[non_exhaustive]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Visibility {
        Unknown = 0,
        Private = 1,
        Public = 2,
        Friend = 3,
    }
    impl Visibility {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "VISIBILITY_UNKNOWN",
                Self::Private => "PRIVATE",
                Self::Public => "PUBLIC",
                Self::Friend => "FRIEND",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "VISIBILITY_UNKNOWN" => Some(Self::Unknown),
                "PRIVATE" => Some(Self::Private),
                "PUBLIC" => Some(Self::Public),
                "FRIEND" => Some(Self::Friend),
                _ => None,
            }
        }
    }
}
/// Representation of a type signature that could appear as a function parameter or return value.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpenSignature {
    #[prost(enumeration = "open_signature::Reference", optional, tag = "1")]
    pub reference: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<OpenSignatureBody>,
}
/// Nested message and enum types in `OpenSignature`.
pub mod open_signature {
    #[non_exhaustive]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Reference {
        Unknown = 0,
        Immutable = 1,
        Mutable = 2,
    }
    impl Reference {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "REFERENCE_UNKNOWN",
                Self::Immutable => "IMMUTABLE",
                Self::Mutable => "MUTABLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REFERENCE_UNKNOWN" => Some(Self::Unknown),
                "IMMUTABLE" => Some(Self::Immutable),
                "MUTABLE" => Some(Self::Mutable),
                _ => None,
            }
        }
    }
}
/// Identifies a struct and the module it was defined in.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TypeOrigin {
    #[prost(string, optional, tag = "1")]
    pub module_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub datatype_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub package_id: ::core::option::Option<::prost::alloc::string::String>,
}
/// Upgraded package info for the linkage table.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Linkage {
    /// Id of the original package.
    #[prost(string, optional, tag = "1")]
    pub original_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Id of the upgraded package.
    #[prost(string, optional, tag = "2")]
    pub upgraded_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Version of the upgraded package.
    #[prost(uint64, optional, tag = "3")]
    pub upgraded_version: ::core::option::Option<u64>,
}
/// An `Ability` classifies what operations are permitted for a given type
#[non_exhaustive]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Ability {
    Unknown = 0,
    /// Allows values of types with this ability to be copied
    Copy = 1,
    /// Allows values of types with this ability to be dropped.
    Drop = 2,
    /// Allows values of types with this ability to exist inside a struct in global storage
    Store = 3,
    /// Allows the type to serve as a key for global storage operations
    Key = 4,
}
impl Ability {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "ABILITY_UNKNOWN",
            Self::Copy => "COPY",
            Self::Drop => "DROP",
            Self::Store => "STORE",
            Self::Key => "KEY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ABILITY_UNKNOWN" => Some(Self::Unknown),
            "COPY" => Some(Self::Copy),
            "DROP" => Some(Self::Drop),
            "STORE" => Some(Self::Store),
            "KEY" => Some(Self::Key),
            _ => None,
        }
    }
}
/// An object on the Sui blockchain.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Object {
    /// This Object serialized as BCS.
    #[prost(message, optional, tag = "1")]
    pub bcs: ::core::option::Option<Bcs>,
    /// `ObjectId` for this object.
    #[prost(string, optional, tag = "2")]
    pub object_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Version of the object.
    #[prost(uint64, optional, tag = "3")]
    pub version: ::core::option::Option<u64>,
    /// The digest of this Object.
    #[prost(string, optional, tag = "4")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Owner of the object.
    #[prost(message, optional, tag = "5")]
    pub owner: ::core::option::Option<Owner>,
    /// The type of this object.
    ///
    /// This will be 'package' for packages and a StructTag for move structs.
    #[prost(string, optional, tag = "6")]
    pub object_type: ::core::option::Option<::prost::alloc::string::String>,
    /// DEPRECATED this field is no longer used to determine whether a tx can transfer this
    /// object. Instead, it is always calculated from the objects type when loaded in execution.
    ///
    /// Only set for Move structs
    #[prost(bool, optional, tag = "7")]
    pub has_public_transfer: ::core::option::Option<bool>,
    /// BCS bytes of a Move struct value.
    ///
    /// Only set for Move structs
    #[prost(message, optional, tag = "8")]
    pub contents: ::core::option::Option<Bcs>,
    /// Package information for Move Packages
    #[prost(message, optional, tag = "9")]
    pub package: ::core::option::Option<Package>,
    /// The digest of the transaction that created or last mutated this object
    #[prost(string, optional, tag = "10")]
    pub previous_transaction: ::core::option::Option<::prost::alloc::string::String>,
    /// The amount of SUI to rebate if this object gets deleted.
    /// This number is re-calculated each time the object is mutated based on
    /// the present storage gas price.
    #[prost(uint64, optional, tag = "11")]
    pub storage_rebate: ::core::option::Option<u64>,
    /// JSON rendering of the object.
    #[prost(message, optional, boxed, tag = "100")]
    pub json: ::core::option::Option<::prost::alloc::boxed::Box<::prost_types::Value>>,
    /// Current balance if this object is a `0x2::coin::Coin<T>`
    #[prost(uint64, optional, tag = "101")]
    pub balance: ::core::option::Option<u64>,
}
/// Reference to an object.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectReference {
    /// The object id of this object.
    #[prost(string, optional, tag = "1")]
    pub object_id: ::core::option::Option<::prost::alloc::string::String>,
    /// The version of this object.
    #[prost(uint64, optional, tag = "2")]
    pub version: ::core::option::Option<u64>,
    /// The digest of this object.
    #[prost(string, optional, tag = "3")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
}
/// Enum of different types of ownership for an object.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Owner {
    #[prost(enumeration = "owner::OwnerKind", optional, tag = "1")]
    pub kind: ::core::option::Option<i32>,
    /// Address or ObjectId of the owner
    #[prost(string, optional, tag = "2")]
    pub address: ::core::option::Option<::prost::alloc::string::String>,
    /// The `initial_shared_version` if kind is `SHARED` or `start_version` if kind `CONSENSUS_ADDRESS`.
    #[prost(uint64, optional, tag = "3")]
    pub version: ::core::option::Option<u64>,
}
/// Nested message and enum types in `Owner`.
pub mod owner {
    #[non_exhaustive]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OwnerKind {
        Unknown = 0,
        Address = 1,
        Object = 2,
        Shared = 3,
        Immutable = 4,
        ConsensusAddress = 5,
    }
    impl OwnerKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "OWNER_KIND_UNKNOWN",
                Self::Address => "ADDRESS",
                Self::Object => "OBJECT",
                Self::Shared => "SHARED",
                Self::Immutable => "IMMUTABLE",
                Self::ConsensusAddress => "CONSENSUS_ADDRESS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OWNER_KIND_UNKNOWN" => Some(Self::Unknown),
                "ADDRESS" => Some(Self::Address),
                "OBJECT" => Some(Self::Object),
                "SHARED" => Some(Self::Shared),
                "IMMUTABLE" => Some(Self::Immutable),
                "CONSENSUS_ADDRESS" => Some(Self::ConsensusAddress),
                _ => None,
            }
        }
    }
}
/// A signature from a user.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserSignature {
    /// This signature serialized as as BCS.
    ///
    /// When provided as input this will support both the form that is length
    /// prefixed as well as not length prefixed.
    #[prost(message, optional, tag = "1")]
    pub bcs: ::core::option::Option<Bcs>,
    /// The signature scheme of this signature.
    #[prost(enumeration = "SignatureScheme", optional, tag = "2")]
    pub scheme: ::core::option::Option<i32>,
    #[prost(oneof = "user_signature::Signature", tags = "3, 4, 5, 6")]
    pub signature: ::core::option::Option<user_signature::Signature>,
}
/// Nested message and enum types in `UserSignature`.
pub mod user_signature {
    #[non_exhaustive]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Signature {
        /// Simple signature if scheme is ed25519 | secp256k1 | secp256r1.
        #[prost(message, tag = "3")]
        Simple(super::SimpleSignature),
        /// The multisig aggregated signature if scheme is `MULTISIG`.
        #[prost(message, tag = "4")]
        Multisig(super::MultisigAggregatedSignature),
        /// The zklogin authenticator if scheme is `ZKLOGIN`.
        #[prost(message, tag = "5")]
        Zklogin(super::ZkLoginAuthenticator),
        /// The passkey authenticator if scheme is `PASSKEY`.
        #[prost(message, tag = "6")]
        Passkey(super::PasskeyAuthenticator),
    }
}
/// Either an ed25519, secp256k1 or secp256r1 signature
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SimpleSignature {
    /// The signature scheme of this signature.
    #[prost(enumeration = "SignatureScheme", optional, tag = "1")]
    pub scheme: ::core::option::Option<i32>,
    /// Signature bytes
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub signature: ::core::option::Option<::prost::bytes::Bytes>,
    /// Public key bytes
    #[prost(bytes = "bytes", optional, tag = "3")]
    pub public_key: ::core::option::Option<::prost::bytes::Bytes>,
}
/// Public key equivalent for zklogin authenticators.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZkLoginPublicIdentifier {
    #[prost(string, optional, tag = "1")]
    pub iss: ::core::option::Option<::prost::alloc::string::String>,
    /// base10 encoded Bn254FieldElement
    #[prost(string, optional, tag = "2")]
    pub address_seed: ::core::option::Option<::prost::alloc::string::String>,
}
/// Set of valid public keys for multisig committee members.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultisigMemberPublicKey {
    /// The signature scheme of this public key.
    #[prost(enumeration = "SignatureScheme", optional, tag = "1")]
    pub scheme: ::core::option::Option<i32>,
    /// Public key bytes if scheme is ed25519 | secp256k1 | secp256r1 | passkey.
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub public_key: ::core::option::Option<::prost::bytes::Bytes>,
    /// A zklogin public identifier if scheme is zklogin.
    #[prost(message, optional, tag = "3")]
    pub zklogin: ::core::option::Option<ZkLoginPublicIdentifier>,
}
/// A member in a multisig committee.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultisigMember {
    /// The public key of the committee member.
    #[prost(message, optional, tag = "1")]
    pub public_key: ::core::option::Option<MultisigMemberPublicKey>,
    /// The weight of this member's signature.
    #[prost(uint32, optional, tag = "2")]
    pub weight: ::core::option::Option<u32>,
}
/// A multisig committee.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultisigCommittee {
    /// A list of committee members and their corresponding weight.
    #[prost(message, repeated, tag = "1")]
    pub members: ::prost::alloc::vec::Vec<MultisigMember>,
    /// The threshold of signatures needed to validate a signature from
    /// this committee.
    #[prost(uint32, optional, tag = "2")]
    pub threshold: ::core::option::Option<u32>,
}
/// Aggregated signature from members of a multisig committee.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultisigAggregatedSignature {
    /// The plain signatures encoded with signature scheme.
    ///
    /// The signatures must be in the same order as they are listed in the committee.
    #[prost(message, repeated, tag = "1")]
    pub signatures: ::prost::alloc::vec::Vec<MultisigMemberSignature>,
    /// Bitmap indicating which committee members contributed to the
    /// signature.
    #[prost(uint32, optional, tag = "2")]
    pub bitmap: ::core::option::Option<u32>,
    /// If present, means this signature's on-chain format uses the old
    /// legacy multisig format.
    #[prost(uint32, repeated, tag = "3")]
    pub legacy_bitmap: ::prost::alloc::vec::Vec<u32>,
    /// The committee to use to validate this signature.
    #[prost(message, optional, tag = "4")]
    pub committee: ::core::option::Option<MultisigCommittee>,
}
/// A signature from a member of a multisig committee.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultisigMemberSignature {
    /// The signature scheme of this signature.
    #[prost(enumeration = "SignatureScheme", optional, tag = "1")]
    pub scheme: ::core::option::Option<i32>,
    /// Signature bytes if scheme is ed25519 | secp256k1 | secp256r1.
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub signature: ::core::option::Option<::prost::bytes::Bytes>,
    /// The zklogin authenticator if scheme is `ZKLOGIN`.
    #[prost(message, optional, tag = "3")]
    pub zklogin: ::core::option::Option<ZkLoginAuthenticator>,
    /// The passkey authenticator if scheme is `PASSKEY`.
    #[prost(message, optional, tag = "4")]
    pub passkey: ::core::option::Option<PasskeyAuthenticator>,
}
/// A zklogin authenticator.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZkLoginAuthenticator {
    /// Zklogin proof and inputs required to perform proof verification.
    #[prost(message, optional, tag = "1")]
    pub inputs: ::core::option::Option<ZkLoginInputs>,
    /// Maximum epoch for which the proof is valid.
    #[prost(uint64, optional, tag = "2")]
    pub max_epoch: ::core::option::Option<u64>,
    /// User signature with the public key attested to by the provided proof.
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<SimpleSignature>,
}
/// A zklogin groth16 proof and the required inputs to perform proof verification.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZkLoginInputs {
    #[prost(message, optional, tag = "1")]
    pub proof_points: ::core::option::Option<ZkLoginProof>,
    #[prost(message, optional, tag = "2")]
    pub iss_base64_details: ::core::option::Option<ZkLoginClaim>,
    #[prost(string, optional, tag = "3")]
    pub header_base64: ::core::option::Option<::prost::alloc::string::String>,
    /// base10 encoded Bn254FieldElement
    #[prost(string, optional, tag = "4")]
    pub address_seed: ::core::option::Option<::prost::alloc::string::String>,
}
/// A zklogin groth16 proof.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZkLoginProof {
    #[prost(message, optional, tag = "1")]
    pub a: ::core::option::Option<CircomG1>,
    #[prost(message, optional, tag = "2")]
    pub b: ::core::option::Option<CircomG2>,
    #[prost(message, optional, tag = "3")]
    pub c: ::core::option::Option<CircomG1>,
}
/// A claim of the iss in a zklogin proof.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZkLoginClaim {
    #[prost(string, optional, tag = "1")]
    pub value: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "2")]
    pub index_mod_4: ::core::option::Option<u32>,
}
/// A G1 point.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CircomG1 {
    /// base10 encoded Bn254FieldElement
    #[prost(string, optional, tag = "1")]
    pub e0: ::core::option::Option<::prost::alloc::string::String>,
    /// base10 encoded Bn254FieldElement
    #[prost(string, optional, tag = "2")]
    pub e1: ::core::option::Option<::prost::alloc::string::String>,
    /// base10 encoded Bn254FieldElement
    #[prost(string, optional, tag = "3")]
    pub e2: ::core::option::Option<::prost::alloc::string::String>,
}
/// A G2 point.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CircomG2 {
    /// base10 encoded Bn254FieldElement
    #[prost(string, optional, tag = "1")]
    pub e00: ::core::option::Option<::prost::alloc::string::String>,
    /// base10 encoded Bn254FieldElement
    #[prost(string, optional, tag = "2")]
    pub e01: ::core::option::Option<::prost::alloc::string::String>,
    /// base10 encoded Bn254FieldElement
    #[prost(string, optional, tag = "3")]
    pub e10: ::core::option::Option<::prost::alloc::string::String>,
    /// base10 encoded Bn254FieldElement
    #[prost(string, optional, tag = "4")]
    pub e11: ::core::option::Option<::prost::alloc::string::String>,
    /// base10 encoded Bn254FieldElement
    #[prost(string, optional, tag = "5")]
    pub e20: ::core::option::Option<::prost::alloc::string::String>,
    /// base10 encoded Bn254FieldElement
    #[prost(string, optional, tag = "6")]
    pub e21: ::core::option::Option<::prost::alloc::string::String>,
}
/// A passkey authenticator.
///
/// See
/// [struct.PasskeyAuthenticator](<https://mystenlabs.github.io/sui-rust-sdk/sui_sdk_types/struct.PasskeyAuthenticator.html#bcs>)
/// for more information on the requirements on the shape of the
/// `client_data_json` field.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PasskeyAuthenticator {
    /// Opaque authenticator data for this passkey signature.
    ///
    /// See [Authenticator Data](<https://www.w3.org/TR/webauthn-2/#sctn-authenticator-data>) for
    /// more information on this field.
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub authenticator_data: ::core::option::Option<::prost::bytes::Bytes>,
    /// Structured, unparsed, JSON for this passkey signature.
    ///
    /// See [CollectedClientData](<https://www.w3.org/TR/webauthn-2/#dictdef-collectedclientdata>)
    /// for more information on this field.
    #[prost(string, optional, tag = "2")]
    pub client_data_json: ::core::option::Option<::prost::alloc::string::String>,
    /// A secp256r1 signature.
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<SimpleSignature>,
}
/// The validator set for a particular epoch.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatorCommittee {
    /// The epoch where this committee governs.
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    /// The committee members.
    #[prost(message, repeated, tag = "2")]
    pub members: ::prost::alloc::vec::Vec<ValidatorCommitteeMember>,
}
/// A member of a validator committee.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatorCommitteeMember {
    /// The 96-byte Bls12381 public key for this validator.
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub public_key: ::core::option::Option<::prost::bytes::Bytes>,
    /// voting weight this validator possesses.
    #[prost(uint64, optional, tag = "2")]
    pub weight: ::core::option::Option<u64>,
}
/// / An aggregated signature from multiple validators.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatorAggregatedSignature {
    /// The epoch when this signature was produced.
    ///
    /// This can be used to lookup the `ValidatorCommittee` from this epoch
    /// to verify this signature.
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    /// The 48-byte Bls12381 aggregated signature.
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub signature: ::core::option::Option<::prost::bytes::Bytes>,
    /// Bitmap indicating which members of the committee contributed to
    /// this signature.
    #[prost(uint32, repeated, tag = "3")]
    pub bitmap: ::prost::alloc::vec::Vec<u32>,
}
/// Flag use to disambiguate the signature schemes supported by Soma.
///
/// Note: the enum values defined by this proto message exactly match their
/// expected BCS serialized values when serialized as a u8.
#[non_exhaustive]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SignatureScheme {
    Ed25519 = 0,
    Secp256k1 = 1,
    Secp256r1 = 2,
    Multisig = 3,
    Bls12381 = 4,
    Zklogin = 5,
    Passkey = 6,
}
impl SignatureScheme {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Ed25519 => "ED25519",
            Self::Secp256k1 => "SECP256K1",
            Self::Secp256r1 => "SECP256R1",
            Self::Multisig => "MULTISIG",
            Self::Bls12381 => "BLS12381",
            Self::Zklogin => "ZKLOGIN",
            Self::Passkey => "PASSKEY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ED25519" => Some(Self::Ed25519),
            "SECP256K1" => Some(Self::Secp256k1),
            "SECP256R1" => Some(Self::Secp256r1),
            "MULTISIG" => Some(Self::Multisig),
            "BLS12381" => Some(Self::Bls12381),
            "ZKLOGIN" => Some(Self::Zklogin),
            "PASSKEY" => Some(Self::Passkey),
            _ => None,
        }
    }
}
/// A transaction.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Transaction {
    /// This Transaction serialized as BCS.
    #[prost(message, optional, tag = "1")]
    pub bcs: ::core::option::Option<Bcs>,
    /// The digest of this Transaction.
    #[prost(string, optional, tag = "2")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Version of this Transaction.
    #[prost(int32, optional, tag = "3")]
    pub version: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "4")]
    pub kind: ::core::option::Option<TransactionKind>,
    #[prost(string, optional, tag = "5")]
    pub sender: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "6")]
    pub gas_payment: ::core::option::Option<GasPayment>,
    #[prost(message, optional, tag = "7")]
    pub expiration: ::core::option::Option<TransactionExpiration>,
}
/// Payment information for executing a transaction.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GasPayment {
    /// Set of gas objects to use for payment.
    #[prost(message, repeated, tag = "1")]
    pub objects: ::prost::alloc::vec::Vec<ObjectReference>,
    /// Owner of the gas objects, either the transaction sender or a sponsor.
    #[prost(string, optional, tag = "2")]
    pub owner: ::core::option::Option<::prost::alloc::string::String>,
    /// Gas unit price to use when charging for computation.
    ///
    /// Must be greater than or equal to the network's current RGP (reference gas price).
    #[prost(uint64, optional, tag = "3")]
    pub price: ::core::option::Option<u64>,
    /// Total budget willing to spend for the execution of a transaction.
    #[prost(uint64, optional, tag = "4")]
    pub budget: ::core::option::Option<u64>,
}
/// A TTL for a transaction.
#[non_exhaustive]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TransactionExpiration {
    #[prost(
        enumeration = "transaction_expiration::TransactionExpirationKind",
        optional,
        tag = "1"
    )]
    pub kind: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "2")]
    pub epoch: ::core::option::Option<u64>,
}
/// Nested message and enum types in `TransactionExpiration`.
pub mod transaction_expiration {
    #[non_exhaustive]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TransactionExpirationKind {
        Unknown = 0,
        /// The transaction has no expiration.
        None = 1,
        /// Validators won't sign and execute transaction unless the expiration epoch
        /// is greater than or equal to the current epoch.
        Epoch = 2,
    }
    impl TransactionExpirationKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "TRANSACTION_EXPIRATION_KIND_UNKNOWN",
                Self::None => "NONE",
                Self::Epoch => "EPOCH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TRANSACTION_EXPIRATION_KIND_UNKNOWN" => Some(Self::Unknown),
                "NONE" => Some(Self::None),
                "EPOCH" => Some(Self::Epoch),
                _ => None,
            }
        }
    }
}
/// Transaction type.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionKind {
    #[prost(
        oneof = "transaction_kind::Kind",
        tags = "2, 3, 100, 101, 102, 103, 104, 105, 106, 107, 108"
    )]
    pub kind: ::core::option::Option<transaction_kind::Kind>,
}
/// Nested message and enum types in `TransactionKind`.
pub mod transaction_kind {
    #[non_exhaustive]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        /// A user transaction comprised of a list of native commands and Move calls.
        #[prost(message, tag = "2")]
        ProgrammableTransaction(super::ProgrammableTransaction),
        /// A system transaction comprised of a list of native commands and Move calls.
        #[prost(message, tag = "3")]
        ProgrammableSystemTransaction(super::ProgrammableTransaction),
        /// System transaction used to end an epoch.
        ///
        /// The `ChangeEpoch` variant is now deprecated (but the `ChangeEpoch` struct is still used by
        /// `EndOfEpochTransaction`).
        #[prost(message, tag = "100")]
        ChangeEpoch(super::ChangeEpoch),
        /// Transaction used to initialize the chain state.
        ///
        /// Only valid if in the genesis checkpoint (0) and if this is the very first transaction ever
        /// executed on the chain.
        #[prost(message, tag = "101")]
        Genesis(super::GenesisTransaction),
        /// V1 consensus commit update.
        #[prost(message, tag = "102")]
        ConsensusCommitPrologueV1(super::ConsensusCommitPrologue),
        /// Update set of valid JWKs used for zklogin.
        #[prost(message, tag = "103")]
        AuthenticatorStateUpdate(super::AuthenticatorStateUpdate),
        /// Set of operations to run at the end of the epoch to close out the current epoch and start
        /// the next one.
        #[prost(message, tag = "104")]
        EndOfEpoch(super::EndOfEpochTransaction),
        /// Randomness update.
        #[prost(message, tag = "105")]
        RandomnessStateUpdate(super::RandomnessStateUpdate),
        /// V2 consensus commit update.
        #[prost(message, tag = "106")]
        ConsensusCommitPrologueV2(super::ConsensusCommitPrologue),
        /// V3 consensus commit update.
        #[prost(message, tag = "107")]
        ConsensusCommitPrologueV3(super::ConsensusCommitPrologue),
        /// V4 consensus commit update.
        #[prost(message, tag = "108")]
        ConsensusCommitPrologueV4(super::ConsensusCommitPrologue),
    }
}
/// A user transaction.
///
/// Contains a series of native commands and Move calls where the results of one command can be
/// used in future commands.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProgrammableTransaction {
    /// Input objects or primitive values.
    #[prost(message, repeated, tag = "1")]
    pub inputs: ::prost::alloc::vec::Vec<Input>,
    /// The commands to be executed sequentially. A failure in any command
    /// results in the failure of the entire transaction.
    #[prost(message, repeated, tag = "2")]
    pub commands: ::prost::alloc::vec::Vec<Command>,
}
/// A single command in a programmable transaction.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Command {
    #[prost(oneof = "command::Command", tags = "1, 2, 3, 4, 5, 6, 7")]
    pub command: ::core::option::Option<command::Command>,
}
/// Nested message and enum types in `Command`.
pub mod command {
    #[non_exhaustive]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Command {
        /// A call to either an entry or a public Move function.
        #[prost(message, tag = "1")]
        MoveCall(super::MoveCall),
        /// `(Vec<forall T:key+store. T>, address)`
        /// It sends n-objects to the specified address. These objects must have store
        /// (public transfer) and either the previous owner must be an address or the object must
        /// be newly created.
        #[prost(message, tag = "2")]
        TransferObjects(super::TransferObjects),
        /// `(&mut Coin<T>, Vec<u64>)` -> `Vec<Coin<T>>`
        /// It splits off some amounts into new coins with those amounts.
        #[prost(message, tag = "3")]
        SplitCoins(super::SplitCoins),
        /// `(&mut Coin<T>, Vec<Coin<T>>)`
        /// It merges n-coins into the first coin.
        #[prost(message, tag = "4")]
        MergeCoins(super::MergeCoins),
        /// Publishes a Move package. It takes the package bytes and a list of the package's transitive
        /// dependencies to link against on chain.
        #[prost(message, tag = "5")]
        Publish(super::Publish),
        /// `forall T: Vec<T> -> vector<T>`
        /// Given n-values of the same type, it constructs a vector. For non-objects or an empty vector,
        /// the type tag must be specified.
        #[prost(message, tag = "6")]
        MakeMoveVector(super::MakeMoveVector),
        /// Upgrades a Move package.
        /// Takes (in order):
        /// 1. A vector of serialized modules for the package.
        /// 2. A vector of object ids for the transitive dependencies of the new package.
        /// 3. The object ID of the package being upgraded.
        /// 4. An argument holding the `UpgradeTicket` that must have been produced from an earlier command in the same
        ///     programmable transaction.
        #[prost(message, tag = "7")]
        Upgrade(super::Upgrade),
    }
}
/// Command to call a Move function.
///
/// Functions that can be called by a `MoveCall` command are those that have a function signature
/// that is either `entry` or `public` (which don't have a reference return type).
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveCall {
    /// The package containing the module and function.
    #[prost(string, optional, tag = "1")]
    pub package: ::core::option::Option<::prost::alloc::string::String>,
    /// The specific module in the package containing the function.
    #[prost(string, optional, tag = "2")]
    pub module: ::core::option::Option<::prost::alloc::string::String>,
    /// The function to be called.
    #[prost(string, optional, tag = "3")]
    pub function: ::core::option::Option<::prost::alloc::string::String>,
    /// The type arguments to the function.
    #[prost(string, repeated, tag = "4")]
    pub type_arguments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The arguments to the function.
    #[prost(message, repeated, tag = "5")]
    pub arguments: ::prost::alloc::vec::Vec<Argument>,
}
/// Command to transfer ownership of a set of objects to an address.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransferObjects {
    /// Set of objects to transfer.
    #[prost(message, repeated, tag = "1")]
    pub objects: ::prost::alloc::vec::Vec<Argument>,
    /// The address to transfer ownership to.
    #[prost(message, optional, tag = "2")]
    pub address: ::core::option::Option<Argument>,
}
/// Command to split a single coin object into multiple coins.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SplitCoins {
    /// The coin to split.
    #[prost(message, optional, tag = "1")]
    pub coin: ::core::option::Option<Argument>,
    /// The amounts to split off.
    #[prost(message, repeated, tag = "2")]
    pub amounts: ::prost::alloc::vec::Vec<Argument>,
}
/// Command to merge multiple coins of the same type into a single coin.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MergeCoins {
    /// Coin to merge coins into.
    #[prost(message, optional, tag = "1")]
    pub coin: ::core::option::Option<Argument>,
    /// Set of coins to merge into `coin`.
    ///
    /// All listed coins must be of the same type and be the same type as `coin`
    #[prost(message, repeated, tag = "2")]
    pub coins_to_merge: ::prost::alloc::vec::Vec<Argument>,
}
/// Command to publish a new Move package.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Publish {
    /// The serialized Move modules.
    #[prost(bytes = "bytes", repeated, tag = "1")]
    pub modules: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
    /// Set of packages that the to-be published package depends on.
    #[prost(string, repeated, tag = "2")]
    pub dependencies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Command to build a Move vector out of a set of individual elements.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MakeMoveVector {
    /// Type of the individual elements.
    ///
    /// This is required to be set when the type can't be inferred, for example when the set of
    /// provided arguments are all pure input values.
    #[prost(string, optional, tag = "1")]
    pub element_type: ::core::option::Option<::prost::alloc::string::String>,
    /// The set individual elements to build the vector with.
    #[prost(message, repeated, tag = "2")]
    pub elements: ::prost::alloc::vec::Vec<Argument>,
}
/// Command to upgrade an already published package.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Upgrade {
    /// The serialized Move modules.
    #[prost(bytes = "bytes", repeated, tag = "1")]
    pub modules: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
    /// Set of packages that the to-be published package depends on.
    #[prost(string, repeated, tag = "2")]
    pub dependencies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Package ID of the package to upgrade.
    #[prost(string, optional, tag = "3")]
    pub package: ::core::option::Option<::prost::alloc::string::String>,
    /// Ticket authorizing the upgrade.
    #[prost(message, optional, tag = "4")]
    pub ticket: ::core::option::Option<Argument>,
}
/// Randomness update.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RandomnessStateUpdate {
    /// Epoch of the randomness state update transaction.
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    /// Randomness round of the update.
    #[prost(uint64, optional, tag = "2")]
    pub randomness_round: ::core::option::Option<u64>,
    /// Updated random bytes.
    #[prost(bytes = "bytes", optional, tag = "3")]
    pub random_bytes: ::core::option::Option<::prost::bytes::Bytes>,
    /// The initial version of the randomness object that it was shared at.
    #[prost(uint64, optional, tag = "4")]
    pub randomness_object_initial_shared_version: ::core::option::Option<u64>,
}
/// System transaction used to change the epoch.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangeEpoch {
    /// The next (to become) epoch ID.
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    /// The protocol version in effect in the new epoch.
    #[prost(uint64, optional, tag = "2")]
    pub protocol_version: ::core::option::Option<u64>,
    /// The total amount of gas charged for storage during the epoch.
    #[prost(uint64, optional, tag = "3")]
    pub storage_charge: ::core::option::Option<u64>,
    /// The total amount of gas charged for computation during the epoch.
    #[prost(uint64, optional, tag = "4")]
    pub computation_charge: ::core::option::Option<u64>,
    /// The amount of storage rebate refunded to the txn senders.
    #[prost(uint64, optional, tag = "5")]
    pub storage_rebate: ::core::option::Option<u64>,
    /// The non-refundable storage fee.
    #[prost(uint64, optional, tag = "6")]
    pub non_refundable_storage_fee: ::core::option::Option<u64>,
    /// Unix timestamp when epoch started.
    #[prost(message, optional, tag = "7")]
    pub epoch_start_timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// System packages (specifically framework and Move stdlib) that are written before the new
    /// epoch starts. This tracks framework upgrades on chain. When executing the `ChangeEpoch` txn,
    /// the validator must write out the following modules.  Modules are provided with the version they
    /// will be upgraded to, their modules in serialized form (which include their package ID), and
    /// a list of their transitive dependencies.
    #[prost(message, repeated, tag = "8")]
    pub system_packages: ::prost::alloc::vec::Vec<SystemPackage>,
}
/// System package.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SystemPackage {
    /// Version of the package.
    #[prost(uint64, optional, tag = "1")]
    pub version: ::core::option::Option<u64>,
    /// Move modules.
    #[prost(bytes = "bytes", repeated, tag = "2")]
    pub modules: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
    /// Package dependencies.
    #[prost(string, repeated, tag = "3")]
    pub dependencies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// The genesis transaction.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenesisTransaction {
    /// Set of genesis objects.
    #[prost(message, repeated, tag = "1")]
    pub objects: ::prost::alloc::vec::Vec<Object>,
}
/// Consensus commit prologue system transaction.
///
/// This message can represent V1, V2, and V3 prologue types.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsensusCommitPrologue {
    /// Epoch of the commit prologue transaction.
    ///
    /// Present in V1, V2, V3, V4.
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    /// Consensus round of the commit.
    ///
    /// Present in V1, V2, V3, V4.
    #[prost(uint64, optional, tag = "2")]
    pub round: ::core::option::Option<u64>,
    /// Unix timestamp from consensus.
    ///
    /// Present in V1, V2, V3, V4.
    #[prost(message, optional, tag = "3")]
    pub commit_timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Digest of consensus output.
    ///
    /// Present in V2, V3, V4.
    #[prost(string, optional, tag = "4")]
    pub consensus_commit_digest: ::core::option::Option<::prost::alloc::string::String>,
    /// The sub DAG index of the consensus commit. This field is populated if there
    /// are multiple consensus commits per round.
    ///
    /// Present in V3, V4.
    #[prost(uint64, optional, tag = "5")]
    pub sub_dag_index: ::core::option::Option<u64>,
    /// Stores consensus handler determined consensus object version assignments.
    ///
    /// Present in V3, V4.
    #[prost(message, optional, tag = "6")]
    pub consensus_determined_version_assignments: ::core::option::Option<
        ConsensusDeterminedVersionAssignments,
    >,
    /// Digest of any additional state computed by the consensus handler.
    /// Used to detect forking bugs as early as possible.
    ///
    /// Present in V4.
    #[prost(string, optional, tag = "7")]
    pub additional_state_digest: ::core::option::Option<::prost::alloc::string::String>,
}
/// Object version assignment from consensus.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VersionAssignment {
    /// `ObjectId` of the object.
    #[prost(string, optional, tag = "1")]
    pub object_id: ::core::option::Option<::prost::alloc::string::String>,
    /// start version of the consensus stream for this object
    #[prost(uint64, optional, tag = "2")]
    pub start_version: ::core::option::Option<u64>,
    /// Assigned version.
    #[prost(uint64, optional, tag = "3")]
    pub version: ::core::option::Option<u64>,
}
/// A transaction that was canceled.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CanceledTransaction {
    /// Digest of the canceled transaction.
    #[prost(string, optional, tag = "1")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// List of object version assignments.
    #[prost(message, repeated, tag = "2")]
    pub version_assignments: ::prost::alloc::vec::Vec<VersionAssignment>,
}
/// Version assignments performed by consensus.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsensusDeterminedVersionAssignments {
    /// Version of this message
    #[prost(int32, optional, tag = "1")]
    pub version: ::core::option::Option<i32>,
    /// Canceled transaction version assignment.
    #[prost(message, repeated, tag = "3")]
    pub canceled_transactions: ::prost::alloc::vec::Vec<CanceledTransaction>,
}
/// Update the set of valid JWKs.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthenticatorStateUpdate {
    /// Epoch of the authenticator state update transaction.
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    /// Consensus round of the authenticator state update.
    #[prost(uint64, optional, tag = "2")]
    pub round: ::core::option::Option<u64>,
    /// Newly active JWKs.
    #[prost(message, repeated, tag = "3")]
    pub new_active_jwks: ::prost::alloc::vec::Vec<ActiveJwk>,
    /// The initial version of the authenticator object that it was shared at.
    #[prost(uint64, optional, tag = "4")]
    pub authenticator_object_initial_shared_version: ::core::option::Option<u64>,
}
/// A new JWK.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActiveJwk {
    /// Identifier used to uniquely identify a JWK.
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<JwkId>,
    /// The JWK.
    #[prost(message, optional, tag = "2")]
    pub jwk: ::core::option::Option<Jwk>,
    /// Most recent epoch in which the JWK was validated.
    #[prost(uint64, optional, tag = "3")]
    pub epoch: ::core::option::Option<u64>,
}
/// Key to uniquely identify a JWK.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JwkId {
    /// The issuer or identity of the OIDC provider.
    #[prost(string, optional, tag = "1")]
    pub iss: ::core::option::Option<::prost::alloc::string::String>,
    /// A key ID used to uniquely identify a key from an OIDC provider.
    #[prost(string, optional, tag = "2")]
    pub kid: ::core::option::Option<::prost::alloc::string::String>,
}
/// A JSON web key.
///
/// Struct that contains info for a JWK. A list of them for different kinds can
/// be retrieved from the JWK endpoint (for example, <<https://www.googleapis.com/oauth2/v3/certs>>).
/// The JWK is used to verify the JWT token.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Jwk {
    /// Key type parameter, <https://datatracker.ietf.org/doc/html/rfc7517#section-4.1.>
    #[prost(string, optional, tag = "1")]
    pub kty: ::core::option::Option<::prost::alloc::string::String>,
    /// RSA public exponent, <https://datatracker.ietf.org/doc/html/rfc7517#section-9.3.>
    #[prost(string, optional, tag = "2")]
    pub e: ::core::option::Option<::prost::alloc::string::String>,
    /// RSA modulus, <https://datatracker.ietf.org/doc/html/rfc7517#section-9.3.>
    #[prost(string, optional, tag = "3")]
    pub n: ::core::option::Option<::prost::alloc::string::String>,
    /// Algorithm parameter, <https://datatracker.ietf.org/doc/html/rfc7517#section-4.4.>
    #[prost(string, optional, tag = "4")]
    pub alg: ::core::option::Option<::prost::alloc::string::String>,
}
/// Set of operations run at the end of the epoch to close out the current epoch
/// and start the next one.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EndOfEpochTransaction {
    #[prost(message, repeated, tag = "1")]
    pub transactions: ::prost::alloc::vec::Vec<EndOfEpochTransactionKind>,
}
/// Operation run at the end of an epoch.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EndOfEpochTransactionKind {
    #[prost(
        oneof = "end_of_epoch_transaction_kind::Kind",
        tags = "2, 3, 4, 200, 201, 202, 203, 204, 205, 206"
    )]
    pub kind: ::core::option::Option<end_of_epoch_transaction_kind::Kind>,
}
/// Nested message and enum types in `EndOfEpochTransactionKind`.
pub mod end_of_epoch_transaction_kind {
    #[non_exhaustive]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        /// End the epoch and start the next one.
        #[prost(message, tag = "2")]
        ChangeEpoch(super::ChangeEpoch),
        /// Expire JWKs used for zklogin.
        #[prost(message, tag = "3")]
        AuthenticatorStateExpire(super::AuthenticatorStateExpire),
        /// Execution time observations from the committee to preserve cross epoch
        #[prost(message, tag = "4")]
        ExecutionTimeObservations(super::ExecutionTimeObservations),
        /// Create and initialize the authenticator object used for zklogin.
        #[prost(message, tag = "200")]
        AuthenticatorStateCreate(()),
        /// Create and initialize the randomness object.
        #[prost(message, tag = "201")]
        RandomnessStateCreate(()),
        /// Create and initialize the deny list object.
        #[prost(message, tag = "202")]
        DenyListStateCreate(()),
        /// Create and initialize the bridge object.
        #[prost(string, tag = "203")]
        BridgeStateCreate(::prost::alloc::string::String),
        /// Initialize the bridge committee.
        #[prost(uint64, tag = "204")]
        BridgeCommitteeInit(u64),
        /// Create the accumulator root object.
        #[prost(message, tag = "205")]
        AccumulatorRootCreate(()),
        /// Create and initialize the Coin Registry object.
        #[prost(message, tag = "206")]
        CoinRegistryCreate(()),
    }
}
/// Expire old JWKs.
#[non_exhaustive]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AuthenticatorStateExpire {
    /// Expire JWKs that have a lower epoch than this.
    #[prost(uint64, optional, tag = "1")]
    pub min_epoch: ::core::option::Option<u64>,
    /// The initial version of the authenticator object that it was shared at.
    #[prost(uint64, optional, tag = "2")]
    pub authenticator_object_initial_shared_version: ::core::option::Option<u64>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutionTimeObservations {
    /// Version of this ExecutionTimeObservations
    #[prost(int32, optional, tag = "1")]
    pub version: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "2")]
    pub observations: ::prost::alloc::vec::Vec<ExecutionTimeObservation>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutionTimeObservation {
    #[prost(
        enumeration = "execution_time_observation::ExecutionTimeObservationKind",
        optional,
        tag = "1"
    )]
    pub kind: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "2")]
    pub move_entry_point: ::core::option::Option<MoveCall>,
    #[prost(message, repeated, tag = "3")]
    pub validator_observations: ::prost::alloc::vec::Vec<
        ValidatorExecutionTimeObservation,
    >,
}
/// Nested message and enum types in `ExecutionTimeObservation`.
pub mod execution_time_observation {
    #[non_exhaustive]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExecutionTimeObservationKind {
        Unknown = 0,
        MoveEntryPoint = 1,
        TransferObjects = 2,
        SplitCoins = 3,
        MergeCoins = 4,
        Publish = 5,
        MakeMoveVector = 6,
        Upgrade = 7,
    }
    impl ExecutionTimeObservationKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "EXECUTION_TIME_OBSERVATION_KIND_UNKNOWN",
                Self::MoveEntryPoint => "MOVE_ENTRY_POINT",
                Self::TransferObjects => "TRANSFER_OBJECTS",
                Self::SplitCoins => "SPLIT_COINS",
                Self::MergeCoins => "MERGE_COINS",
                Self::Publish => "PUBLISH",
                Self::MakeMoveVector => "MAKE_MOVE_VECTOR",
                Self::Upgrade => "UPGRADE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EXECUTION_TIME_OBSERVATION_KIND_UNKNOWN" => Some(Self::Unknown),
                "MOVE_ENTRY_POINT" => Some(Self::MoveEntryPoint),
                "TRANSFER_OBJECTS" => Some(Self::TransferObjects),
                "SPLIT_COINS" => Some(Self::SplitCoins),
                "MERGE_COINS" => Some(Self::MergeCoins),
                "PUBLISH" => Some(Self::Publish),
                "MAKE_MOVE_VECTOR" => Some(Self::MakeMoveVector),
                "UPGRADE" => Some(Self::Upgrade),
                _ => None,
            }
        }
    }
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatorExecutionTimeObservation {
    /// Bls12381 public key of the validator
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub validator: ::core::option::Option<::prost::bytes::Bytes>,
    /// Duration of an execution observation
    #[prost(message, optional, tag = "2")]
    pub duration: ::core::option::Option<::prost_types::Duration>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteTransactionRequest {
    /// The transaction to execute.
    #[prost(message, optional, tag = "1")]
    pub transaction: ::core::option::Option<Transaction>,
    /// Set of `UserSiganture`s authorizing the execution of the provided
    /// transaction.
    #[prost(message, repeated, tag = "2")]
    pub signatures: ::prost::alloc::vec::Vec<UserSignature>,
    /// Mask specifying which fields to read.
    /// If no mask is specified, defaults to `finality`.
    #[prost(message, optional, tag = "3")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Response message for `NodeService.ExecuteTransaction`.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteTransactionResponse {
    /// Indicates the finality of the executed transaction.
    #[prost(message, optional, tag = "1")]
    pub finality: ::core::option::Option<TransactionFinality>,
    #[prost(message, optional, tag = "2")]
    pub transaction: ::core::option::Option<ExecutedTransaction>,
}
/// Indicates the finality of the executed transaction.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionFinality {
    #[prost(oneof = "transaction_finality::Finality", tags = "1, 2, 3")]
    pub finality: ::core::option::Option<transaction_finality::Finality>,
}
/// Nested message and enum types in `TransactionFinality`.
pub mod transaction_finality {
    #[non_exhaustive]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Finality {
        /// A quorum certificate certifying that a transaction is final but might not
        /// be included in a checkpoint yet.
        #[prost(message, tag = "1")]
        Certified(super::ValidatorAggregatedSignature),
        /// Sequence number of the checkpoint that includes the transaction.
        #[prost(uint64, tag = "2")]
        Checkpointed(u64),
        /// Indicates that a quorum of validators has executed the transaction but
        /// that it might not be included in a checkpoint yet.
        #[prost(message, tag = "3")]
        QuorumExecuted(()),
    }
}
/// Generated client implementations.
pub mod transaction_execution_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct TransactionExecutionServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl TransactionExecutionServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> TransactionExecutionServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> TransactionExecutionServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            TransactionExecutionServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn execute_transaction(
            &mut self,
            request: impl tonic::IntoRequest<super::ExecuteTransactionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ExecuteTransactionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/soma.rpc.TransactionExecutionService/ExecuteTransaction",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "soma.rpc.TransactionExecutionService",
                        "ExecuteTransaction",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod transaction_execution_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with TransactionExecutionServiceServer.
    #[async_trait]
    pub trait TransactionExecutionService: std::marker::Send + std::marker::Sync + 'static {
        async fn execute_transaction(
            &self,
            request: tonic::Request<super::ExecuteTransactionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ExecuteTransactionResponse>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct TransactionExecutionServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> TransactionExecutionServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for TransactionExecutionServiceServer<T>
    where
        T: TransactionExecutionService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/soma.rpc.TransactionExecutionService/ExecuteTransaction" => {
                    #[allow(non_camel_case_types)]
                    struct ExecuteTransactionSvc<T: TransactionExecutionService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: TransactionExecutionService,
                    > tonic::server::UnaryService<super::ExecuteTransactionRequest>
                    for ExecuteTransactionSvc<T> {
                        type Response = super::ExecuteTransactionResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ExecuteTransactionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TransactionExecutionService>::execute_transaction(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ExecuteTransactionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(
                            tonic::body::Body::default(),
                        );
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for TransactionExecutionServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "soma.rpc.TransactionExecutionService";
    impl<T> tonic::server::NamedService for TransactionExecutionServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
