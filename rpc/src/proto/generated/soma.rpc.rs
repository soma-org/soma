// This file is @generated by prost-build.
/// The delta, or change, in balance for an address for a particular `Coin` type.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BalanceChange {
    /// The account address that is affected by this balance change event.
    #[prost(string, optional, tag = "1")]
    pub address: ::core::option::Option<::prost::alloc::string::String>,
    /// The amount or change in balance.
    #[prost(string, optional, tag = "2")]
    pub amount: ::core::option::Option<::prost::alloc::string::String>,
}
/// `Bcs` contains an arbitrary type that is serialized using the BCS
/// format as well as a name that identifies the type of the serialized value.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Bcs {
    /// Name that identifies the type of the serialized value.
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// Bytes of a BCS serialized value.
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub value: ::core::option::Option<::prost::bytes::Bytes>,
}
/// The effects of executing a transaction.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionEffects {
    /// This TransactionEffects serialized as BCS.
    #[prost(message, optional, tag = "1")]
    pub bcs: ::core::option::Option<Bcs>,
    /// The digest of this TransactionEffects.
    #[prost(string, optional, tag = "2")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// The status of the execution.
    #[prost(message, optional, tag = "3")]
    pub status: ::core::option::Option<ExecutionStatus>,
    /// The epoch when this transaction was executed.
    #[prost(uint64, optional, tag = "4")]
    pub epoch: ::core::option::Option<u64>,
    /// The transaction fee
    #[prost(message, optional, tag = "5")]
    pub fee: ::core::option::Option<TransactionFee>,
    /// The transaction digest.
    #[prost(string, optional, tag = "6")]
    pub transaction_digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Information about the gas object. Also present in the `changed_objects` vector.
    ///
    /// System transaction that don't require gas will leave this as `None`.
    #[prost(message, optional, tag = "7")]
    pub gas_object: ::core::option::Option<ChangedObject>,
    /// The set of transaction digests this transaction depends on.
    #[prost(string, repeated, tag = "8")]
    pub dependencies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The version number of all the written objects (excluding packages) by this transaction.
    #[prost(uint64, optional, tag = "9")]
    pub lamport_version: ::core::option::Option<u64>,
    /// Objects whose state are changed by this transaction.
    #[prost(message, repeated, tag = "10")]
    pub changed_objects: ::prost::alloc::vec::Vec<ChangedObject>,
    /// Shared objects that are not mutated in this transaction. Unlike owned objects,
    /// read-only shared objects' version are not committed in the transaction,
    /// and in order for a node to catch up and execute it without consensus sequencing,
    /// the version needs to be committed in the effects.
    #[prost(message, repeated, tag = "11")]
    pub unchanged_shared_objects: ::prost::alloc::vec::Vec<UnchangedSharedObject>,
}
/// Input/output state of an object that was changed during execution.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangedObject {
    /// ID of the object.
    #[prost(string, optional, tag = "1")]
    pub object_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "changed_object::InputObjectState", optional, tag = "2")]
    pub input_state: ::core::option::Option<i32>,
    /// Version of the object before this transaction executed.
    #[prost(uint64, optional, tag = "3")]
    pub input_version: ::core::option::Option<u64>,
    /// Digest of the object before this transaction executed.
    #[prost(string, optional, tag = "4")]
    pub input_digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Owner of the object before this transaction executed.
    #[prost(message, optional, tag = "5")]
    pub input_owner: ::core::option::Option<Owner>,
    #[prost(enumeration = "changed_object::OutputObjectState", optional, tag = "6")]
    pub output_state: ::core::option::Option<i32>,
    /// Version of the object after this transaction executed.
    #[prost(uint64, optional, tag = "7")]
    pub output_version: ::core::option::Option<u64>,
    /// Digest of the object after this transaction executed.
    #[prost(string, optional, tag = "8")]
    pub output_digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Owner of the object after this transaction executed.
    #[prost(message, optional, tag = "9")]
    pub output_owner: ::core::option::Option<Owner>,
    /// What happened to an `ObjectId` during execution.
    #[prost(enumeration = "changed_object::IdOperation", optional, tag = "10")]
    pub id_operation: ::core::option::Option<i32>,
    /// Type information is not provided by the effects structure but is instead
    /// provided by an indexing layer
    #[prost(string, optional, tag = "11")]
    pub object_type: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `ChangedObject`.
pub mod changed_object {
    #[non_exhaustive]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InputObjectState {
        Unknown = 0,
        DoesNotExist = 1,
        Exists = 2,
    }
    impl InputObjectState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "INPUT_OBJECT_STATE_UNKNOWN",
                Self::DoesNotExist => "INPUT_OBJECT_STATE_DOES_NOT_EXIST",
                Self::Exists => "INPUT_OBJECT_STATE_EXISTS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INPUT_OBJECT_STATE_UNKNOWN" => Some(Self::Unknown),
                "INPUT_OBJECT_STATE_DOES_NOT_EXIST" => Some(Self::DoesNotExist),
                "INPUT_OBJECT_STATE_EXISTS" => Some(Self::Exists),
                _ => None,
            }
        }
    }
    #[non_exhaustive]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OutputObjectState {
        Unknown = 0,
        DoesNotExist = 1,
        ObjectWrite = 2,
    }
    impl OutputObjectState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "OUTPUT_OBJECT_STATE_UNKNOWN",
                Self::DoesNotExist => "OUTPUT_OBJECT_STATE_DOES_NOT_EXIST",
                Self::ObjectWrite => "OUTPUT_OBJECT_STATE_OBJECT_WRITE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OUTPUT_OBJECT_STATE_UNKNOWN" => Some(Self::Unknown),
                "OUTPUT_OBJECT_STATE_DOES_NOT_EXIST" => Some(Self::DoesNotExist),
                "OUTPUT_OBJECT_STATE_OBJECT_WRITE" => Some(Self::ObjectWrite),
                _ => None,
            }
        }
    }
    #[non_exhaustive]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum IdOperation {
        Unknown = 0,
        None = 1,
        Created = 2,
        Deleted = 3,
    }
    impl IdOperation {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "ID_OPERATION_UNKNOWN",
                Self::None => "NONE",
                Self::Created => "CREATED",
                Self::Deleted => "DELETED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ID_OPERATION_UNKNOWN" => Some(Self::Unknown),
                "NONE" => Some(Self::None),
                "CREATED" => Some(Self::Created),
                "DELETED" => Some(Self::Deleted),
                _ => None,
            }
        }
    }
}
/// A shared object that wasn't changed during execution.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnchangedSharedObject {
    #[prost(
        enumeration = "unchanged_shared_object::UnchangedSharedObjectKind",
        optional,
        tag = "1"
    )]
    pub kind: ::core::option::Option<i32>,
    /// ObjectId of the consensus object.
    #[prost(string, optional, tag = "2")]
    pub object_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Version of the consensus object.
    #[prost(uint64, optional, tag = "3")]
    pub version: ::core::option::Option<u64>,
    /// Digest of the consensus object.
    #[prost(string, optional, tag = "4")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Type information is not provided by the effects structure but is instead
    /// provided by an indexing layer
    #[prost(string, optional, tag = "5")]
    pub object_type: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `UnchangedSharedObject`.
pub mod unchanged_shared_object {
    #[non_exhaustive]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UnchangedSharedObjectKind {
        Unknown = 0,
        /// Read-only shared object from the input.
        ReadOnlyRoot = 1,
        /// / Deleted shared objects that appear mutably/owned in the input
        MutatedDeleted = 2,
        /// Deleted shared objects that appear as read-only in the input.
        ReadDeleted = 3,
        /// Consensus objects that were congested and resulted in this transaction being
        /// canceled.
        Canceled = 4,
    }
    impl UnchangedSharedObjectKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNCHANGED_SHARED_OBJECT_KIND_UNKNOWN",
                Self::ReadOnlyRoot => "READ_ONLY_ROOT",
                Self::MutatedDeleted => "MUTATED_DELETED",
                Self::ReadDeleted => "READ_DELETED",
                Self::Canceled => "CANCELED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNCHANGED_SHARED_OBJECT_KIND_UNKNOWN" => Some(Self::Unknown),
                "READ_ONLY_ROOT" => Some(Self::ReadOnlyRoot),
                "MUTATED_DELETED" => Some(Self::MutatedDeleted),
                "READ_DELETED" => Some(Self::ReadDeleted),
                "CANCELED" => Some(Self::Canceled),
                _ => None,
            }
        }
    }
}
#[non_exhaustive]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ErrorReason {
    Unknown = 0,
    FieldInvalid = 1,
    FieldMissing = 2,
}
impl ErrorReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "ERROR_REASON_UNKNOWN",
            Self::FieldInvalid => "FIELD_INVALID",
            Self::FieldMissing => "FIELD_MISSING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ERROR_REASON_UNKNOWN" => Some(Self::Unknown),
            "FIELD_INVALID" => Some(Self::FieldInvalid),
            "FIELD_MISSING" => Some(Self::FieldMissing),
            _ => None,
        }
    }
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutedTransaction {
    /// The digest of this Transaction.
    #[prost(string, optional, tag = "1")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// The transaction itself.
    #[prost(message, optional, tag = "2")]
    pub transaction: ::core::option::Option<Transaction>,
    /// List of user signatures that are used to authorize the
    /// execution of this transaction.
    #[prost(message, repeated, tag = "3")]
    pub signatures: ::prost::alloc::vec::Vec<UserSignature>,
    /// The `TransactionEffects` for this transaction.
    #[prost(message, optional, tag = "4")]
    pub effects: ::core::option::Option<TransactionEffects>,
    /// The commit index that includes this transaction.
    #[prost(uint64, optional, tag = "5")]
    pub commit: ::core::option::Option<u64>,
    /// The Unix timestamp of the checkpoint that includes this transaction.
    #[prost(message, optional, tag = "6")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, repeated, tag = "7")]
    pub balance_changes: ::prost::alloc::vec::Vec<BalanceChange>,
    /// Set of input objects used during the execution of this transaction.
    #[prost(message, repeated, tag = "8")]
    pub input_objects: ::prost::alloc::vec::Vec<Object>,
    /// Set of output objects produced from the execution of this transaction.
    #[prost(message, repeated, tag = "9")]
    pub output_objects: ::prost::alloc::vec::Vec<Object>,
}
/// The status of an executed transaction.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutionStatus {
    /// Indicates if the transaction was successful or not.
    #[prost(bool, optional, tag = "1")]
    pub success: ::core::option::Option<bool>,
    /// The error if `success` is false.
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<ExecutionError>,
}
/// An error that can occur during the execution of a transaction.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutionError {
    /// A human readable description of the error
    #[prost(string, optional, tag = "1")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "execution_error::ExecutionErrorKind", optional, tag = "2")]
    pub kind: ::core::option::Option<i32>,
    #[prost(oneof = "execution_error::ErrorDetails", tags = "3, 4")]
    pub error_details: ::core::option::Option<execution_error::ErrorDetails>,
}
/// Nested message and enum types in `ExecutionError`.
pub mod execution_error {
    #[non_exhaustive]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExecutionErrorKind {
        Unknown = 0,
        /// Insufficient gas.
        InsufficientGas = 1,
        /// Invalid owner for object.
        InvalidOwnership = 2,
        /// Object not found.
        ObjectNotFound = 3,
        /// Invalid object type.
        InvalidObjectType = 4,
        /// Invalid transaction type
        InvalidTransactionType = 5,
        /// Invalid arguments for transaction
        InvalidArguments = 6,
        /// Adding avalidator that already exists
        DuplicateValidator = 7,
        /// Trying to remove a validator that doesn't exist
        NotAValidator = 8,
        /// Removing a validator that was already removed
        ValidatorAlreadyRemoved = 9,
        /// Advancing to unexpected epoch
        AdvancedToWrongEpoch = 10,
        /// Adding an encoder that already exists
        DuplicateEncoder = 11,
        /// Removing an encoder that doesn't exist
        NotAnEncoder = 12,
        /// Removing an encoder already removed
        EncoderAlreadyRemoved = 13,
        /// Insufficient coin balance for requested operation.
        InsufficientCoinBalance = 14,
        /// Coin balance overflowed an u64.
        CoinBalanceOverflow = 15,
        /// Validator not found
        ValidatorNotFound = 16,
        /// Encoder not found
        EncoderNotFound = 17,
        /// Staking pool not found
        StakingPoolNotFound = 18,
        /// Validator cannot report oneself
        CannotReportOneself = 19,
        /// Unreported record cannot be undone
        ReportRecordNotFound = 20,
        /// Other error.
        OtherError = 21,
    }
    impl ExecutionErrorKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "EXECUTION_ERROR_KIND_UNKNOWN",
                Self::InsufficientGas => "INSUFFICIENT_GAS",
                Self::InvalidOwnership => "INVALID_OWNERSHIP",
                Self::ObjectNotFound => "OBJECT_NOT_FOUND",
                Self::InvalidObjectType => "INVALID_OBJECT_TYPE",
                Self::InvalidTransactionType => "INVALID_TRANSACTION_TYPE",
                Self::InvalidArguments => "INVALID_ARGUMENTS",
                Self::DuplicateValidator => "DUPLICATE_VALIDATOR",
                Self::NotAValidator => "NOT_A_VALIDATOR",
                Self::ValidatorAlreadyRemoved => "VALIDATOR_ALREADY_REMOVED",
                Self::AdvancedToWrongEpoch => "ADVANCED_TO_WRONG_EPOCH",
                Self::DuplicateEncoder => "DUPLICATE_ENCODER",
                Self::NotAnEncoder => "NOT_AN_ENCODER",
                Self::EncoderAlreadyRemoved => "ENCODER_ALREADY_REMOVED",
                Self::InsufficientCoinBalance => "INSUFFICIENT_COIN_BALANCE",
                Self::CoinBalanceOverflow => "COIN_BALANCE_OVERFLOW",
                Self::ValidatorNotFound => "VALIDATOR_NOT_FOUND",
                Self::EncoderNotFound => "ENCODER_NOT_FOUND",
                Self::StakingPoolNotFound => "STAKING_POOL_NOT_FOUND",
                Self::CannotReportOneself => "CANNOT_REPORT_ONESELF",
                Self::ReportRecordNotFound => "REPORT_RECORD_NOT_FOUND",
                Self::OtherError => "OTHER_ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EXECUTION_ERROR_KIND_UNKNOWN" => Some(Self::Unknown),
                "INSUFFICIENT_GAS" => Some(Self::InsufficientGas),
                "INVALID_OWNERSHIP" => Some(Self::InvalidOwnership),
                "OBJECT_NOT_FOUND" => Some(Self::ObjectNotFound),
                "INVALID_OBJECT_TYPE" => Some(Self::InvalidObjectType),
                "INVALID_TRANSACTION_TYPE" => Some(Self::InvalidTransactionType),
                "INVALID_ARGUMENTS" => Some(Self::InvalidArguments),
                "DUPLICATE_VALIDATOR" => Some(Self::DuplicateValidator),
                "NOT_A_VALIDATOR" => Some(Self::NotAValidator),
                "VALIDATOR_ALREADY_REMOVED" => Some(Self::ValidatorAlreadyRemoved),
                "ADVANCED_TO_WRONG_EPOCH" => Some(Self::AdvancedToWrongEpoch),
                "DUPLICATE_ENCODER" => Some(Self::DuplicateEncoder),
                "NOT_AN_ENCODER" => Some(Self::NotAnEncoder),
                "ENCODER_ALREADY_REMOVED" => Some(Self::EncoderAlreadyRemoved),
                "INSUFFICIENT_COIN_BALANCE" => Some(Self::InsufficientCoinBalance),
                "COIN_BALANCE_OVERFLOW" => Some(Self::CoinBalanceOverflow),
                "VALIDATOR_NOT_FOUND" => Some(Self::ValidatorNotFound),
                "ENCODER_NOT_FOUND" => Some(Self::EncoderNotFound),
                "STAKING_POOL_NOT_FOUND" => Some(Self::StakingPoolNotFound),
                "CANNOT_REPORT_ONESELF" => Some(Self::CannotReportOneself),
                "REPORT_RECORD_NOT_FOUND" => Some(Self::ReportRecordNotFound),
                "OTHER_ERROR" => Some(Self::OtherError),
                _ => None,
            }
        }
    }
    #[non_exhaustive]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ErrorDetails {
        #[prost(string, tag = "3")]
        ObjectId(::prost::alloc::string::String),
        #[prost(string, tag = "4")]
        OtherError(::prost::alloc::string::String),
    }
}
/// An object on the Sui blockchain.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Object {
    /// This Object serialized as BCS.
    #[prost(message, optional, tag = "1")]
    pub bcs: ::core::option::Option<Bcs>,
    /// `ObjectId` for this object.
    #[prost(string, optional, tag = "2")]
    pub object_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Version of the object.
    #[prost(uint64, optional, tag = "3")]
    pub version: ::core::option::Option<u64>,
    /// The digest of this Object.
    #[prost(string, optional, tag = "4")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Owner of the object.
    #[prost(message, optional, tag = "5")]
    pub owner: ::core::option::Option<Owner>,
    /// The type of this object.
    #[prost(string, optional, tag = "6")]
    pub object_type: ::core::option::Option<::prost::alloc::string::String>,
    /// BCS bytes of a struct value.
    #[prost(message, optional, tag = "7")]
    pub contents: ::core::option::Option<Bcs>,
    /// The digest of the transaction that created or last mutated this object
    #[prost(string, optional, tag = "8")]
    pub previous_transaction: ::core::option::Option<::prost::alloc::string::String>,
}
/// Reference to an object.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectReference {
    /// The object id of this object.
    #[prost(string, optional, tag = "1")]
    pub object_id: ::core::option::Option<::prost::alloc::string::String>,
    /// The version of this object.
    #[prost(uint64, optional, tag = "2")]
    pub version: ::core::option::Option<u64>,
    /// The digest of this object.
    #[prost(string, optional, tag = "3")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
}
/// Enum of different types of ownership for an object.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Owner {
    #[prost(enumeration = "owner::OwnerKind", optional, tag = "1")]
    pub kind: ::core::option::Option<i32>,
    /// Address or ObjectId of the owner
    #[prost(string, optional, tag = "2")]
    pub address: ::core::option::Option<::prost::alloc::string::String>,
    /// The `initial_shared_version` if kind is `SHARED`.
    #[prost(uint64, optional, tag = "3")]
    pub version: ::core::option::Option<u64>,
}
/// Nested message and enum types in `Owner`.
pub mod owner {
    #[non_exhaustive]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OwnerKind {
        Unknown = 0,
        Address = 1,
        Shared = 2,
        Immutable = 3,
    }
    impl OwnerKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "OWNER_KIND_UNKNOWN",
                Self::Address => "ADDRESS",
                Self::Shared => "SHARED",
                Self::Immutable => "IMMUTABLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OWNER_KIND_UNKNOWN" => Some(Self::Unknown),
                "ADDRESS" => Some(Self::Address),
                "SHARED" => Some(Self::Shared),
                "IMMUTABLE" => Some(Self::Immutable),
                _ => None,
            }
        }
    }
}
/// A signature from a user.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserSignature {
    /// This signature serialized as as BCS.
    ///
    /// When provided as input this will support both the form that is length
    /// prefixed as well as not length prefixed.
    #[prost(message, optional, tag = "1")]
    pub bcs: ::core::option::Option<Bcs>,
    /// The signature scheme of this signature.
    #[prost(enumeration = "SignatureScheme", optional, tag = "2")]
    pub scheme: ::core::option::Option<i32>,
    #[prost(oneof = "user_signature::Signature", tags = "3")]
    pub signature: ::core::option::Option<user_signature::Signature>,
}
/// Nested message and enum types in `UserSignature`.
pub mod user_signature {
    #[non_exhaustive]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Signature {
        /// Simple signature if scheme is ed25519 | secp256k1 | secp256r1.
        #[prost(message, tag = "3")]
        Simple(super::SimpleSignature),
    }
}
/// Either an ed25519, secp256k1 or secp256r1 signature
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SimpleSignature {
    /// The signature scheme of this signature.
    #[prost(enumeration = "SignatureScheme", optional, tag = "1")]
    pub scheme: ::core::option::Option<i32>,
    /// Signature bytes
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub signature: ::core::option::Option<::prost::bytes::Bytes>,
    /// Public key bytes
    #[prost(bytes = "bytes", optional, tag = "3")]
    pub public_key: ::core::option::Option<::prost::bytes::Bytes>,
}
/// The validator set for a particular epoch.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatorCommittee {
    /// The epoch where this committee governs.
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    /// The committee members.
    #[prost(message, repeated, tag = "2")]
    pub members: ::prost::alloc::vec::Vec<ValidatorCommitteeMember>,
}
/// A member of a validator committee.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatorCommitteeMember {
    /// The 96-byte Bls12381 public key for this validator.
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub public_key: ::core::option::Option<::prost::bytes::Bytes>,
    /// voting weight this validator possesses.
    #[prost(uint64, optional, tag = "2")]
    pub weight: ::core::option::Option<u64>,
}
/// / An aggregated signature from multiple validators.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatorAggregatedSignature {
    /// The epoch when this signature was produced.
    ///
    /// This can be used to lookup the `ValidatorCommittee` from this epoch
    /// to verify this signature.
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    /// The 48-byte Bls12381 aggregated signature.
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub signature: ::core::option::Option<::prost::bytes::Bytes>,
    /// Bitmap indicating which members of the committee contributed to
    /// this signature.
    #[prost(uint32, repeated, tag = "3")]
    pub bitmap: ::prost::alloc::vec::Vec<u32>,
}
/// Flag use to disambiguate the signature schemes supported by Soma.
///
/// Note: the enum values defined by this proto message exactly match their
/// expected BCS serialized values when serialized as a u8.
#[non_exhaustive]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SignatureScheme {
    Ed25519 = 0,
    Bls12381 = 1,
}
impl SignatureScheme {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Ed25519 => "ED25519",
            Self::Bls12381 => "BLS12381",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ED25519" => Some(Self::Ed25519),
            "BLS12381" => Some(Self::Bls12381),
            _ => None,
        }
    }
}
/// A transaction.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Transaction {
    /// This Transaction serialized as BCS.
    #[prost(message, optional, tag = "1")]
    pub bcs: ::core::option::Option<Bcs>,
    /// The digest of this Transaction.
    #[prost(string, optional, tag = "2")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "4")]
    pub kind: ::core::option::Option<TransactionKind>,
    #[prost(string, optional, tag = "5")]
    pub sender: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "6")]
    pub gas_payment: ::core::option::Option<GasPayment>,
}
/// Payment information for executing a transaction.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GasPayment {
    /// Set of gas objects to use for payment.
    #[prost(message, repeated, tag = "1")]
    pub objects: ::prost::alloc::vec::Vec<ObjectReference>,
    /// Owner of the gas objects, either the transaction sender or a sponsor.
    #[prost(string, optional, tag = "2")]
    pub owner: ::core::option::Option<::prost::alloc::string::String>,
}
/// Transaction type.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionKind {
    #[prost(
        oneof = "transaction_kind::Kind",
        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 100, 101, 102"
    )]
    pub kind: ::core::option::Option<transaction_kind::Kind>,
}
/// Nested message and enum types in `TransactionKind`.
pub mod transaction_kind {
    #[non_exhaustive]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(message, tag = "1")]
        AddValidator(super::AddValidator),
        #[prost(message, tag = "2")]
        RemoveValidator(super::RemoveValidator),
        #[prost(message, tag = "3")]
        ReportValidator(super::ReportValidator),
        #[prost(message, tag = "4")]
        UndoReportValidator(super::UndoReportValidator),
        #[prost(message, tag = "5")]
        UpdateValidatorMetadata(super::UpdateValidatorMetadata),
        #[prost(message, tag = "6")]
        SetCommissionRate(super::SetCommissionRate),
        #[prost(message, tag = "7")]
        AddEncoder(super::AddEncoder),
        #[prost(message, tag = "8")]
        RemoveEncoder(super::RemoveEncoder),
        #[prost(message, tag = "9")]
        ReportEncoder(super::ReportEncoder),
        #[prost(message, tag = "10")]
        UndoReportEncoder(super::UndoReportEncoder),
        #[prost(message, tag = "11")]
        UpdateEncoderMetadata(super::UpdateEncoderMetadata),
        #[prost(message, tag = "12")]
        SetEncoderCommissionRate(super::SetEncoderCommissionRate),
        #[prost(message, tag = "13")]
        SetEncoderBytePrice(super::SetEncoderBytePrice),
        #[prost(message, tag = "14")]
        TransferCoin(super::TransferCoin),
        #[prost(message, tag = "15")]
        PayCoins(super::PayCoins),
        #[prost(message, tag = "16")]
        TransferObjects(super::TransferObjects),
        #[prost(message, tag = "17")]
        AddStake(super::AddStake),
        #[prost(message, tag = "18")]
        AddStakeToEncoder(super::AddStakeToEncoder),
        #[prost(message, tag = "19")]
        WithdrawStake(super::WithdrawStake),
        #[prost(message, tag = "20")]
        EmbedData(super::EmbedData),
        #[prost(message, tag = "21")]
        ClaimEscrow(super::ClaimEscrow),
        #[prost(message, tag = "22")]
        ReportScores(super::ReportScores),
        /// System transaction used to end an epoch..
        #[prost(message, tag = "100")]
        ChangeEpoch(super::ChangeEpoch),
        /// Transaction used to initialize the chain state.
        ///
        /// Only valid if in the genesis checkpoint (0) and if this is the very first transaction ever
        /// executed on the chain.
        #[prost(message, tag = "101")]
        Genesis(super::GenesisTransaction),
        /// Consensus commit update.
        #[prost(message, tag = "102")]
        ConsensusCommitPrologue(super::ConsensusCommitPrologue),
    }
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddValidator {
    #[prost(message, optional, tag = "1")]
    pub pubkey_bytes: ::core::option::Option<Bcs>,
    #[prost(message, optional, tag = "2")]
    pub network_pubkey_bytes: ::core::option::Option<Bcs>,
    #[prost(message, optional, tag = "3")]
    pub worker_pubkey_bytes: ::core::option::Option<Bcs>,
    #[prost(message, optional, tag = "4")]
    pub net_address: ::core::option::Option<Bcs>,
    #[prost(message, optional, tag = "5")]
    pub p2p_address: ::core::option::Option<Bcs>,
    #[prost(message, optional, tag = "6")]
    pub primary_address: ::core::option::Option<Bcs>,
    #[prost(message, optional, tag = "7")]
    pub encoder_validator_address: ::core::option::Option<Bcs>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveValidator {
    #[prost(message, optional, tag = "1")]
    pub pubkey_bytes: ::core::option::Option<Bcs>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReportValidator {
    #[prost(string, optional, tag = "1")]
    pub reportee: ::core::option::Option<::prost::alloc::string::String>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UndoReportValidator {
    #[prost(string, optional, tag = "1")]
    pub reportee: ::core::option::Option<::prost::alloc::string::String>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateValidatorMetadata {
    #[prost(message, optional, tag = "1")]
    pub next_epoch_network_address: ::core::option::Option<Bcs>,
    #[prost(message, optional, tag = "2")]
    pub next_epoch_p2p_address: ::core::option::Option<Bcs>,
    #[prost(message, optional, tag = "3")]
    pub next_epoch_primary_address: ::core::option::Option<Bcs>,
    #[prost(message, optional, tag = "4")]
    pub next_epoch_protocol_pubkey: ::core::option::Option<Bcs>,
    #[prost(message, optional, tag = "5")]
    pub next_epoch_worker_pubkey: ::core::option::Option<Bcs>,
    #[prost(message, optional, tag = "6")]
    pub next_epoch_network_pubkey: ::core::option::Option<Bcs>,
}
#[non_exhaustive]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetCommissionRate {
    #[prost(uint64, optional, tag = "1")]
    pub new_rate: ::core::option::Option<u64>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddEncoder {
    #[prost(message, optional, tag = "1")]
    pub encoder_pubkey_bytes: ::core::option::Option<Bcs>,
    #[prost(message, optional, tag = "2")]
    pub network_pubkey_bytes: ::core::option::Option<Bcs>,
    #[prost(message, optional, tag = "3")]
    pub internal_network_address: ::core::option::Option<Bcs>,
    #[prost(message, optional, tag = "4")]
    pub external_network_address: ::core::option::Option<Bcs>,
    #[prost(message, optional, tag = "5")]
    pub object_server_address: ::core::option::Option<Bcs>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveEncoder {
    #[prost(message, optional, tag = "1")]
    pub encoder_pubkey_bytes: ::core::option::Option<Bcs>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReportEncoder {
    #[prost(string, optional, tag = "1")]
    pub reportee: ::core::option::Option<::prost::alloc::string::String>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UndoReportEncoder {
    #[prost(string, optional, tag = "1")]
    pub reportee: ::core::option::Option<::prost::alloc::string::String>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateEncoderMetadata {
    #[prost(message, optional, tag = "1")]
    pub next_epoch_external_network_address: ::core::option::Option<Bcs>,
    #[prost(message, optional, tag = "2")]
    pub next_epoch_internal_network_address: ::core::option::Option<Bcs>,
    #[prost(message, optional, tag = "3")]
    pub next_epoch_network_pubkey: ::core::option::Option<Bcs>,
    #[prost(message, optional, tag = "4")]
    pub next_epoch_object_server_address: ::core::option::Option<Bcs>,
}
#[non_exhaustive]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetEncoderCommissionRate {
    #[prost(uint64, optional, tag = "1")]
    pub new_rate: ::core::option::Option<u64>,
}
#[non_exhaustive]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetEncoderBytePrice {
    #[prost(uint64, optional, tag = "1")]
    pub new_price: ::core::option::Option<u64>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransferCoin {
    #[prost(message, optional, tag = "1")]
    pub coin: ::core::option::Option<ObjectReference>,
    #[prost(uint64, optional, tag = "2")]
    pub amount: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3")]
    pub recipient: ::core::option::Option<::prost::alloc::string::String>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PayCoins {
    #[prost(message, repeated, tag = "1")]
    pub coins: ::prost::alloc::vec::Vec<ObjectReference>,
    #[prost(uint64, repeated, tag = "2")]
    pub amounts: ::prost::alloc::vec::Vec<u64>,
    #[prost(string, repeated, tag = "3")]
    pub recipients: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransferObjects {
    #[prost(message, repeated, tag = "1")]
    pub objects: ::prost::alloc::vec::Vec<ObjectReference>,
    #[prost(string, optional, tag = "2")]
    pub recipient: ::core::option::Option<::prost::alloc::string::String>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddStake {
    #[prost(string, optional, tag = "1")]
    pub address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    pub coin_ref: ::core::option::Option<ObjectReference>,
    #[prost(uint64, optional, tag = "3")]
    pub amount: ::core::option::Option<u64>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddStakeToEncoder {
    #[prost(string, optional, tag = "1")]
    pub encoder_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    pub coin_ref: ::core::option::Option<ObjectReference>,
    #[prost(uint64, optional, tag = "3")]
    pub amount: ::core::option::Option<u64>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WithdrawStake {
    #[prost(message, optional, tag = "1")]
    pub staked_soma: ::core::option::Option<ObjectReference>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EmbedData {
    #[prost(string, optional, tag = "1")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "2")]
    pub data_size_bytes: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "3")]
    pub coin_ref: ::core::option::Option<ObjectReference>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClaimEscrow {
    #[prost(message, optional, tag = "1")]
    pub shard_input_ref: ::core::option::Option<ObjectReference>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReportScores {
    #[prost(message, optional, tag = "1")]
    pub shard_input_ref: ::core::option::Option<ObjectReference>,
    #[prost(message, optional, tag = "2")]
    pub scores: ::core::option::Option<Bcs>,
    #[prost(message, optional, tag = "3")]
    pub encoder_aggregate_signature: ::core::option::Option<Bcs>,
    #[prost(string, repeated, tag = "4")]
    pub signers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// System transaction used to change the epoch.
#[non_exhaustive]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChangeEpoch {
    /// The next (to become) epoch ID.
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    /// Unix timestamp when epoch started.
    #[prost(message, optional, tag = "2")]
    pub epoch_start_timestamp: ::core::option::Option<::prost_types::Timestamp>,
}
/// The genesis transaction.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenesisTransaction {
    /// Set of genesis objects.
    #[prost(message, repeated, tag = "1")]
    pub objects: ::prost::alloc::vec::Vec<Object>,
}
/// Consensus commit prologue system transaction.
///
/// This message can represent V1, V2, and V3 prologue types.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsensusCommitPrologue {
    /// Epoch of the commit prologue transaction.
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    /// Consensus round of the commit.
    #[prost(uint64, optional, tag = "2")]
    pub round: ::core::option::Option<u64>,
    /// Unix timestamp from consensus.
    #[prost(message, optional, tag = "3")]
    pub commit_timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Digest of consensus output.
    #[prost(string, optional, tag = "4")]
    pub consensus_commit_digest: ::core::option::Option<::prost::alloc::string::String>,
    /// The sub DAG index of the consensus commit. This field is populated if there
    /// are multiple consensus commits per round.
    #[prost(uint64, optional, tag = "5")]
    pub sub_dag_index: ::core::option::Option<u64>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteTransactionRequest {
    /// The transaction to execute.
    #[prost(message, optional, tag = "1")]
    pub transaction: ::core::option::Option<Transaction>,
    /// Set of `UserSiganture`s authorizing the execution of the provided
    /// transaction.
    #[prost(message, repeated, tag = "2")]
    pub signatures: ::prost::alloc::vec::Vec<UserSignature>,
    /// Mask specifying which fields to read.
    /// If no mask is specified, defaults to `finality`.
    #[prost(message, optional, tag = "3")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Response message for `NodeService.ExecuteTransaction`.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteTransactionResponse {
    /// Indicates the finality of the executed transaction.
    #[prost(message, optional, tag = "1")]
    pub finality: ::core::option::Option<TransactionFinality>,
    #[prost(message, optional, tag = "2")]
    pub transaction: ::core::option::Option<ExecutedTransaction>,
}
/// Indicates the finality of the executed transaction.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionFinality {
    #[prost(oneof = "transaction_finality::Finality", tags = "1")]
    pub finality: ::core::option::Option<transaction_finality::Finality>,
}
/// Nested message and enum types in `TransactionFinality`.
pub mod transaction_finality {
    #[non_exhaustive]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Finality {
        /// A quorum certificate certifying that a transaction is final but might not
        /// be included in a checkpoint yet.
        #[prost(message, tag = "1")]
        Certified(super::ValidatorAggregatedSignature),
    }
}
/// Generated client implementations.
pub mod transaction_execution_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct TransactionExecutionServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl TransactionExecutionServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> TransactionExecutionServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> TransactionExecutionServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            TransactionExecutionServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn execute_transaction(
            &mut self,
            request: impl tonic::IntoRequest<super::ExecuteTransactionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ExecuteTransactionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/soma.rpc.TransactionExecutionService/ExecuteTransaction",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "soma.rpc.TransactionExecutionService",
                        "ExecuteTransaction",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod transaction_execution_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with TransactionExecutionServiceServer.
    #[async_trait]
    pub trait TransactionExecutionService: std::marker::Send + std::marker::Sync + 'static {
        async fn execute_transaction(
            &self,
            request: tonic::Request<super::ExecuteTransactionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ExecuteTransactionResponse>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct TransactionExecutionServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> TransactionExecutionServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for TransactionExecutionServiceServer<T>
    where
        T: TransactionExecutionService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/soma.rpc.TransactionExecutionService/ExecuteTransaction" => {
                    #[allow(non_camel_case_types)]
                    struct ExecuteTransactionSvc<T: TransactionExecutionService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: TransactionExecutionService,
                    > tonic::server::UnaryService<super::ExecuteTransactionRequest>
                    for ExecuteTransactionSvc<T> {
                        type Response = super::ExecuteTransactionResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ExecuteTransactionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TransactionExecutionService>::execute_transaction(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ExecuteTransactionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(
                            tonic::body::Body::default(),
                        );
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for TransactionExecutionServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "soma.rpc.TransactionExecutionService";
    impl<T> tonic::server::NamedService for TransactionExecutionServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Summary of the fee for this transaction.
#[non_exhaustive]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TransactionFee {
    /// base transaction fee.
    #[prost(uint64, optional, tag = "1")]
    pub base_fee: ::core::option::Option<u64>,
    /// Fee for each object operation (reads and writes).
    #[prost(uint64, optional, tag = "2")]
    pub operation_fee: ::core::option::Option<u64>,
    /// Fee based on transaction value.
    #[prost(uint64, optional, tag = "3")]
    pub value_fee: ::core::option::Option<u64>,
    /// Total fee deducted.
    #[prost(uint64, optional, tag = "4")]
    pub total_fee: ::core::option::Option<u64>,
}
