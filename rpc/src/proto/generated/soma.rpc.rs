// This file is @generated by prost-build.
/// The delta, or change, in balance for an address for a particular `Coin` type.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BalanceChange {
    /// The account address that is affected by this balance change event.
    #[prost(string, optional, tag = "1")]
    pub address: ::core::option::Option<::prost::alloc::string::String>,
    /// The amount or change in balance.
    #[prost(string, optional, tag = "2")]
    pub amount: ::core::option::Option<::prost::alloc::string::String>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Checkpoint {
    /// The height of this checkpoint.
    #[prost(uint64, optional, tag = "1")]
    pub sequence_number: ::core::option::Option<u64>,
    /// The digest of this Checkpoint's CheckpointSummary.
    #[prost(string, optional, tag = "2")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// The `CheckpointSummary` for this checkpoint.
    #[prost(message, optional, tag = "3")]
    pub summary: ::core::option::Option<CheckpointSummary>,
    /// An aggregated quorum signature from the validator committee that
    /// certified this checkpoint.
    #[prost(message, optional, tag = "4")]
    pub signature: ::core::option::Option<ValidatorAggregatedSignature>,
    /// The `CheckpointContents` for this checkpoint.
    #[prost(message, optional, tag = "5")]
    pub contents: ::core::option::Option<CheckpointContents>,
    /// List of transactions included in this checkpoint.
    #[prost(message, repeated, tag = "6")]
    pub transactions: ::prost::alloc::vec::Vec<ExecutedTransaction>,
    /// Set of objects either referenced as inputs or produced as
    /// outputs by transactions included in this checkpoint.
    ///
    /// In order to benefit from deduplication of objects that
    /// appear in multiple transactions in this checkpoint, objects
    /// will only be present here and the `transactions.objects`
    /// field will not be populated.
    #[prost(message, optional, tag = "7")]
    pub objects: ::core::option::Option<ObjectSet>,
}
/// The committed to contents of a checkpoint.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckpointContents {
    /// The digest of this CheckpointContents.
    #[prost(string, optional, tag = "1")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Version of this CheckpointContents
    #[prost(int32, optional, tag = "2")]
    pub version: ::core::option::Option<i32>,
    /// Set of transactions committed to in this checkpoint.
    #[prost(message, repeated, tag = "3")]
    pub transactions: ::prost::alloc::vec::Vec<CheckpointedTransactionInfo>,
}
/// Transaction information committed to in a checkpoint.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckpointedTransactionInfo {
    /// Digest of the transaction.
    #[prost(string, optional, tag = "1")]
    pub transaction: ::core::option::Option<::prost::alloc::string::String>,
    /// Digest of the effects.
    #[prost(string, optional, tag = "2")]
    pub effects: ::core::option::Option<::prost::alloc::string::String>,
    /// Set of user signatures that authorized the transaction.
    #[prost(message, repeated, tag = "3")]
    pub signatures: ::prost::alloc::vec::Vec<UserSignature>,
}
/// A header for a checkpoint on the Soma blockchain.
///
/// On the Soma network, checkpoints define the history of the blockchain. They are quite similar to
/// the concept of blocks used by other blockchains like Bitcoin or Ethereum. The Soma blockchain,
/// however, forms checkpoints after transaction execution has already happened to provide a
/// certified history of the chain, instead of being formed before execution.
///
/// Checkpoints commit to a variety of state, including but not limited to:
/// - The hash of the previous checkpoint.
/// - The set of transaction digests, their corresponding effects digests, as well as the set of
///    user signatures that authorized its execution.
/// - The objects produced by a transaction.
/// - The set of live objects that make up the current state of the chain.
/// - On epoch transitions, the next validator committee.
///
/// `CheckpointSummary`s themselves don't directly include all of the previous information but they
/// are the top-level type by which all the information is committed to transitively via cryptographic
/// hashes included in the summary. `CheckpointSummary`s are signed and certified by a quorum of
/// the validator committee in a given epoch to allow verification of the chain's state.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckpointSummary {
    /// The digest of this CheckpointSummary.
    #[prost(string, optional, tag = "1")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Epoch that this checkpoint belongs to.
    #[prost(uint64, optional, tag = "2")]
    pub epoch: ::core::option::Option<u64>,
    /// The height of this checkpoint.
    #[prost(uint64, optional, tag = "3")]
    pub sequence_number: ::core::option::Option<u64>,
    /// Total number of transactions committed since genesis, including those in this
    /// checkpoint.
    #[prost(uint64, optional, tag = "4")]
    pub total_network_transactions: ::core::option::Option<u64>,
    /// The hash of the `CheckpointContents` for this checkpoint.
    #[prost(string, optional, tag = "5")]
    pub content_digest: ::core::option::Option<::prost::alloc::string::String>,
    /// The hash of the previous `CheckpointSummary`.
    ///
    /// This will be `None` only for the first, or genesis, checkpoint.
    #[prost(string, optional, tag = "6")]
    pub previous_digest: ::core::option::Option<::prost::alloc::string::String>,
    /// The running total fees of all transactions included in the current epoch so far
    /// until this checkpoint.
    #[prost(message, optional, tag = "7")]
    pub epoch_rolling_transaction_fees: ::core::option::Option<TransactionFee>,
    /// Timestamp of the checkpoint - number of milliseconds from the Unix epoch
    /// Checkpoint timestamps are monotonic, but not strongly monotonic - subsequent
    /// checkpoints can have the same timestamp if they originate from the same underlining consensus commit.
    #[prost(message, optional, tag = "8")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Commitments to checkpoint-specific state.
    #[prost(message, repeated, tag = "9")]
    pub commitments: ::prost::alloc::vec::Vec<CheckpointCommitment>,
    /// Extra data only present in the final checkpoint of an epoch.
    #[prost(message, optional, tag = "10")]
    pub end_of_epoch_data: ::core::option::Option<EndOfEpochData>,
}
/// Data, which when included in a `CheckpointSummary`, signals the end of an `Epoch`.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EndOfEpochData {
    /// The set of validators that will be in the `ValidatorCommittee` for the next epoch.
    #[prost(message, optional, tag = "1")]
    pub next_epoch_validator_committee: ::core::option::Option<ValidatorCommittee>,
    /// TODO: add encoder committee & network committees
    /// The protocol version that is in effect during the next epoch.
    #[prost(uint64, optional, tag = "2")]
    pub next_epoch_protocol_version: ::core::option::Option<u64>,
    /// Commitments to epoch specific state (live object set)
    #[prost(message, repeated, tag = "3")]
    pub epoch_commitments: ::prost::alloc::vec::Vec<CheckpointCommitment>,
}
/// A commitment made by a checkpoint.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckpointCommitment {
    #[prost(
        enumeration = "checkpoint_commitment::CheckpointCommitmentKind",
        optional,
        tag = "1"
    )]
    pub kind: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `CheckpointCommitment`.
pub mod checkpoint_commitment {
    #[non_exhaustive]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CheckpointCommitmentKind {
        Unknown = 0,
        /// An elliptic curve multiset hash attesting to the set of objects that
        /// comprise the live state of the Soma blockchain.
        EcmhLiveObjectSet = 1,
        /// Digest of the checkpoint artifacts.
        CheckpointArtifacts = 2,
    }
    impl CheckpointCommitmentKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "CHECKPOINT_COMMITMENT_KIND_UNKNOWN",
                Self::EcmhLiveObjectSet => "ECMH_LIVE_OBJECT_SET",
                Self::CheckpointArtifacts => "CHECKPOINT_ARTIFACTS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CHECKPOINT_COMMITMENT_KIND_UNKNOWN" => Some(Self::Unknown),
                "ECMH_LIVE_OBJECT_SET" => Some(Self::EcmhLiveObjectSet),
                "CHECKPOINT_ARTIFACTS" => Some(Self::CheckpointArtifacts),
                _ => None,
            }
        }
    }
}
/// The effects of executing a transaction.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionEffects {
    /// The status of the execution.
    #[prost(message, optional, tag = "1")]
    pub status: ::core::option::Option<ExecutionStatus>,
    /// The epoch when this transaction was executed.
    #[prost(uint64, optional, tag = "2")]
    pub epoch: ::core::option::Option<u64>,
    /// The transaction fee
    #[prost(message, optional, tag = "3")]
    pub fee: ::core::option::Option<TransactionFee>,
    /// The transaction digest.
    #[prost(string, optional, tag = "4")]
    pub transaction_digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Information about the gas object. Also present in the `changed_objects` vector.
    ///
    /// System transactions that don't require gas will leave this as `None`.
    #[prost(uint32, optional, tag = "5")]
    pub gas_object_index: ::core::option::Option<u32>,
    /// The set of transaction digests this transaction depends on.
    #[prost(string, repeated, tag = "6")]
    pub dependencies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The version number of all the written objects (excluding packages) by this transaction.
    #[prost(uint64, optional, tag = "7")]
    pub lamport_version: ::core::option::Option<u64>,
    /// Objects whose state are changed by this transaction.
    #[prost(message, repeated, tag = "8")]
    pub changed_objects: ::prost::alloc::vec::Vec<ChangedObject>,
    /// Shared objects that are not mutated in this transaction. Unlike owned objects,
    /// read-only shared objects' version are not committed in the transaction,
    /// and in order for a node to catch up and execute it without consensus sequencing,
    /// the version needs to be committed in the effects.
    #[prost(message, repeated, tag = "9")]
    pub unchanged_shared_objects: ::prost::alloc::vec::Vec<UnchangedSharedObject>,
}
/// Input/output state of an object that was changed during execution.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangedObject {
    /// ID of the object.
    #[prost(string, optional, tag = "1")]
    pub object_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "changed_object::InputObjectState", optional, tag = "2")]
    pub input_state: ::core::option::Option<i32>,
    /// Version of the object before this transaction executed.
    #[prost(uint64, optional, tag = "3")]
    pub input_version: ::core::option::Option<u64>,
    /// Digest of the object before this transaction executed.
    #[prost(string, optional, tag = "4")]
    pub input_digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Owner of the object before this transaction executed.
    #[prost(message, optional, tag = "5")]
    pub input_owner: ::core::option::Option<Owner>,
    #[prost(enumeration = "changed_object::OutputObjectState", optional, tag = "6")]
    pub output_state: ::core::option::Option<i32>,
    /// Version of the object after this transaction executed.
    #[prost(uint64, optional, tag = "7")]
    pub output_version: ::core::option::Option<u64>,
    /// Digest of the object after this transaction executed.
    #[prost(string, optional, tag = "8")]
    pub output_digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Owner of the object after this transaction executed.
    #[prost(message, optional, tag = "9")]
    pub output_owner: ::core::option::Option<Owner>,
    /// What happened to an `ObjectId` during execution.
    #[prost(enumeration = "changed_object::IdOperation", optional, tag = "10")]
    pub id_operation: ::core::option::Option<i32>,
    /// Type information is not provided by the effects structure but is instead
    /// provided by an indexing layer
    #[prost(string, optional, tag = "11")]
    pub object_type: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `ChangedObject`.
pub mod changed_object {
    #[non_exhaustive]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InputObjectState {
        Unknown = 0,
        DoesNotExist = 1,
        Exists = 2,
    }
    impl InputObjectState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "INPUT_OBJECT_STATE_UNKNOWN",
                Self::DoesNotExist => "INPUT_OBJECT_STATE_DOES_NOT_EXIST",
                Self::Exists => "INPUT_OBJECT_STATE_EXISTS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INPUT_OBJECT_STATE_UNKNOWN" => Some(Self::Unknown),
                "INPUT_OBJECT_STATE_DOES_NOT_EXIST" => Some(Self::DoesNotExist),
                "INPUT_OBJECT_STATE_EXISTS" => Some(Self::Exists),
                _ => None,
            }
        }
    }
    #[non_exhaustive]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OutputObjectState {
        Unknown = 0,
        DoesNotExist = 1,
        ObjectWrite = 2,
    }
    impl OutputObjectState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "OUTPUT_OBJECT_STATE_UNKNOWN",
                Self::DoesNotExist => "OUTPUT_OBJECT_STATE_DOES_NOT_EXIST",
                Self::ObjectWrite => "OUTPUT_OBJECT_STATE_OBJECT_WRITE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OUTPUT_OBJECT_STATE_UNKNOWN" => Some(Self::Unknown),
                "OUTPUT_OBJECT_STATE_DOES_NOT_EXIST" => Some(Self::DoesNotExist),
                "OUTPUT_OBJECT_STATE_OBJECT_WRITE" => Some(Self::ObjectWrite),
                _ => None,
            }
        }
    }
    #[non_exhaustive]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum IdOperation {
        Unknown = 0,
        None = 1,
        Created = 2,
        Deleted = 3,
    }
    impl IdOperation {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "ID_OPERATION_UNKNOWN",
                Self::None => "NONE",
                Self::Created => "CREATED",
                Self::Deleted => "DELETED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ID_OPERATION_UNKNOWN" => Some(Self::Unknown),
                "NONE" => Some(Self::None),
                "CREATED" => Some(Self::Created),
                "DELETED" => Some(Self::Deleted),
                _ => None,
            }
        }
    }
}
/// A shared object that wasn't changed during execution.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnchangedSharedObject {
    #[prost(
        enumeration = "unchanged_shared_object::UnchangedSharedObjectKind",
        optional,
        tag = "1"
    )]
    pub kind: ::core::option::Option<i32>,
    /// ObjectId of the consensus object.
    #[prost(string, optional, tag = "2")]
    pub object_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Version of the consensus object.
    #[prost(uint64, optional, tag = "3")]
    pub version: ::core::option::Option<u64>,
    /// Digest of the consensus object.
    #[prost(string, optional, tag = "4")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Type information is not provided by the effects structure but is instead
    /// provided by an indexing layer
    #[prost(string, optional, tag = "5")]
    pub object_type: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `UnchangedSharedObject`.
pub mod unchanged_shared_object {
    #[non_exhaustive]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UnchangedSharedObjectKind {
        Unknown = 0,
        /// Read-only shared object from the input.
        ReadOnlyRoot = 1,
        /// / Deleted shared objects that appear mutably/owned in the input
        MutatedDeleted = 2,
        /// Deleted shared objects that appear as read-only in the input.
        ReadDeleted = 3,
        /// Consensus objects that were congested and resulted in this transaction being
        /// canceled.
        Canceled = 4,
    }
    impl UnchangedSharedObjectKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNCHANGED_SHARED_OBJECT_KIND_UNKNOWN",
                Self::ReadOnlyRoot => "READ_ONLY_ROOT",
                Self::MutatedDeleted => "MUTATED_DELETED",
                Self::ReadDeleted => "READ_DELETED",
                Self::Canceled => "CANCELED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNCHANGED_SHARED_OBJECT_KIND_UNKNOWN" => Some(Self::Unknown),
                "READ_ONLY_ROOT" => Some(Self::ReadOnlyRoot),
                "MUTATED_DELETED" => Some(Self::MutatedDeleted),
                "READ_DELETED" => Some(Self::ReadDeleted),
                "CANCELED" => Some(Self::Canceled),
                _ => None,
            }
        }
    }
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Epoch {
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    /// The committee governing this epoch.
    #[prost(message, optional, tag = "2")]
    pub committee: ::core::option::Option<ValidatorCommittee>,
    /// Snapshot of SystemState at the
    /// beginning of the epoch, for past epochs, or the current state for the
    /// current epoch.
    #[prost(message, optional, boxed, tag = "3")]
    pub system_state: ::core::option::Option<::prost::alloc::boxed::Box<SystemState>>,
    #[prost(uint64, optional, tag = "4")]
    pub first_checkpoint: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "5")]
    pub last_checkpoint: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "6")]
    pub start: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub end: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub protocol_config: ::core::option::Option<ProtocolConfig>,
}
#[non_exhaustive]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ErrorReason {
    Unknown = 0,
    FieldInvalid = 1,
    FieldMissing = 2,
}
impl ErrorReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "ERROR_REASON_UNKNOWN",
            Self::FieldInvalid => "FIELD_INVALID",
            Self::FieldMissing => "FIELD_MISSING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ERROR_REASON_UNKNOWN" => Some(Self::Unknown),
            "FIELD_INVALID" => Some(Self::FieldInvalid),
            "FIELD_MISSING" => Some(Self::FieldMissing),
            _ => None,
        }
    }
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutedTransaction {
    /// The digest of this Transaction.
    #[prost(string, optional, tag = "1")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// The transaction itself.
    #[prost(message, optional, tag = "2")]
    pub transaction: ::core::option::Option<Transaction>,
    /// List of user signatures that are used to authorize the
    /// execution of this transaction.
    #[prost(message, repeated, tag = "3")]
    pub signatures: ::prost::alloc::vec::Vec<UserSignature>,
    /// The `TransactionEffects` for this transaction.
    #[prost(message, optional, tag = "4")]
    pub effects: ::core::option::Option<TransactionEffects>,
    /// The checkpoint index that includes this transaction.
    #[prost(uint64, optional, tag = "5")]
    pub checkpoint: ::core::option::Option<u64>,
    /// The Unix timestamp of the checkpoint that includes this transaction.
    #[prost(message, optional, tag = "6")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, repeated, tag = "7")]
    pub balance_changes: ::prost::alloc::vec::Vec<BalanceChange>,
    /// Set of objects either referenced as inputs or produced as
    /// outputs from this Transaction.
    #[prost(message, optional, tag = "9")]
    pub objects: ::core::option::Option<ObjectSet>,
}
/// The status of an executed transaction.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutionStatus {
    /// Indicates if the transaction was successful or not.
    #[prost(bool, optional, tag = "1")]
    pub success: ::core::option::Option<bool>,
    /// The error if `success` is false.
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<ExecutionError>,
}
/// An error that can occur during the execution of a transaction.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutionError {
    /// A human readable description of the error
    #[prost(string, optional, tag = "1")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "execution_error::ExecutionErrorKind", optional, tag = "2")]
    pub kind: ::core::option::Option<i32>,
    #[prost(oneof = "execution_error::ErrorDetails", tags = "3, 4")]
    pub error_details: ::core::option::Option<execution_error::ErrorDetails>,
}
/// Nested message and enum types in `ExecutionError`.
pub mod execution_error {
    #[non_exhaustive]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExecutionErrorKind {
        Unknown = 0,
        /// Insufficient gas.
        InsufficientGas = 1,
        /// Invalid owner for object.
        InvalidOwnership = 2,
        /// Object not found.
        ObjectNotFound = 3,
        /// Invalid object type.
        InvalidObjectType = 4,
        /// Invalid transaction type
        InvalidTransactionType = 5,
        /// Invalid arguments for transaction
        InvalidArguments = 6,
        /// Adding avalidator that already exists
        DuplicateValidator = 7,
        /// Trying to remove a validator that doesn't exist
        NotAValidator = 8,
        /// Removing a validator that was already removed
        ValidatorAlreadyRemoved = 9,
        /// Advancing to unexpected epoch
        AdvancedToWrongEpoch = 10,
        /// Adding an encoder that already exists
        DuplicateEncoder = 11,
        /// Removing an encoder that doesn't exist
        NotAnEncoder = 12,
        /// Removing an encoder already removed
        EncoderAlreadyRemoved = 13,
        /// Insufficient coin balance for requested operation.
        InsufficientCoinBalance = 14,
        /// Coin balance overflowed an u64.
        CoinBalanceOverflow = 15,
        /// Validator not found
        ValidatorNotFound = 16,
        /// Encoder not found
        EncoderNotFound = 17,
        /// Staking pool not found
        StakingPoolNotFound = 18,
        /// Validator cannot report oneself
        CannotReportOneself = 19,
        /// Unreported record cannot be undone
        ReportRecordNotFound = 20,
        InputObjectDeleted = 21,
        CertificateDenied = 22,
        SharedObjectCongestion = 23,
        /// Other error.
        OtherError = 24,
    }
    impl ExecutionErrorKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "EXECUTION_ERROR_KIND_UNKNOWN",
                Self::InsufficientGas => "INSUFFICIENT_GAS",
                Self::InvalidOwnership => "INVALID_OWNERSHIP",
                Self::ObjectNotFound => "OBJECT_NOT_FOUND",
                Self::InvalidObjectType => "INVALID_OBJECT_TYPE",
                Self::InvalidTransactionType => "INVALID_TRANSACTION_TYPE",
                Self::InvalidArguments => "INVALID_ARGUMENTS",
                Self::DuplicateValidator => "DUPLICATE_VALIDATOR",
                Self::NotAValidator => "NOT_A_VALIDATOR",
                Self::ValidatorAlreadyRemoved => "VALIDATOR_ALREADY_REMOVED",
                Self::AdvancedToWrongEpoch => "ADVANCED_TO_WRONG_EPOCH",
                Self::DuplicateEncoder => "DUPLICATE_ENCODER",
                Self::NotAnEncoder => "NOT_AN_ENCODER",
                Self::EncoderAlreadyRemoved => "ENCODER_ALREADY_REMOVED",
                Self::InsufficientCoinBalance => "INSUFFICIENT_COIN_BALANCE",
                Self::CoinBalanceOverflow => "COIN_BALANCE_OVERFLOW",
                Self::ValidatorNotFound => "VALIDATOR_NOT_FOUND",
                Self::EncoderNotFound => "ENCODER_NOT_FOUND",
                Self::StakingPoolNotFound => "STAKING_POOL_NOT_FOUND",
                Self::CannotReportOneself => "CANNOT_REPORT_ONESELF",
                Self::ReportRecordNotFound => "REPORT_RECORD_NOT_FOUND",
                Self::InputObjectDeleted => "INPUT_OBJECT_DELETED",
                Self::CertificateDenied => "CERTIFICATE_DENIED",
                Self::SharedObjectCongestion => "SHARED_OBJECT_CONGESTION",
                Self::OtherError => "OTHER_ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EXECUTION_ERROR_KIND_UNKNOWN" => Some(Self::Unknown),
                "INSUFFICIENT_GAS" => Some(Self::InsufficientGas),
                "INVALID_OWNERSHIP" => Some(Self::InvalidOwnership),
                "OBJECT_NOT_FOUND" => Some(Self::ObjectNotFound),
                "INVALID_OBJECT_TYPE" => Some(Self::InvalidObjectType),
                "INVALID_TRANSACTION_TYPE" => Some(Self::InvalidTransactionType),
                "INVALID_ARGUMENTS" => Some(Self::InvalidArguments),
                "DUPLICATE_VALIDATOR" => Some(Self::DuplicateValidator),
                "NOT_A_VALIDATOR" => Some(Self::NotAValidator),
                "VALIDATOR_ALREADY_REMOVED" => Some(Self::ValidatorAlreadyRemoved),
                "ADVANCED_TO_WRONG_EPOCH" => Some(Self::AdvancedToWrongEpoch),
                "DUPLICATE_ENCODER" => Some(Self::DuplicateEncoder),
                "NOT_AN_ENCODER" => Some(Self::NotAnEncoder),
                "ENCODER_ALREADY_REMOVED" => Some(Self::EncoderAlreadyRemoved),
                "INSUFFICIENT_COIN_BALANCE" => Some(Self::InsufficientCoinBalance),
                "COIN_BALANCE_OVERFLOW" => Some(Self::CoinBalanceOverflow),
                "VALIDATOR_NOT_FOUND" => Some(Self::ValidatorNotFound),
                "ENCODER_NOT_FOUND" => Some(Self::EncoderNotFound),
                "STAKING_POOL_NOT_FOUND" => Some(Self::StakingPoolNotFound),
                "CANNOT_REPORT_ONESELF" => Some(Self::CannotReportOneself),
                "REPORT_RECORD_NOT_FOUND" => Some(Self::ReportRecordNotFound),
                "INPUT_OBJECT_DELETED" => Some(Self::InputObjectDeleted),
                "CERTIFICATE_DENIED" => Some(Self::CertificateDenied),
                "SHARED_OBJECT_CONGESTION" => Some(Self::SharedObjectCongestion),
                "OTHER_ERROR" => Some(Self::OtherError),
                _ => None,
            }
        }
    }
    #[non_exhaustive]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ErrorDetails {
        #[prost(string, tag = "3")]
        ObjectId(::prost::alloc::string::String),
        #[prost(string, tag = "4")]
        OtherError(::prost::alloc::string::String),
    }
}
#[non_exhaustive]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetServiceInfoRequest {}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetServiceInfoResponse {
    /// The chain identifier of the chain that this node is on.
    ///
    /// The chain identifier is the digest of the genesis checkpoint, the
    /// checkpoint with sequence number 0.
    #[prost(string, optional, tag = "1")]
    pub chain_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Human-readable name of the chain that this node is on.
    ///
    /// This is intended to be a human-readable name like `mainnet`, `testnet`, and so on.
    #[prost(string, optional, tag = "2")]
    pub chain: ::core::option::Option<::prost::alloc::string::String>,
    /// Current epoch of the node based on its highest executed checkpoint.
    #[prost(uint64, optional, tag = "3")]
    pub epoch: ::core::option::Option<u64>,
    /// Checkpoint height of the most recently executed checkpoint.
    #[prost(uint64, optional, tag = "4")]
    pub checkpoint_height: ::core::option::Option<u64>,
    /// Unix timestamp of the most recently executed checkpoint.
    #[prost(message, optional, tag = "5")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// The lowest checkpoint for which checkpoints and transaction data are available.
    #[prost(uint64, optional, tag = "6")]
    pub lowest_available_checkpoint: ::core::option::Option<u64>,
    /// The lowest checkpoint for which object data is available.
    #[prost(uint64, optional, tag = "7")]
    pub lowest_available_checkpoint_objects: ::core::option::Option<u64>,
    /// Software version of the service. Similar to the `server` http header.
    #[prost(string, optional, tag = "8")]
    pub server: ::core::option::Option<::prost::alloc::string::String>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetObjectRequest {
    /// Required. The `ObjectId` of the requested object.
    #[prost(string, optional, tag = "1")]
    pub object_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Request a specific version of the object.
    /// If no version is specified, and the object is live, then the latest
    /// version of the object is returned.
    #[prost(uint64, optional, tag = "2")]
    pub version: ::core::option::Option<u64>,
    /// Mask specifying which fields to read.
    /// If no mask is specified, defaults to `object_id,version,digest`.
    #[prost(message, optional, tag = "3")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetObjectResponse {
    #[prost(message, optional, tag = "1")]
    pub object: ::core::option::Option<Object>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchGetObjectsRequest {
    #[prost(message, repeated, tag = "1")]
    pub requests: ::prost::alloc::vec::Vec<GetObjectRequest>,
    /// Mask specifying which fields to read.
    /// If no mask is specified, defaults to `object_id,version,digest`.
    #[prost(message, optional, tag = "2")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchGetObjectsResponse {
    #[prost(message, repeated, tag = "1")]
    pub objects: ::prost::alloc::vec::Vec<GetObjectResult>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetObjectResult {
    #[prost(oneof = "get_object_result::Result", tags = "1, 2")]
    pub result: ::core::option::Option<get_object_result::Result>,
}
/// Nested message and enum types in `GetObjectResult`.
pub mod get_object_result {
    #[non_exhaustive]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(message, tag = "1")]
        Object(super::Object),
        #[prost(message, tag = "2")]
        Error(crate::proto::google::rpc::Status),
    }
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTransactionRequest {
    /// Required. The digest of the requested transaction.
    #[prost(string, optional, tag = "1")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Mask specifying which fields to read.
    /// If no mask is specified, defaults to `digest`.
    #[prost(message, optional, tag = "2")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTransactionResponse {
    #[prost(message, optional, tag = "1")]
    pub transaction: ::core::option::Option<ExecutedTransaction>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchGetTransactionsRequest {
    /// Required. The digests of the requested transactions.
    #[prost(string, repeated, tag = "1")]
    pub digests: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Mask specifying which fields to read.
    /// If no mask is specified, defaults to `digest`.
    #[prost(message, optional, tag = "2")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchGetTransactionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub transactions: ::prost::alloc::vec::Vec<GetTransactionResult>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTransactionResult {
    #[prost(oneof = "get_transaction_result::Result", tags = "1, 2")]
    pub result: ::core::option::Option<get_transaction_result::Result>,
}
/// Nested message and enum types in `GetTransactionResult`.
pub mod get_transaction_result {
    #[non_exhaustive]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(message, tag = "1")]
        Transaction(super::ExecutedTransaction),
        #[prost(message, tag = "2")]
        Error(crate::proto::google::rpc::Status),
    }
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCheckpointRequest {
    /// Mask specifying which fields to read.
    /// If no mask is specified, defaults to `sequence_number,digest`.
    #[prost(message, optional, tag = "3")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// If neither is provided, return the latest
    #[prost(oneof = "get_checkpoint_request::CheckpointId", tags = "1, 2")]
    pub checkpoint_id: ::core::option::Option<get_checkpoint_request::CheckpointId>,
}
/// Nested message and enum types in `GetCheckpointRequest`.
pub mod get_checkpoint_request {
    /// If neither is provided, return the latest
    #[non_exhaustive]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum CheckpointId {
        /// The sequence number of the requested checkpoint.
        #[prost(uint64, tag = "1")]
        SequenceNumber(u64),
        /// The digest of the requested checkpoint.
        #[prost(string, tag = "2")]
        Digest(::prost::alloc::string::String),
    }
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCheckpointResponse {
    #[prost(message, optional, tag = "1")]
    pub checkpoint: ::core::option::Option<Checkpoint>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEpochRequest {
    /// The requested epoch.
    /// If no epoch is provided the current epoch will be returned.
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    /// Mask specifying which fields to read.
    /// If no mask is specified, defaults to `epoch`.
    #[prost(message, optional, tag = "2")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEpochResponse {
    #[prost(message, optional, tag = "1")]
    pub epoch: ::core::option::Option<Epoch>,
}
/// Generated client implementations.
pub mod ledger_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct LedgerServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl LedgerServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> LedgerServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> LedgerServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            LedgerServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Query the service for general information about its current state.
        pub async fn get_service_info(
            &mut self,
            request: impl tonic::IntoRequest<super::GetServiceInfoRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetServiceInfoResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/soma.rpc.LedgerService/GetServiceInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("soma.rpc.LedgerService", "GetServiceInfo"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_object(
            &mut self,
            request: impl tonic::IntoRequest<super::GetObjectRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetObjectResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/soma.rpc.LedgerService/GetObject",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("soma.rpc.LedgerService", "GetObject"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn batch_get_objects(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchGetObjectsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchGetObjectsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/soma.rpc.LedgerService/BatchGetObjects",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("soma.rpc.LedgerService", "BatchGetObjects"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_transaction(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTransactionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetTransactionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/soma.rpc.LedgerService/GetTransaction",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("soma.rpc.LedgerService", "GetTransaction"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn batch_get_transactions(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchGetTransactionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchGetTransactionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/soma.rpc.LedgerService/BatchGetTransactions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("soma.rpc.LedgerService", "BatchGetTransactions"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_checkpoint(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCheckpointRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetCheckpointResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/soma.rpc.LedgerService/GetCheckpoint",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("soma.rpc.LedgerService", "GetCheckpoint"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_epoch(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEpochRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetEpochResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/soma.rpc.LedgerService/GetEpoch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("soma.rpc.LedgerService", "GetEpoch"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod ledger_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with LedgerServiceServer.
    #[async_trait]
    pub trait LedgerService: std::marker::Send + std::marker::Sync + 'static {
        /// Query the service for general information about its current state.
        async fn get_service_info(
            &self,
            request: tonic::Request<super::GetServiceInfoRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetServiceInfoResponse>,
            tonic::Status,
        >;
        async fn get_object(
            &self,
            request: tonic::Request<super::GetObjectRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetObjectResponse>,
            tonic::Status,
        >;
        async fn batch_get_objects(
            &self,
            request: tonic::Request<super::BatchGetObjectsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchGetObjectsResponse>,
            tonic::Status,
        >;
        async fn get_transaction(
            &self,
            request: tonic::Request<super::GetTransactionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetTransactionResponse>,
            tonic::Status,
        >;
        async fn batch_get_transactions(
            &self,
            request: tonic::Request<super::BatchGetTransactionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchGetTransactionsResponse>,
            tonic::Status,
        >;
        async fn get_checkpoint(
            &self,
            request: tonic::Request<super::GetCheckpointRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetCheckpointResponse>,
            tonic::Status,
        >;
        async fn get_epoch(
            &self,
            request: tonic::Request<super::GetEpochRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetEpochResponse>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct LedgerServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> LedgerServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for LedgerServiceServer<T>
    where
        T: LedgerService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/soma.rpc.LedgerService/GetServiceInfo" => {
                    #[allow(non_camel_case_types)]
                    struct GetServiceInfoSvc<T: LedgerService>(pub Arc<T>);
                    impl<
                        T: LedgerService,
                    > tonic::server::UnaryService<super::GetServiceInfoRequest>
                    for GetServiceInfoSvc<T> {
                        type Response = super::GetServiceInfoResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetServiceInfoRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LedgerService>::get_service_info(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetServiceInfoSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/soma.rpc.LedgerService/GetObject" => {
                    #[allow(non_camel_case_types)]
                    struct GetObjectSvc<T: LedgerService>(pub Arc<T>);
                    impl<
                        T: LedgerService,
                    > tonic::server::UnaryService<super::GetObjectRequest>
                    for GetObjectSvc<T> {
                        type Response = super::GetObjectResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetObjectRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LedgerService>::get_object(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetObjectSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/soma.rpc.LedgerService/BatchGetObjects" => {
                    #[allow(non_camel_case_types)]
                    struct BatchGetObjectsSvc<T: LedgerService>(pub Arc<T>);
                    impl<
                        T: LedgerService,
                    > tonic::server::UnaryService<super::BatchGetObjectsRequest>
                    for BatchGetObjectsSvc<T> {
                        type Response = super::BatchGetObjectsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::BatchGetObjectsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LedgerService>::batch_get_objects(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = BatchGetObjectsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/soma.rpc.LedgerService/GetTransaction" => {
                    #[allow(non_camel_case_types)]
                    struct GetTransactionSvc<T: LedgerService>(pub Arc<T>);
                    impl<
                        T: LedgerService,
                    > tonic::server::UnaryService<super::GetTransactionRequest>
                    for GetTransactionSvc<T> {
                        type Response = super::GetTransactionResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetTransactionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LedgerService>::get_transaction(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetTransactionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/soma.rpc.LedgerService/BatchGetTransactions" => {
                    #[allow(non_camel_case_types)]
                    struct BatchGetTransactionsSvc<T: LedgerService>(pub Arc<T>);
                    impl<
                        T: LedgerService,
                    > tonic::server::UnaryService<super::BatchGetTransactionsRequest>
                    for BatchGetTransactionsSvc<T> {
                        type Response = super::BatchGetTransactionsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::BatchGetTransactionsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LedgerService>::batch_get_transactions(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = BatchGetTransactionsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/soma.rpc.LedgerService/GetCheckpoint" => {
                    #[allow(non_camel_case_types)]
                    struct GetCheckpointSvc<T: LedgerService>(pub Arc<T>);
                    impl<
                        T: LedgerService,
                    > tonic::server::UnaryService<super::GetCheckpointRequest>
                    for GetCheckpointSvc<T> {
                        type Response = super::GetCheckpointResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetCheckpointRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LedgerService>::get_checkpoint(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetCheckpointSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/soma.rpc.LedgerService/GetEpoch" => {
                    #[allow(non_camel_case_types)]
                    struct GetEpochSvc<T: LedgerService>(pub Arc<T>);
                    impl<
                        T: LedgerService,
                    > tonic::server::UnaryService<super::GetEpochRequest>
                    for GetEpochSvc<T> {
                        type Response = super::GetEpochResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetEpochRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LedgerService>::get_epoch(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetEpochSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(
                            tonic::body::Body::default(),
                        );
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for LedgerServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "soma.rpc.LedgerService";
    impl<T> tonic::server::NamedService for LedgerServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// An object on the Sui blockchain.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Object {
    /// `ObjectId` for this object.
    #[prost(string, optional, tag = "1")]
    pub object_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Version of the object.
    #[prost(uint64, optional, tag = "2")]
    pub version: ::core::option::Option<u64>,
    /// The digest of this Object.
    #[prost(string, optional, tag = "3")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Owner of the object.
    #[prost(message, optional, tag = "4")]
    pub owner: ::core::option::Option<Owner>,
    /// The type of this object.
    #[prost(string, optional, tag = "5")]
    pub object_type: ::core::option::Option<::prost::alloc::string::String>,
    /// BCS bytes of a struct value.
    #[prost(bytes = "bytes", optional, tag = "6")]
    pub contents: ::core::option::Option<::prost::bytes::Bytes>,
    /// The digest of the transaction that created or last mutated this object
    #[prost(string, optional, tag = "7")]
    pub previous_transaction: ::core::option::Option<::prost::alloc::string::String>,
}
/// Set of Objects
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectSet {
    /// Objects are sorted by the key `(object_id, version)`.
    #[prost(message, repeated, tag = "1")]
    pub objects: ::prost::alloc::vec::Vec<Object>,
}
/// Reference to an object.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectReference {
    /// The object id of this object.
    #[prost(string, optional, tag = "1")]
    pub object_id: ::core::option::Option<::prost::alloc::string::String>,
    /// The version of this object.
    #[prost(uint64, optional, tag = "2")]
    pub version: ::core::option::Option<u64>,
    /// The digest of this object.
    #[prost(string, optional, tag = "3")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
}
/// Enum of different types of ownership for an object.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Owner {
    #[prost(enumeration = "owner::OwnerKind", optional, tag = "1")]
    pub kind: ::core::option::Option<i32>,
    /// Address or ObjectId of the owner
    #[prost(string, optional, tag = "2")]
    pub address: ::core::option::Option<::prost::alloc::string::String>,
    /// The `initial_shared_version` if kind is `SHARED`.
    #[prost(uint64, optional, tag = "3")]
    pub version: ::core::option::Option<u64>,
}
/// Nested message and enum types in `Owner`.
pub mod owner {
    #[non_exhaustive]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OwnerKind {
        Unknown = 0,
        Address = 1,
        Shared = 2,
        Immutable = 3,
    }
    impl OwnerKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "OWNER_KIND_UNKNOWN",
                Self::Address => "ADDRESS",
                Self::Shared => "SHARED",
                Self::Immutable => "IMMUTABLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OWNER_KIND_UNKNOWN" => Some(Self::Unknown),
                "ADDRESS" => Some(Self::Address),
                "SHARED" => Some(Self::Shared),
                "IMMUTABLE" => Some(Self::Immutable),
                _ => None,
            }
        }
    }
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtocolConfig {
    #[prost(uint64, optional, tag = "1")]
    pub protocol_version: ::core::option::Option<u64>,
    #[prost(btree_map = "string, bool", tag = "2")]
    pub feature_flags: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        bool,
    >,
    #[prost(btree_map = "string, string", tag = "3")]
    pub attributes: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Shard {
    #[prost(uint32, optional, tag = "1")]
    pub quorum_threshold: ::core::option::Option<u32>,
    #[prost(string, repeated, tag = "2")]
    pub encoders: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bytes = "bytes", optional, tag = "3")]
    pub seed: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(uint64, optional, tag = "4")]
    pub epoch: ::core::option::Option<u64>,
}
/// A signature from a user.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserSignature {
    /// The signature scheme of this signature.
    #[prost(enumeration = "SignatureScheme", optional, tag = "1")]
    pub scheme: ::core::option::Option<i32>,
    #[prost(oneof = "user_signature::Signature", tags = "2, 3")]
    pub signature: ::core::option::Option<user_signature::Signature>,
}
/// Nested message and enum types in `UserSignature`.
pub mod user_signature {
    #[non_exhaustive]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Signature {
        /// Simple signature if scheme is ed25519.
        #[prost(message, tag = "2")]
        Simple(super::SimpleSignature),
        /// The multisig aggregated signature if scheme is `MULTISIG`.
        #[prost(message, tag = "3")]
        Multisig(super::MultisigAggregatedSignature),
    }
}
/// Either an ed25519, secp256k1 or secp256r1 signature
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SimpleSignature {
    /// The signature scheme of this signature.
    #[prost(enumeration = "SignatureScheme", optional, tag = "1")]
    pub scheme: ::core::option::Option<i32>,
    /// Signature bytes
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub signature: ::core::option::Option<::prost::bytes::Bytes>,
    /// Public key bytes
    #[prost(bytes = "bytes", optional, tag = "3")]
    pub public_key: ::core::option::Option<::prost::bytes::Bytes>,
}
/// Set of valid public keys for multisig committee members.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultisigMemberPublicKey {
    /// The signature scheme of this public key.
    #[prost(enumeration = "SignatureScheme", optional, tag = "1")]
    pub scheme: ::core::option::Option<i32>,
    /// Public key bytes if scheme is ed25519.
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub public_key: ::core::option::Option<::prost::bytes::Bytes>,
}
/// A member in a multisig committee.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultisigMember {
    /// The public key of the committee member.
    #[prost(message, optional, tag = "1")]
    pub public_key: ::core::option::Option<MultisigMemberPublicKey>,
    /// The weight of this member's signature.
    #[prost(uint32, optional, tag = "2")]
    pub weight: ::core::option::Option<u32>,
}
/// A multisig committee.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultisigCommittee {
    /// A list of committee members and their corresponding weight.
    #[prost(message, repeated, tag = "1")]
    pub members: ::prost::alloc::vec::Vec<MultisigMember>,
    /// The threshold of signatures needed to validate a signature from
    /// this committee.
    #[prost(uint32, optional, tag = "2")]
    pub threshold: ::core::option::Option<u32>,
}
/// Aggregated signature from members of a multisig committee.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultisigAggregatedSignature {
    /// The plain signatures encoded with signature scheme.
    ///
    /// The signatures must be in the same order as they are listed in the committee.
    #[prost(message, repeated, tag = "1")]
    pub signatures: ::prost::alloc::vec::Vec<MultisigMemberSignature>,
    /// Bitmap indicating which committee members contributed to the
    /// signature.
    #[prost(uint32, optional, tag = "2")]
    pub bitmap: ::core::option::Option<u32>,
    /// The committee to use to validate this signature.
    #[prost(message, optional, tag = "3")]
    pub committee: ::core::option::Option<MultisigCommittee>,
}
/// A signature from a member of a multisig committee.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultisigMemberSignature {
    /// The signature scheme of this signature.
    #[prost(enumeration = "SignatureScheme", optional, tag = "1")]
    pub scheme: ::core::option::Option<i32>,
    /// Signature bytes if scheme is ed25519.
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub signature: ::core::option::Option<::prost::bytes::Bytes>,
}
/// The validator set for a particular epoch.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatorCommittee {
    /// The epoch where this committee governs.
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    /// The committee members.
    #[prost(message, repeated, tag = "2")]
    pub members: ::prost::alloc::vec::Vec<ValidatorCommitteeMember>,
}
/// A member of a validator committee with full authority information.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatorCommitteeMember {
    /// The BLS12381 public key bytes (becomes AuthorityName)
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub authority_key: ::core::option::Option<::prost::bytes::Bytes>,
    /// Voting weight this validator possesses.
    #[prost(uint64, optional, tag = "2")]
    pub weight: ::core::option::Option<u64>,
    /// Network metadata for this validator
    #[prost(message, optional, tag = "3")]
    pub network_metadata: ::core::option::Option<ValidatorNetworkMetadata>,
}
/// Network and protocol information for a validator
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatorNetworkMetadata {
    /// Multiaddr for consensus communication (as string)
    #[prost(string, optional, tag = "1")]
    pub consensus_address: ::core::option::Option<::prost::alloc::string::String>,
    /// Hostname for metrics and logging
    #[prost(string, optional, tag = "2")]
    pub hostname: ::core::option::Option<::prost::alloc::string::String>,
    /// Ed25519 protocol public key bytes
    #[prost(bytes = "bytes", optional, tag = "3")]
    pub protocol_key: ::core::option::Option<::prost::bytes::Bytes>,
    /// Ed25519 network public key bytes
    #[prost(bytes = "bytes", optional, tag = "4")]
    pub network_key: ::core::option::Option<::prost::bytes::Bytes>,
}
/// / An aggregated signature from multiple validators.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatorAggregatedSignature {
    /// The epoch when this signature was produced.
    ///
    /// This can be used to lookup the `ValidatorCommittee` from this epoch
    /// to verify this signature.
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    /// The 48-byte Bls12381 aggregated signature.
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub signature: ::core::option::Option<::prost::bytes::Bytes>,
    /// Bitmap indicating which members of the committee contributed to
    /// this signature.
    #[prost(uint32, repeated, tag = "3")]
    pub bitmap: ::prost::alloc::vec::Vec<u32>,
}
/// Flag use to disambiguate the signature schemes supported by Soma.
///
/// Note: the enum values defined by this proto message exactly match their
/// expected BCS serialized values when serialized as a u8.
#[non_exhaustive]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SignatureScheme {
    Ed25519 = 0,
    Bls12381 = 1,
    Multisig = 2,
}
impl SignatureScheme {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Ed25519 => "ED25519",
            Self::Bls12381 => "BLS12381",
            Self::Multisig => "MULTISIG",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ED25519" => Some(Self::Ed25519),
            "BLS12381" => Some(Self::Bls12381),
            "MULTISIG" => Some(Self::Multisig),
            _ => None,
        }
    }
}
/// Request message for `LiveDataService.GetBalance`.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBalanceRequest {
    /// Required. The owner's Sui address.
    #[prost(string, optional, tag = "1")]
    pub owner: ::core::option::Option<::prost::alloc::string::String>,
}
/// Response message for `LiveDataService.GetBalance`.
/// Return the total coin balance for coin, owned by the address owner.
#[non_exhaustive]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetBalanceResponse {
    #[prost(uint64, optional, tag = "1")]
    pub balance: ::core::option::Option<u64>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListOwnedObjectsRequest {
    /// Required. The address of the account that owns the objects.
    #[prost(string, optional, tag = "1")]
    pub owner: ::core::option::Option<::prost::alloc::string::String>,
    /// The maximum number of entries return. The service may return fewer than this value.
    /// If unspecified, at most `50` entries will be returned.
    /// The maximum value is `1000`; values above `1000` will be coerced to `1000`.
    #[prost(uint32, optional, tag = "2")]
    pub page_size: ::core::option::Option<u32>,
    /// A page token, received from a previous `ListOwnedObjects` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListOwnedObjects` must
    /// match the call that provided the page token.
    #[prost(bytes = "bytes", optional, tag = "3")]
    pub page_token: ::core::option::Option<::prost::bytes::Bytes>,
    /// Mask specifying which fields to read.
    /// If no mask is specified, defaults to `object_id,version,object_type`.
    #[prost(message, optional, tag = "4")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Optional type filter to limit the types of objects listed.
    ///
    /// Providing an object type with no type params will return objects of that
    /// type with any type parameter.
    #[prost(string, optional, tag = "5")]
    pub object_type: ::core::option::Option<::prost::alloc::string::String>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListOwnedObjectsResponse {
    /// Page of dynamic fields owned by the specified parent.
    #[prost(message, repeated, tag = "1")]
    pub objects: ::prost::alloc::vec::Vec<Object>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub next_page_token: ::core::option::Option<::prost::bytes::Bytes>,
}
/// Generated client implementations.
pub mod state_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct StateServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl StateServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> StateServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> StateServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            StateServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn list_owned_objects(
            &mut self,
            request: impl tonic::IntoRequest<super::ListOwnedObjectsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListOwnedObjectsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/soma.rpc.StateService/ListOwnedObjects",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("soma.rpc.StateService", "ListOwnedObjects"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_balance(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBalanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetBalanceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/soma.rpc.StateService/GetBalance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("soma.rpc.StateService", "GetBalance"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod state_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with StateServiceServer.
    #[async_trait]
    pub trait StateService: std::marker::Send + std::marker::Sync + 'static {
        async fn list_owned_objects(
            &self,
            request: tonic::Request<super::ListOwnedObjectsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListOwnedObjectsResponse>,
            tonic::Status,
        >;
        async fn get_balance(
            &self,
            request: tonic::Request<super::GetBalanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetBalanceResponse>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct StateServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> StateServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for StateServiceServer<T>
    where
        T: StateService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/soma.rpc.StateService/ListOwnedObjects" => {
                    #[allow(non_camel_case_types)]
                    struct ListOwnedObjectsSvc<T: StateService>(pub Arc<T>);
                    impl<
                        T: StateService,
                    > tonic::server::UnaryService<super::ListOwnedObjectsRequest>
                    for ListOwnedObjectsSvc<T> {
                        type Response = super::ListOwnedObjectsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListOwnedObjectsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StateService>::list_owned_objects(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListOwnedObjectsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/soma.rpc.StateService/GetBalance" => {
                    #[allow(non_camel_case_types)]
                    struct GetBalanceSvc<T: StateService>(pub Arc<T>);
                    impl<
                        T: StateService,
                    > tonic::server::UnaryService<super::GetBalanceRequest>
                    for GetBalanceSvc<T> {
                        type Response = super::GetBalanceResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetBalanceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StateService>::get_balance(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetBalanceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(
                            tonic::body::Body::default(),
                        );
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for StateServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "soma.rpc.StateService";
    impl<T> tonic::server::NamedService for StateServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for SubscriptionService.SubscribeCheckpoints
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeCheckpointsRequest {
    /// Optional. Mask for specifying which parts of the
    /// SubscribeCheckpointsResponse should be returned.
    #[prost(message, optional, tag = "1")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Response message for SubscriptionService.SubscribeCheckpoints
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeCheckpointsResponse {
    /// Required. The checkpoint sequence number and value of the current cursor
    /// into the checkpoint stream
    #[prost(uint64, optional, tag = "1")]
    pub cursor: ::core::option::Option<u64>,
    /// The requested data for this checkpoint
    #[prost(message, optional, tag = "2")]
    pub checkpoint: ::core::option::Option<Checkpoint>,
}
/// Generated client implementations.
pub mod subscription_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct SubscriptionServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SubscriptionServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SubscriptionServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SubscriptionServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SubscriptionServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Subscribe to the stream of checkpoints.
        ///
        /// This API provides a subscription to the checkpoint stream for the Sui
        /// blockchain. When a subscription is initialized the stream will begin with
        /// the latest executed checkpoint as seen by the server. Responses are
        /// guaranteed to return checkpoints in-order and without gaps. This enables
        /// clients to know exactly the last checkpoint they have processed and in the
        /// event the subscription terminates (either by the client/server or by the
        /// connection breaking), clients will be able to reinitialize a subscription
        /// and then leverage other APIs in order to request data for the checkpoints
        /// they missed.
        pub async fn subscribe_checkpoints(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribeCheckpointsRequest>,
        ) -> std::result::Result<
            tonic::Response<
                tonic::codec::Streaming<super::SubscribeCheckpointsResponse>,
            >,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/soma.rpc.SubscriptionService/SubscribeCheckpoints",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "soma.rpc.SubscriptionService",
                        "SubscribeCheckpoints",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod subscription_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with SubscriptionServiceServer.
    #[async_trait]
    pub trait SubscriptionService: std::marker::Send + std::marker::Sync + 'static {
        /// Server streaming response type for the SubscribeCheckpoints method.
        type SubscribeCheckpointsStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<
                    super::SubscribeCheckpointsResponse,
                    tonic::Status,
                >,
            >
            + std::marker::Send
            + 'static;
        /// Subscribe to the stream of checkpoints.
        ///
        /// This API provides a subscription to the checkpoint stream for the Sui
        /// blockchain. When a subscription is initialized the stream will begin with
        /// the latest executed checkpoint as seen by the server. Responses are
        /// guaranteed to return checkpoints in-order and without gaps. This enables
        /// clients to know exactly the last checkpoint they have processed and in the
        /// event the subscription terminates (either by the client/server or by the
        /// connection breaking), clients will be able to reinitialize a subscription
        /// and then leverage other APIs in order to request data for the checkpoints
        /// they missed.
        async fn subscribe_checkpoints(
            &self,
            request: tonic::Request<super::SubscribeCheckpointsRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::SubscribeCheckpointsStream>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct SubscriptionServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> SubscriptionServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for SubscriptionServiceServer<T>
    where
        T: SubscriptionService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/soma.rpc.SubscriptionService/SubscribeCheckpoints" => {
                    #[allow(non_camel_case_types)]
                    struct SubscribeCheckpointsSvc<T: SubscriptionService>(pub Arc<T>);
                    impl<
                        T: SubscriptionService,
                    > tonic::server::ServerStreamingService<
                        super::SubscribeCheckpointsRequest,
                    > for SubscribeCheckpointsSvc<T> {
                        type Response = super::SubscribeCheckpointsResponse;
                        type ResponseStream = T::SubscribeCheckpointsStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SubscribeCheckpointsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SubscriptionService>::subscribe_checkpoints(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SubscribeCheckpointsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(
                            tonic::body::Body::default(),
                        );
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for SubscriptionServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "soma.rpc.SubscriptionService";
    impl<T> tonic::server::NamedService for SubscriptionServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SystemState {
    /// Core epoch information
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub epoch_start_timestamp_ms: ::core::option::Option<u64>,
    /// The protocol version
    #[prost(uint64, optional, tag = "3")]
    pub protocol_version: ::core::option::Option<u64>,
    /// System parameters
    #[prost(message, optional, tag = "4")]
    pub parameters: ::core::option::Option<SystemParameters>,
    /// Validator and encoder sets
    #[prost(message, optional, tag = "5")]
    pub validators: ::core::option::Option<ValidatorSet>,
    #[prost(message, optional, tag = "6")]
    pub encoders: ::core::option::Option<EncoderSet>,
    /// Report records
    #[prost(btree_map = "string, message", tag = "7")]
    pub validator_report_records: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ReporterSet,
    >,
    #[prost(btree_map = "string, message", tag = "8")]
    pub encoder_report_records: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ReporterSet,
    >,
    /// Emission pool
    #[prost(message, optional, tag = "9")]
    pub emission_pool: ::core::option::Option<EmissionPool>,
    /// Shard results (digest -> result)
    #[prost(btree_map = "string, message", tag = "10")]
    pub shard_results: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ShardResult,
    >,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReporterSet {
    #[prost(string, repeated, tag = "1")]
    pub reporters: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[non_exhaustive]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SystemParameters {
    #[prost(uint64, optional, tag = "1")]
    pub epoch_duration_ms: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub vdf_iterations: ::core::option::Option<u64>,
}
#[non_exhaustive]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EmissionPool {
    #[prost(uint64, optional, tag = "1")]
    pub balance: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub emission_per_epoch: ::core::option::Option<u64>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatorSet {
    #[prost(uint64, optional, tag = "1")]
    pub total_stake: ::core::option::Option<u64>,
    #[prost(message, repeated, tag = "2")]
    pub consensus_validators: ::prost::alloc::vec::Vec<Validator>,
    #[prost(message, repeated, tag = "3")]
    pub networking_validators: ::prost::alloc::vec::Vec<Validator>,
    #[prost(message, repeated, tag = "4")]
    pub pending_validators: ::prost::alloc::vec::Vec<Validator>,
    #[prost(message, repeated, tag = "5")]
    pub pending_removals: ::prost::alloc::vec::Vec<PendingRemoval>,
    /// pool_id -> validator_address
    #[prost(btree_map = "string, string", tag = "6")]
    pub staking_pool_mappings: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// pool_id -> validator
    #[prost(btree_map = "string, message", tag = "7")]
    pub inactive_validators: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        Validator,
    >,
    /// address -> epochs_at_risk
    #[prost(btree_map = "string, uint64", tag = "8")]
    pub at_risk_validators: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        u64,
    >,
}
#[non_exhaustive]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PendingRemoval {
    #[prost(bool, optional, tag = "1")]
    pub is_consensus: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "2")]
    pub index: ::core::option::Option<u32>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Validator {
    #[prost(string, optional, tag = "1")]
    pub soma_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub protocol_pubkey: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", optional, tag = "3")]
    pub network_pubkey: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", optional, tag = "4")]
    pub worker_pubkey: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(string, optional, tag = "5")]
    pub net_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "6")]
    pub p2p_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "7")]
    pub primary_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "8")]
    pub encoder_validator_address: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(uint64, optional, tag = "9")]
    pub voting_power: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "10")]
    pub commission_rate: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "11")]
    pub next_epoch_stake: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "12")]
    pub next_epoch_commission_rate: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "13")]
    pub staking_pool: ::core::option::Option<StakingPool>,
    /// Next epoch metadata (only if set)
    #[prost(bytes = "bytes", optional, tag = "14")]
    pub next_epoch_protocol_pubkey: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", optional, tag = "15")]
    pub next_epoch_network_pubkey: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", optional, tag = "16")]
    pub next_epoch_worker_pubkey: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(string, optional, tag = "17")]
    pub next_epoch_net_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "18")]
    pub next_epoch_p2p_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19")]
    pub next_epoch_primary_address: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "20")]
    pub next_epoch_encoder_validator_address: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StakingPool {
    #[prost(string, optional, tag = "1")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "2")]
    pub activation_epoch: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub deactivation_epoch: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "4")]
    pub soma_balance: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "5")]
    pub rewards_pool: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "6")]
    pub pool_token_balance: ::core::option::Option<u64>,
    #[prost(btree_map = "uint64, message", tag = "7")]
    pub exchange_rates: ::prost::alloc::collections::BTreeMap<
        u64,
        PoolTokenExchangeRate,
    >,
    #[prost(uint64, optional, tag = "8")]
    pub pending_stake: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "9")]
    pub pending_total_soma_withdraw: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "10")]
    pub pending_pool_token_withdraw: ::core::option::Option<u64>,
}
#[non_exhaustive]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PoolTokenExchangeRate {
    #[prost(uint64, optional, tag = "1")]
    pub soma_amount: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub pool_token_amount: ::core::option::Option<u64>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EncoderSet {
    #[prost(uint64, optional, tag = "1")]
    pub total_stake: ::core::option::Option<u64>,
    #[prost(message, repeated, tag = "2")]
    pub active_encoders: ::prost::alloc::vec::Vec<Encoder>,
    #[prost(message, repeated, tag = "3")]
    pub pending_active_encoders: ::prost::alloc::vec::Vec<Encoder>,
    #[prost(uint32, repeated, tag = "4")]
    pub pending_removals: ::prost::alloc::vec::Vec<u32>,
    /// pool_id -> encoder_address
    #[prost(btree_map = "string, string", tag = "5")]
    pub staking_pool_mappings: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// pool_id -> encoder
    #[prost(btree_map = "string, message", tag = "6")]
    pub inactive_encoders: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        Encoder,
    >,
    /// address -> epochs_at_risk
    #[prost(btree_map = "string, uint64", tag = "7")]
    pub at_risk_encoders: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        u64,
    >,
    #[prost(uint64, optional, tag = "8")]
    pub reference_byte_price: ::core::option::Option<u64>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Encoder {
    #[prost(string, optional, tag = "1")]
    pub soma_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub encoder_pubkey: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", optional, tag = "3")]
    pub network_pubkey: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(string, optional, tag = "4")]
    pub internal_network_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "5")]
    pub external_network_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "6")]
    pub object_server_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "7")]
    pub voting_power: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "8")]
    pub commission_rate: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "9")]
    pub next_epoch_stake: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "10")]
    pub next_epoch_commission_rate: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "11")]
    pub byte_price: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "12")]
    pub next_epoch_byte_price: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "13")]
    pub staking_pool: ::core::option::Option<StakingPool>,
    /// Next epoch metadata (only if set)
    #[prost(bytes = "bytes", optional, tag = "14")]
    pub next_epoch_network_pubkey: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(string, optional, tag = "15")]
    pub next_epoch_internal_network_address: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "16")]
    pub next_epoch_external_network_address: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "17")]
    pub next_epoch_object_server_address: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShardResult {
    #[prost(message, optional, tag = "1")]
    pub download_metadata: ::core::option::Option<DownloadMetadata>,
    #[prost(uint64, optional, tag = "2")]
    pub amount: ::core::option::Option<u64>,
    #[prost(bytes = "bytes", optional, tag = "3")]
    pub report: ::core::option::Option<::prost::bytes::Bytes>,
}
/// A transaction.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Transaction {
    /// The digest of this Transaction.
    #[prost(string, optional, tag = "1")]
    pub digest: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    pub kind: ::core::option::Option<TransactionKind>,
    #[prost(string, optional, tag = "3")]
    pub sender: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "4")]
    pub gas_payment: ::prost::alloc::vec::Vec<ObjectReference>,
}
/// Transaction type.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionKind {
    #[prost(
        oneof = "transaction_kind::Kind",
        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25"
    )]
    pub kind: ::core::option::Option<transaction_kind::Kind>,
}
/// Nested message and enum types in `TransactionKind`.
pub mod transaction_kind {
    #[non_exhaustive]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        /// Transaction used to initialize the chain state.
        ///
        /// Only valid if in the genesis checkpoint (0) and if this is the very first transaction ever
        /// executed on the chain.
        #[prost(message, tag = "1")]
        Genesis(super::GenesisTransaction),
        /// Consensus commit update.
        #[prost(message, tag = "2")]
        ConsensusCommitPrologue(super::ConsensusCommitPrologue),
        /// System transaction used to end an epoch..
        #[prost(message, tag = "3")]
        ChangeEpoch(super::ChangeEpoch),
        #[prost(message, tag = "4")]
        AddValidator(super::AddValidator),
        #[prost(message, tag = "5")]
        RemoveValidator(super::RemoveValidator),
        #[prost(message, tag = "6")]
        ReportValidator(super::ReportValidator),
        #[prost(message, tag = "7")]
        UndoReportValidator(super::UndoReportValidator),
        #[prost(message, tag = "8")]
        UpdateValidatorMetadata(super::UpdateValidatorMetadata),
        #[prost(message, tag = "9")]
        SetCommissionRate(super::SetCommissionRate),
        #[prost(message, tag = "10")]
        AddEncoder(super::AddEncoder),
        #[prost(message, tag = "11")]
        RemoveEncoder(super::RemoveEncoder),
        #[prost(message, tag = "12")]
        ReportEncoder(super::ReportEncoder),
        #[prost(message, tag = "13")]
        UndoReportEncoder(super::UndoReportEncoder),
        #[prost(message, tag = "14")]
        UpdateEncoderMetadata(super::UpdateEncoderMetadata),
        #[prost(message, tag = "15")]
        SetEncoderCommissionRate(super::SetEncoderCommissionRate),
        #[prost(message, tag = "16")]
        SetEncoderBytePrice(super::SetEncoderBytePrice),
        #[prost(message, tag = "17")]
        TransferCoin(super::TransferCoin),
        #[prost(message, tag = "18")]
        PayCoins(super::PayCoins),
        #[prost(message, tag = "19")]
        TransferObjects(super::TransferObjects),
        #[prost(message, tag = "20")]
        AddStake(super::AddStake),
        #[prost(message, tag = "21")]
        AddStakeToEncoder(super::AddStakeToEncoder),
        #[prost(message, tag = "22")]
        WithdrawStake(super::WithdrawStake),
        #[prost(message, tag = "23")]
        EmbedData(super::EmbedData),
        #[prost(message, tag = "24")]
        ClaimEscrow(super::ClaimEscrow),
        #[prost(message, tag = "25")]
        ReportWinner(super::ReportWinner),
    }
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddValidator {
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub pubkey_bytes: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub network_pubkey_bytes: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", optional, tag = "3")]
    pub worker_pubkey_bytes: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", optional, tag = "4")]
    pub net_address: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", optional, tag = "5")]
    pub p2p_address: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", optional, tag = "6")]
    pub primary_address: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", optional, tag = "7")]
    pub encoder_validator_address: ::core::option::Option<::prost::bytes::Bytes>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveValidator {
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub pubkey_bytes: ::core::option::Option<::prost::bytes::Bytes>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReportValidator {
    #[prost(string, optional, tag = "1")]
    pub reportee: ::core::option::Option<::prost::alloc::string::String>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UndoReportValidator {
    #[prost(string, optional, tag = "1")]
    pub reportee: ::core::option::Option<::prost::alloc::string::String>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateValidatorMetadata {
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub next_epoch_network_address: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub next_epoch_p2p_address: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", optional, tag = "3")]
    pub next_epoch_primary_address: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", optional, tag = "4")]
    pub next_epoch_protocol_pubkey: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", optional, tag = "5")]
    pub next_epoch_worker_pubkey: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", optional, tag = "6")]
    pub next_epoch_network_pubkey: ::core::option::Option<::prost::bytes::Bytes>,
}
#[non_exhaustive]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetCommissionRate {
    #[prost(uint64, optional, tag = "1")]
    pub new_rate: ::core::option::Option<u64>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddEncoder {
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub encoder_pubkey_bytes: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub network_pubkey_bytes: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", optional, tag = "3")]
    pub internal_network_address: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", optional, tag = "4")]
    pub external_network_address: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", optional, tag = "5")]
    pub object_server_address: ::core::option::Option<::prost::bytes::Bytes>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveEncoder {
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub encoder_pubkey_bytes: ::core::option::Option<::prost::bytes::Bytes>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReportEncoder {
    #[prost(string, optional, tag = "1")]
    pub reportee: ::core::option::Option<::prost::alloc::string::String>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UndoReportEncoder {
    #[prost(string, optional, tag = "1")]
    pub reportee: ::core::option::Option<::prost::alloc::string::String>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateEncoderMetadata {
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub next_epoch_external_network_address: ::core::option::Option<
        ::prost::bytes::Bytes,
    >,
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub next_epoch_internal_network_address: ::core::option::Option<
        ::prost::bytes::Bytes,
    >,
    #[prost(bytes = "bytes", optional, tag = "3")]
    pub next_epoch_network_pubkey: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", optional, tag = "4")]
    pub next_epoch_object_server_address: ::core::option::Option<::prost::bytes::Bytes>,
}
#[non_exhaustive]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetEncoderCommissionRate {
    #[prost(uint64, optional, tag = "1")]
    pub new_rate: ::core::option::Option<u64>,
}
#[non_exhaustive]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetEncoderBytePrice {
    #[prost(uint64, optional, tag = "1")]
    pub new_price: ::core::option::Option<u64>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransferCoin {
    #[prost(message, optional, tag = "1")]
    pub coin: ::core::option::Option<ObjectReference>,
    #[prost(uint64, optional, tag = "2")]
    pub amount: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3")]
    pub recipient: ::core::option::Option<::prost::alloc::string::String>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PayCoins {
    #[prost(message, repeated, tag = "1")]
    pub coins: ::prost::alloc::vec::Vec<ObjectReference>,
    #[prost(uint64, repeated, tag = "2")]
    pub amounts: ::prost::alloc::vec::Vec<u64>,
    #[prost(string, repeated, tag = "3")]
    pub recipients: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransferObjects {
    #[prost(message, repeated, tag = "1")]
    pub objects: ::prost::alloc::vec::Vec<ObjectReference>,
    #[prost(string, optional, tag = "2")]
    pub recipient: ::core::option::Option<::prost::alloc::string::String>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddStake {
    #[prost(string, optional, tag = "1")]
    pub address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    pub coin_ref: ::core::option::Option<ObjectReference>,
    #[prost(uint64, optional, tag = "3")]
    pub amount: ::core::option::Option<u64>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddStakeToEncoder {
    #[prost(string, optional, tag = "1")]
    pub encoder_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    pub coin_ref: ::core::option::Option<ObjectReference>,
    #[prost(uint64, optional, tag = "3")]
    pub amount: ::core::option::Option<u64>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WithdrawStake {
    #[prost(message, optional, tag = "1")]
    pub staked_soma: ::core::option::Option<ObjectReference>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Metadata {
    #[prost(oneof = "metadata::Version", tags = "1")]
    pub version: ::core::option::Option<metadata::Version>,
}
/// Nested message and enum types in `Metadata`.
pub mod metadata {
    #[non_exhaustive]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Version {
        #[prost(message, tag = "1")]
        V1(super::MetadataV1),
    }
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataV1 {
    /// 32-byte digest
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub checksum: ::core::option::Option<::prost::bytes::Bytes>,
    /// Size in bytes
    #[prost(uint64, optional, tag = "2")]
    pub size: ::core::option::Option<u64>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DefaultDownloadMetadataV1 {
    #[prost(string, optional, tag = "1")]
    pub url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    pub metadata: ::core::option::Option<Metadata>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DefaultDownloadMetadata {
    #[prost(oneof = "default_download_metadata::Version", tags = "1")]
    pub version: ::core::option::Option<default_download_metadata::Version>,
}
/// Nested message and enum types in `DefaultDownloadMetadata`.
pub mod default_download_metadata {
    #[non_exhaustive]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Version {
        #[prost(message, tag = "1")]
        V1(super::DefaultDownloadMetadataV1),
    }
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MtlsDownloadMetadataV1 {
    /// NetworkPublicKey bytes
    #[prost(bytes = "bytes", optional, tag = "1")]
    pub peer: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(string, optional, tag = "2")]
    pub url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "3")]
    pub metadata: ::core::option::Option<Metadata>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MtlsDownloadMetadata {
    #[prost(oneof = "mtls_download_metadata::Version", tags = "1")]
    pub version: ::core::option::Option<mtls_download_metadata::Version>,
}
/// Nested message and enum types in `MtlsDownloadMetadata`.
pub mod mtls_download_metadata {
    #[non_exhaustive]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Version {
        #[prost(message, tag = "1")]
        V1(super::MtlsDownloadMetadataV1),
    }
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DownloadMetadata {
    #[prost(oneof = "download_metadata::Kind", tags = "1, 2")]
    pub kind: ::core::option::Option<download_metadata::Kind>,
}
/// Nested message and enum types in `DownloadMetadata`.
pub mod download_metadata {
    #[non_exhaustive]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(message, tag = "1")]
        Default(super::DefaultDownloadMetadata),
        #[prost(message, tag = "2")]
        Mtls(super::MtlsDownloadMetadata),
    }
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EmbedData {
    #[prost(message, optional, tag = "1")]
    pub download_metadata: ::core::option::Option<DownloadMetadata>,
    #[prost(message, optional, tag = "2")]
    pub coin_ref: ::core::option::Option<ObjectReference>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClaimEscrow {
    #[prost(message, optional, tag = "1")]
    pub shard_input_ref: ::core::option::Option<ObjectReference>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReportWinner {
    #[prost(message, optional, tag = "1")]
    pub shard_input_ref: ::core::option::Option<ObjectReference>,
    #[prost(bytes = "bytes", optional, tag = "2")]
    pub signed_report: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bytes = "bytes", optional, tag = "3")]
    pub encoder_aggregate_signature: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(string, repeated, tag = "4")]
    pub signers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bytes = "bytes", optional, tag = "5")]
    pub shard_auth_token: ::core::option::Option<::prost::bytes::Bytes>,
}
/// System transaction used to change the epoch.
#[non_exhaustive]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChangeEpoch {
    /// The next (to become) epoch ID.
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    /// Unix timestamp when epoch started.
    #[prost(message, optional, tag = "2")]
    pub epoch_start_timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// The protocol version in effect in the new epoch.
    #[prost(uint64, optional, tag = "3")]
    pub protocol_version: ::core::option::Option<u64>,
    /// The total amount of fees charged during the epoch.
    #[prost(uint64, optional, tag = "4")]
    pub fees: ::core::option::Option<u64>,
}
/// The genesis transaction.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenesisTransaction {
    /// Set of genesis objects.
    #[prost(message, repeated, tag = "1")]
    pub objects: ::prost::alloc::vec::Vec<Object>,
}
/// Consensus commit prologue system transaction.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsensusCommitPrologue {
    /// Epoch of the commit prologue transaction.
    #[prost(uint64, optional, tag = "1")]
    pub epoch: ::core::option::Option<u64>,
    /// Consensus round of the commit.
    #[prost(uint64, optional, tag = "2")]
    pub round: ::core::option::Option<u64>,
    /// The sub DAG index of the consensus commit. This field is populated if there
    /// are multiple consensus commits per round.
    #[prost(uint64, optional, tag = "3")]
    pub sub_dag_index: ::core::option::Option<u64>,
    /// Unix timestamp from consensus.
    #[prost(message, optional, tag = "4")]
    pub commit_timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Digest of consensus output.
    #[prost(string, optional, tag = "5")]
    pub consensus_commit_digest: ::core::option::Option<::prost::alloc::string::String>,
    /// Digest of any additional state computed by the consensus handler.
    /// Used to detect forking bugs as early as possible.
    #[prost(string, optional, tag = "6")]
    pub additional_state_digest: ::core::option::Option<::prost::alloc::string::String>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteTransactionRequest {
    /// The transaction to execute.
    #[prost(message, optional, tag = "1")]
    pub transaction: ::core::option::Option<Transaction>,
    /// Set of `UserSignature`s authorizing the execution of the provided
    /// transaction.
    #[prost(message, repeated, tag = "2")]
    pub signatures: ::prost::alloc::vec::Vec<UserSignature>,
    /// Mask specifying which fields to read.
    /// If no mask is specified, defaults to `effects.status,checkpoint`.
    #[prost(message, optional, tag = "3")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Response message for `NodeService.ExecuteTransaction`.
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteTransactionResponse {
    #[prost(message, optional, tag = "1")]
    pub transaction: ::core::option::Option<ExecutedTransaction>,
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SimulateTransactionRequest {
    #[prost(message, optional, tag = "1")]
    pub transaction: ::core::option::Option<Transaction>,
    /// Mask specifying which fields to read.
    #[prost(message, optional, tag = "2")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Specify whether checks should be ENABLED (default) or DISABLED while executing the transaction
    #[prost(
        enumeration = "simulate_transaction_request::TransactionChecks",
        optional,
        tag = "3"
    )]
    pub checks: ::core::option::Option<i32>,
}
/// Nested message and enum types in `SimulateTransactionRequest`.
pub mod simulate_transaction_request {
    /// buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX
    #[non_exhaustive]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TransactionChecks {
        Enabled = 0,
        Disabled = 1,
    }
    impl TransactionChecks {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Enabled => "ENABLED",
                Self::Disabled => "DISABLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ENABLED" => Some(Self::Enabled),
                "DISABLED" => Some(Self::Disabled),
                _ => None,
            }
        }
    }
}
#[non_exhaustive]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SimulateTransactionResponse {
    #[prost(message, optional, tag = "1")]
    pub transaction: ::core::option::Option<ExecutedTransaction>,
}
/// Generated client implementations.
pub mod transaction_execution_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct TransactionExecutionServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl TransactionExecutionServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> TransactionExecutionServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> TransactionExecutionServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            TransactionExecutionServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn execute_transaction(
            &mut self,
            request: impl tonic::IntoRequest<super::ExecuteTransactionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ExecuteTransactionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/soma.rpc.TransactionExecutionService/ExecuteTransaction",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "soma.rpc.TransactionExecutionService",
                        "ExecuteTransaction",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn simulate_transaction(
            &mut self,
            request: impl tonic::IntoRequest<super::SimulateTransactionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SimulateTransactionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/soma.rpc.TransactionExecutionService/SimulateTransaction",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "soma.rpc.TransactionExecutionService",
                        "SimulateTransaction",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod transaction_execution_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with TransactionExecutionServiceServer.
    #[async_trait]
    pub trait TransactionExecutionService: std::marker::Send + std::marker::Sync + 'static {
        async fn execute_transaction(
            &self,
            request: tonic::Request<super::ExecuteTransactionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ExecuteTransactionResponse>,
            tonic::Status,
        >;
        async fn simulate_transaction(
            &self,
            request: tonic::Request<super::SimulateTransactionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SimulateTransactionResponse>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct TransactionExecutionServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> TransactionExecutionServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for TransactionExecutionServiceServer<T>
    where
        T: TransactionExecutionService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/soma.rpc.TransactionExecutionService/ExecuteTransaction" => {
                    #[allow(non_camel_case_types)]
                    struct ExecuteTransactionSvc<T: TransactionExecutionService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: TransactionExecutionService,
                    > tonic::server::UnaryService<super::ExecuteTransactionRequest>
                    for ExecuteTransactionSvc<T> {
                        type Response = super::ExecuteTransactionResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ExecuteTransactionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TransactionExecutionService>::execute_transaction(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ExecuteTransactionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/soma.rpc.TransactionExecutionService/SimulateTransaction" => {
                    #[allow(non_camel_case_types)]
                    struct SimulateTransactionSvc<T: TransactionExecutionService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: TransactionExecutionService,
                    > tonic::server::UnaryService<super::SimulateTransactionRequest>
                    for SimulateTransactionSvc<T> {
                        type Response = super::SimulateTransactionResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SimulateTransactionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TransactionExecutionService>::simulate_transaction(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SimulateTransactionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(
                            tonic::body::Body::default(),
                        );
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for TransactionExecutionServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "soma.rpc.TransactionExecutionService";
    impl<T> tonic::server::NamedService for TransactionExecutionServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Summary of the fee for this transaction.
#[non_exhaustive]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TransactionFee {
    /// base transaction fee.
    #[prost(uint64, optional, tag = "1")]
    pub base_fee: ::core::option::Option<u64>,
    /// Fee for each object operation (reads and writes).
    #[prost(uint64, optional, tag = "2")]
    pub operation_fee: ::core::option::Option<u64>,
    /// Fee based on transaction value.
    #[prost(uint64, optional, tag = "3")]
    pub value_fee: ::core::option::Option<u64>,
    /// Total fee deducted.
    #[prost(uint64, optional, tag = "4")]
    pub total_fee: ::core::option::Option<u64>,
}
